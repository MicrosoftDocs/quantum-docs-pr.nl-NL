---
title: Software stack | Microsoft Docs
description: Software stack
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184726"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="f2f9a-103">Software stack voor Quantum Computing</span><span class="sxs-lookup"><span data-stu-id="f2f9a-103">Software stack for quantum computing</span></span>
<span data-ttu-id="f2f9a-104">Normaal gesp roken wordt een computer voor één apparaat gebruikt, maar moderne computer omgevingen zijn veel complexer en Geavanceerd.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="f2f9a-105">De toepassing waarmee u communiceert, verloopt doorgaans op meerdere lagen software die de uitvoering van de toepassing naar het hardwareniveau bieden.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="f2f9a-106">Deze software lagen zijn nodig om de ontwikkeling van een toepassings oplossing uit de onderliggende complexiteit van het volledige computer systeem te abstracten.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="f2f9a-107">Als een ontwikkelaar heeft gedenkd over bus, cache architecturen, communicatie protocollen en meer tijdens het schrijven van een eenvoudige smartphone-app, zou de taak veel ingewik kelder worden.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="f2f9a-108">Het concept van een *software stack* is ontwikkeld in klassieke computing om deze problemen op te lossen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="f2f9a-109">Lenen van het klassieke concept is een software stack ook een belang rijk onderdeel van de visie achter Quantum Computing met Q #.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="f2f9a-110">Conventionele stack</span><span class="sxs-lookup"><span data-stu-id="f2f9a-110">Conventional stack</span></span>
<span data-ttu-id="f2f9a-111">Het belangrijkste idee achter een software stack is recursie.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="f2f9a-112">Het bestaat uit verschillende geneste lagen van interfaces waarmee de details van de lagere niveaus van het apparaat van de ontwikkelaar worden opgebouwd.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="f2f9a-113">Een veelgebruikte software stack omvat bijvoorbeeld het uitvoeren van ASP.NET (een programmeer taal), op SQL Server (een relationele Database Management System), die wordt uitgevoerd boven op Internet Information Services (een webserver), die wordt uitgevoerd op Windows Server (een besturings systeem), dat de computerhardware verstuurt.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="f2f9a-114">Door te kijken naar software als een hiërarchie, kan de ene software schrijven in ASP.NET zonder dat ze de details op laag niveau van alle bijbehorende software moeten begrijpen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="f2f9a-115">Quantum stack</span><span class="sxs-lookup"><span data-stu-id="f2f9a-115">Quantum stack</span></span>

<span data-ttu-id="f2f9a-116">De software stack in quantum computing is niet anders in principe en werkt in de praktijk op een lager niveau dan traditionele stacks.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="f2f9a-117">Hoe ziet een Quantum stack eruit?</span><span class="sxs-lookup"><span data-stu-id="f2f9a-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="f2f9a-118">Een quantum computer is geen vervanging voor traditionele (ook wel klassieke) computers genoemd.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="f2f9a-119">In feite zullen quantum computers vrijwel zeker samen werken met klassieke computers voor het oplossen van reken problemen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="f2f9a-120">Dit veroorzaakt deel uit de kwets bare Quantum gegevens.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="f2f9a-121">Quantum gegevens zijn zo kwetsbaar dat als u deze zelfs bekijkt, de informatie die wordt waargenomen, bijna zeker beschadigd is.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="f2f9a-122">Quantum computers moeten daarom worden ontworpen met een Quantum fout correctie, zodat de interacties van de fysieke omgeving niet per ongeluk de informatie en berekening kunnen beschadigen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="f2f9a-123">Daarom is een natuurlijk doel voor Q # een fout gecorrigeerde quantum computer (ook wel een *fout tolerante* quantum computer genoemd) die een lijst met Quantum instructies (Gates of poort bewerkingen genoemd) accepteert en die instructies toepast op de Quantum gegevens die in het bestand zijn opgeslagen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="f2f9a-124">Houd er rekening mee dat als het aantal qubits-en Gate-bewerkingen in een Quantum algoritme of programma klein genoeg is, de fout correctie mogelijk niet absoluut nood zakelijk is.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="f2f9a-125">Naarmate het aantal qubits-en poort bewerkingen groeit, is het beter om de software-stack en Q # te bouwen aan aptly en efficiënt fouten te corrigeren en schaal bare, fout tolerante Quantum Computing in te scha kelen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="f2f9a-126">Fout correctie</span><span class="sxs-lookup"><span data-stu-id="f2f9a-126">Error correction</span></span>
<span data-ttu-id="f2f9a-127">Voor fout correctie moet een snelle en betrouw bare klassieke computer in overleg met de quantum computer worden uitgevoerd om fouten te corrigeren zoals ze worden weer gegeven in de Quantum berekening.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="f2f9a-128">In de praktijk moeten onderdelen, zoals veld-Programmeer bare Gate arrays (Fpga's) of snelle Cryogenic-processors, nodig zijn om de fouten sneller te identificeren en te corrigeren dan ze in de quantum computer in natuurlijke richting oplopen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="f2f9a-129">Als gevolg hiervan is een quantum computer een hybride computer die bestaat uit verschillende reken apparaten die over een breed scala van Tempe raturen beschikken.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="f2f9a-130">Daarom is het veel handiger om te denken over het Program meren van een quantum computer via de lens van een software stack, omdat er veel hardware-en software lagen (klassiek en Quantum) nodig zijn om de implementatie van een quantum te verzorgen algoritme op een quantum computer.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="f2f9a-131">Quantum conceptuele stack</span><span class="sxs-lookup"><span data-stu-id="f2f9a-131">Quantum conceptual stack</span></span>
<span data-ttu-id="f2f9a-132">Hieronder ziet u een conceptuele stack die de functionele stroom van factor 8704143553785700723 in een quantum computer omgeving illustreert:</span><span class="sxs-lookup"><span data-stu-id="f2f9a-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Software stack](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="f2f9a-134">Specificatie en algoritme</span><span class="sxs-lookup"><span data-stu-id="f2f9a-134">Specification and algorithm</span></span>
<span data-ttu-id="f2f9a-135">Er zijn verschillende algemene fasen voor het Program meren van een dergelijke Quantum berekening.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="f2f9a-136">De eerste en weliswaar meest uitdagende fase geeft u het probleem op dat één wil oplossen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="f2f9a-137">In dit geval is het probleem het getal 8704143553785700723 te vermenigvuldigen met een product van twee priem cijfers.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="f2f9a-138">De volgende stap omvat het ontwerpen van een algoritme voor het oplossen van dit verwerkings probleem.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="f2f9a-139">In dit geval kan het beroemde Quantum Factory-algoritme van Shor worden gebruikt om de factoren te vinden.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="f2f9a-140">Dit algoritme wordt uitgedrukt in Q # en vervolgens wordt een reeks Quantum bewerkingen uitgevoerd die kunnen worden uitgevoerd op een computer met een ideale fout-Free Quantum.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="f2f9a-141">Fysieke Gates</span><span class="sxs-lookup"><span data-stu-id="f2f9a-141">Physical gates</span></span>
<span data-ttu-id="f2f9a-142">In dit voor beeld wordt ervan uitgegaan dat er een fout vrije quantum computer is, zodat de volgende stap de door Q # uitgelichte bewerkingen uitvoert en deze vertaalt met behulp van sjablonen die zijn opgegeven door de Quantum fout correctie methode die is gekozen in fysieke poorten die de basis-hardware kan worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="f2f9a-143">Dit proces omvat het vervangen van elke logische Qubit die wordt beschreven in het vorige model met een host van fysieke qubits die worden gebruikt voor het opslaan en beveiligen van de informatie binnen één Qubit op een redundante manier die lokale fouten op het fysieke niveau kan voor komen. qubits lang genoeg om dergelijke fouten te detecteren en te corrigeren.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="f2f9a-144">Net zoals de logische qubits die wordt beschreven door de Q #-code moet worden vervangen door veel fysieke qubits, op dezelfde manier moet elke Quantum-poort die in de uitvoer wordt beschreven, worden vertaald naar een reeks fysieke poorten die op de fysieke qubits handelen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="f2f9a-145">Daarom is de uitvoer van Q # zelden het uiteindelijke doel voor Quantum Computing en zijn er verdere abstractie niveaus nodig om de code op hardware in een Oblivious te kunnen uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="f2f9a-146">Beheer computer</span><span class="sxs-lookup"><span data-stu-id="f2f9a-146">Control computer</span></span>
<span data-ttu-id="f2f9a-147">De fysieke poort reeks wordt vervolgens geladen in een gewone computer die deze instructies verzendt naar een beheer computer die rechtstreeks interfaces met de quantum computer doorgeeft.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="f2f9a-148">Deze laag in de software stack wordt vaak verwerkt door experimentele controle software, zoals [QCoDeS](http://qcodes.github.io/Qcodes/).</span><span class="sxs-lookup"><span data-stu-id="f2f9a-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="f2f9a-149">Interface computer</span><span class="sxs-lookup"><span data-stu-id="f2f9a-149">Interface computer</span></span>
<span data-ttu-id="f2f9a-150">De laatste stap in dit proces is dat de interface computer eerst de poorten moet streamen die nodig zijn voor een snelle controle computer.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="f2f9a-151">De Fast Control-computer past vervolgens de benodigde spanningen (vaak pulsen genoemd) toe om de vereiste poorten op qubits te implementeren.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="f2f9a-152">Dit moet worden gedaan bij het corrigeren van fouten die worden waargenomen door middel van een Quantum fout correctie.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="f2f9a-153">Cryogenic Fpga's of andere exotische hardware kan nodig zijn om deze stappen uit te voeren binnen de strikte tijd vereisten die zijn opgelegd door de snelheid waarmee fouten worden weer gegeven op de quantum computer.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="f2f9a-154">De doel taal op dit niveau is vaak [VHDL](https://en.wikipedia.org/wiki/VHDL), wat een unieke manier moet bedenken die wordt gebruikt in het bovenste uiteinde van de stack om een beschrijving van een Quantum algoritme te parseren.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="f2f9a-155">De ' Q # Quantum-programmeer taal</span><span class="sxs-lookup"><span data-stu-id="f2f9a-155">The Q# quantum programming language</span></span>
<span data-ttu-id="f2f9a-156">Het doel van Q # is om een eenvoudige taal te bieden waarmee ontwikkel aars code kunnen schrijven die gericht is op een schat aan Quantum Computing platformen en interface met de tussenliggende lagen van software die tussen de gebruiker en het Quantum apparaat staan.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="f2f9a-157">De taal vereenvoudigt dit door het begrip van een software stack te maken en veel van de details van de onderliggende quantum computer samen te stellen, terwijl er C#nog andere niveaus van de stack beschikbaar zijn, zodat deze de benodigde vertalingen van Q #-code naar fundamentele bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="f2f9a-158">Zo kan de ontwikkelaar zich richten op wat ze het beste doen: algoritmen ontwerpen en problemen oplossen.</span><span class="sxs-lookup"><span data-stu-id="f2f9a-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
