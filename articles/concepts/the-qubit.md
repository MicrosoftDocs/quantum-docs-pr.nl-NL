---
title: De Qubit in Quantum Computing
description: Meer informatie over qubits, de basis eenheid van informatie in Quantum Computing.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 770b739d95f5c1512234f6f7d2ca4544f1d80e64
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907525"
---
# <a name="the-qubit"></a><span data-ttu-id="76916-103">De Qubit</span><span class="sxs-lookup"><span data-stu-id="76916-103">The Qubit</span></span>

<span data-ttu-id="76916-104">Net als bits is het belangrijkste object van informatie in klassieke computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (Quantum bits) het belangrijkste object van informatie in Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="76916-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="76916-105">We kijken naar het eenvoudigste voor beeld om deze correspondentie te begrijpen: één Qubit.</span><span class="sxs-lookup"><span data-stu-id="76916-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="76916-106">Een Qubit vertegenwoordigt</span><span class="sxs-lookup"><span data-stu-id="76916-106">Representing a Qubit</span></span>

<span data-ttu-id="76916-107">Hoewel een bit, of binair cijfer, een waarde van $0 $ of $1 $ kan hebben, kan een Qubit een waarde hebben die een van deze twee of een Quantum-superpositie van $0 $ en $1 $ kan hebben.</span><span class="sxs-lookup"><span data-stu-id="76916-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="76916-108">De status van één qubit kan worden beschreven met behulp van een tweedimensionale kolom vector van de eenheids norm, dat wil zeggen dat de grootte van de items in het kwadraat moet worden opgeteld bij $1 $.</span><span class="sxs-lookup"><span data-stu-id="76916-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="76916-109">Deze vector, de Quantum-status vector, bevat alle informatie die nodig is om het Quantum systeem van één Qubit te beschrijven, net als een enkele bit, met alle informatie die nodig is om de status van een binaire variabele te beschrijven.</span><span class="sxs-lookup"><span data-stu-id="76916-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="76916-110">Een tweedimensionale kolom vector van reële of complexe getallen met norm $1 $ vertegenwoordigt een mogelijke Quantum status die door een Qubit wordt gehouden.</span><span class="sxs-lookup"><span data-stu-id="76916-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="76916-111">Dus $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ vertegenwoordigt een Qubit-status als $ \alpha $ en $ \beta $ complexe getallen zijn die voldoen aan $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="76916-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="76916-112">Enkele voor beelden van geldige Quantum status vectoren die qubits bevatten</span><span class="sxs-lookup"><span data-stu-id="76916-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="76916-113">$ $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}, \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{-1}{\sqrt{2}} \end{bmatrix}, \Text{en} \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\ \frac{i}{\sqrt{2}} \end{bmatrix}. $ $</span><span class="sxs-lookup"><span data-stu-id="76916-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="76916-114">De Quantum status vectors $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $ en $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $ een speciale rol nemen.</span><span class="sxs-lookup"><span data-stu-id="76916-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="76916-115">Deze twee vectoren vormen een basis voor de vector ruimte die de status van de Qubit beschrijft.</span><span class="sxs-lookup"><span data-stu-id="76916-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="76916-116">Dit betekent dat elke Quantum status vector kan worden geschreven als een som van deze basis vectoren.</span><span class="sxs-lookup"><span data-stu-id="76916-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="76916-117">Met name de vector $ \begin{bmatrix} x \\\\ y \end{bmatrix} $ kan worden geschreven als $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="76916-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="76916-118">Hoewel elke draaiing van deze vectoren als een volledig geldige basis voor de Qubit fungeert, kiezen we de bevoegdheid om dit te doen door de *berekening*uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="76916-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="76916-119">We nemen deze twee Quantum Staten in overeenstemming met de twee staten van een klassieke bit, namelijk $0 $ en $1 $.</span><span class="sxs-lookup"><span data-stu-id="76916-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="76916-120">De standaard Conventie is om te kiezen</span><span class="sxs-lookup"><span data-stu-id="76916-120">The standard convention is to choose</span></span>

<span data-ttu-id="76916-121">$ $0 \ equiv \begin{bmatrix} 1 \\\\ 0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix}, $ $</span><span class="sxs-lookup"><span data-stu-id="76916-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="76916-122">Hoewel de tegenovergestelde keuze kan gelijkelijk worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="76916-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="76916-123">Daarom is er een oneindig aantal mogelijke Quantum status vectoren met één Qubit, maar beide komen overeen met de statussen van klassieke bits; alle andere Quantum statussen doen dit niet.</span><span class="sxs-lookup"><span data-stu-id="76916-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="76916-124">Een Qubit meten</span><span class="sxs-lookup"><span data-stu-id="76916-124">Measuring a Qubit</span></span>

<span data-ttu-id="76916-125">Nu we weten hoe u een Qubit kunt vertegenwoordigen, kunnen we een Intuition verkrijgen voor wat deze provincies vertegenwoordigen door het concept van [*meting*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics)te bespreken.</span><span class="sxs-lookup"><span data-stu-id="76916-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="76916-126">Een meting komt overeen met het informele idee van ' lookd ' op een Qubit, waarmee de Quantum status onmiddellijk wordt samengevouwen in een van de twee klassieke Staten $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $ of $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="76916-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="76916-127">Wanneer een Qubit gegeven door de Quantum status vector $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ wordt gemeten, krijgen we het resultaat $0 $ met kans $ | \alpha | ^ 2 $ en de uitkomst $1 $ met kans $ | \beta | ^ 2 $.</span><span class="sxs-lookup"><span data-stu-id="76916-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="76916-128">Op de uitkomst $0 $ is de nieuwe status van de Qubit $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $; op de uitkomst $1 $ is de status $ \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="76916-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="76916-129">Houd er rekening mee dat deze waarschijnlijkheid tot $1 $ optelt vanwege de normalisatie voorwaarde $ | \alpha | ^ 2 + | \beta | ^ 2 = $1.</span><span class="sxs-lookup"><span data-stu-id="76916-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="76916-130">De eigenschappen van meting betekenen ook dat het algemene teken van de Quantum State-vector niet van belang is.</span><span class="sxs-lookup"><span data-stu-id="76916-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="76916-131">Het negeren van een vector is gelijk aan $ \alpha \rightarrow-\alpha $ en $ \beta \rightarrow-\beta $.</span><span class="sxs-lookup"><span data-stu-id="76916-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="76916-132">Omdat de waarschijnlijkheid van het meten van $0 $ en $1 $ afhankelijk is van de grootte van de voor waarden, is het invoegen van dergelijke tekens niet van invloed op de waarschijnlijkheid.</span><span class="sxs-lookup"><span data-stu-id="76916-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="76916-133">Dergelijke fasen worden meestal [\`\`*globale fasen*](https://en.wikipedia.org/wiki/Phase_factor) genoemd en kunnen in het algemeen van het formulier $e ^ {i \phi} $ en niet alleen $ \pm $1.</span><span class="sxs-lookup"><span data-stu-id="76916-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="76916-134">Een laatste belang rijke eigenschap van meting is dat het niet nood zakelijk is om alle Quantum status vectoren te beschadigen.</span><span class="sxs-lookup"><span data-stu-id="76916-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="76916-135">Als we beginnen met een Qubit in de staat $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} $, die overeenkomt met de klassieke staat $0 $, geeft deze status altijd het resultaat $0 $ en wordt de Quantum status ongewijzigd gelaten.</span><span class="sxs-lookup"><span data-stu-id="76916-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="76916-136">Als we in deze zin alleen klassieke bits hebben (qubits die $ \begin{bmatrix}1 \\\\ 0 \end{bmatrix} $ of $ \begin{bmatrix}0 \\\\ 1 \end{bmatrix} $), wordt het systeem door meting niet beschadigd.</span><span class="sxs-lookup"><span data-stu-id="76916-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="76916-137">Dit betekent dat we klassieke gegevens kunnen repliceren en bewerken op een quantum computer, net als bij een klassieke computer.</span><span class="sxs-lookup"><span data-stu-id="76916-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="76916-138">De mogelijkheid om gegevens in beide staten tegelijk op te slaan, is wat een grotere verfijning van Quantum Computing overschrijdt dan wat mogelijk op klassieke en andere Robs quantum computers van de mogelijkheid om Quantum gegevens te kopiëren, zie ook [de theorema zonder klonen](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="76916-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="76916-139">Qubits en trans formaties visualiseren met behulp van de Bloch-bol</span><span class="sxs-lookup"><span data-stu-id="76916-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="76916-140">Qubits kan ook in $3 $ D worden afgebeeld met behulp van de weer gave [*Bloch Sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="76916-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="76916-141">De Bloch-bol biedt een manier om een Quantum status met één Qubit te beschrijven (dit is een tweedimensionale, complexe vector) als een driedimensionale vector.</span><span class="sxs-lookup"><span data-stu-id="76916-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="76916-142">Dit is belang rijk omdat het ons de mogelijkheid biedt om Qubit te visualiseren en daarom redenen te ontwikkelen die ingrijpend kunnen zijn in de statussen van meerdere Qubit (waarbij Sadly de Bloch Sphere-weer gave inzoomt).</span><span class="sxs-lookup"><span data-stu-id="76916-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="76916-143">De Bloch-bol kan als volgt worden gevisualiseerd:</span><span class="sxs-lookup"><span data-stu-id="76916-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="76916-144">![Bloche Sphere](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="76916-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="76916-145">De pijlen in dit diagram tonen de richting waarin de Quantum status vector wijst en elke trans formatie van de pijl kan worden beschouwd als een rotatie over een van de assen.</span><span class="sxs-lookup"><span data-stu-id="76916-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="76916-146">Het is een goed idee om met behulp van deze Intuition de algoritmen te ontwerpen en te beschrijven, terwijl u overweegt een Quantum berekening uit te geven als een reeks rotaties een krachtige Intuition is.</span><span class="sxs-lookup"><span data-stu-id="76916-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="76916-147">Q # vermindert dit probleem door een taal te bieden voor het beschrijven van dergelijke draaiingen.</span><span class="sxs-lookup"><span data-stu-id="76916-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="76916-148">Single-Qubit bewerkingen</span><span class="sxs-lookup"><span data-stu-id="76916-148">Single-Qubit Operations</span></span>

<span data-ttu-id="76916-149">Quantum computers verwerken gegevens door een universele set Quantum-Gates toe te passen waarmee de draai hoek van de Quantum status vector kan worden geëmuleerd.</span><span class="sxs-lookup"><span data-stu-id="76916-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="76916-150">Dit voor stel van universality is Akin naar het principe van de universele kracht voor traditionele (klassieke) computing waarbij een poortset als universeel wordt beschouwd als elke trans formatie van de invoer bits kan worden uitgevoerd met behulp van een circuit met een eindige lengte.</span><span class="sxs-lookup"><span data-stu-id="76916-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="76916-151">In Quantum Computing zijn de geldige trans formaties die we mogen uitvoeren op een Qubit, unitary trans formaties en meting.</span><span class="sxs-lookup"><span data-stu-id="76916-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="76916-152">De *adjoint-bewerking* of de complex geconjugeerde getransponeerde is van cruciaal belang voor Quantum Computing, omdat het nodig is om Quantum trans formaties te omkeren.</span><span class="sxs-lookup"><span data-stu-id="76916-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="76916-153">Q # weerspiegelt dit door methoden te bieden voor het automatisch compileren van Gate-reeksen aan hun adjoint, waarmee de programmeur in veel gevallen de code van de hand kan adjoints.</span><span class="sxs-lookup"><span data-stu-id="76916-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="76916-154">Hieronder ziet u een voor beeld van dit:</span><span class="sxs-lookup"><span data-stu-id="76916-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="76916-155">Hoewel dit een gelastig voor beeld is (als de <xref:microsoft.quantum.intrinsic.h>-bewerking zelf adjoint is), ziet u hoe dit inwaardevol wordt voor complexere Qubit bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="76916-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="76916-156">Zie [bewerkingen en functies](xref:microsoft.quantum.techniques.opsandfunctions)voor meer informatie.</span><span class="sxs-lookup"><span data-stu-id="76916-156">For more information, see [Operations and Functions](xref:microsoft.quantum.techniques.opsandfunctions).</span></span>

<span data-ttu-id="76916-157">Er zijn slechts vier functies die één bit aan één bit op een klassieke computer toewijzen.</span><span class="sxs-lookup"><span data-stu-id="76916-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="76916-158">Daarentegen is er een oneindig aantal unitary-trans formaties op één Qubit op een quantum computer.</span><span class="sxs-lookup"><span data-stu-id="76916-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="76916-159">Daarom kan een beperkte set primitieve Quantum bewerkingen, die [*Gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate)worden genoemd, de oneindige set unitary-trans formaties die zijn toegestaan in de Quantum Computing, exact repliceren.</span><span class="sxs-lookup"><span data-stu-id="76916-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="76916-160">Dit betekent dat, in tegens telling tot klassieke computing, het onmogelijk is dat een quantum computer elk mogelijk Quantum programma implementeert, precies met een eindige hoeveelheid poorten.</span><span class="sxs-lookup"><span data-stu-id="76916-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="76916-161">Daarom kunnen quantum computers niet universeel zijn in dezelfde zin van klassieke computers.</span><span class="sxs-lookup"><span data-stu-id="76916-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="76916-162">Als we er rekening mee houden dat een reeks poorten *universeel* is voor Quantum Computing, hebben we eigenlijk iets zwakkerer dan voor klassiek computing.</span><span class="sxs-lookup"><span data-stu-id="76916-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="76916-163">Voor universality is het vereist dat een quantum computer alleen elke unitary-matrix binnen een eindige fout *benadert* met behulp van een poort reeks met een eind lengte.</span><span class="sxs-lookup"><span data-stu-id="76916-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="76916-164">Met andere woorden, een reeks poorten is een universele Gate-set als een unitary-trans formatie ongeveer als een product van poorten van deze set kan worden geschreven.</span><span class="sxs-lookup"><span data-stu-id="76916-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="76916-165">Het is vereist dat voor elke vereiste fout gebonden poorten bestaan $G _{1}, G_{2}, \ldots, G_N $ van de poort set zodanig dat</span><span class="sxs-lookup"><span data-stu-id="76916-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="76916-166">$ $ G_N G_ {N-1} \cdots G_2 G_1 \approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="76916-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="76916-167">Houd er rekening mee dat de Conventie voor het vermenigvuldigen van de matrix van rechts naar links de eerste poort bewerking in deze volg orde moet worden $G _N $, in feite de laatste is toegepast op de Quantum status vector.</span><span class="sxs-lookup"><span data-stu-id="76916-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="76916-168">Formeel, we zeggen dat een dergelijke Gate set universeel is als er voor elke fout tolerantie $ \epsilon > 0 $ bestaat $G _1, \ldots, G_N $ zodanig dat de afstand tussen $G _N \ldots G_1 $ en $U $ Maxi maal $ \epsilon $ is.</span><span class="sxs-lookup"><span data-stu-id="76916-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="76916-169">In het ideale geval de waarde van $N $ die nodig is om deze afstand van $ \epsilon $ te bereiken, moet poly-logarithmically met $1/\ Epsilon $ worden geschaald.</span><span class="sxs-lookup"><span data-stu-id="76916-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="76916-170">Hoe ziet een universele Gate-set eruit als in de praktijk?</span><span class="sxs-lookup"><span data-stu-id="76916-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="76916-171">De meest eenvoudige, universele Gate-set voor single-Qubit-poorten bestaat uit slechts twee poorten: de Hadamard-poort $H $ en de zogenaamde $T $-Gate (ook wel de $ \ Pi/8 $ Gate):</span><span class="sxs-lookup"><span data-stu-id="76916-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="76916-172">$ $ H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 &-1 \end{bmatrix}, \qquad T = \begin{bmatrix} 1 & 0 \\\\ 0 & e ^ {i \ Pi/4} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="76916-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="76916-173">Om praktische redenen met betrekking tot de Quantum-fout correctie kan het echter handiger zijn om een grotere poortset te gebruiken. Dit is namelijk een reeks die kan worden gegenereerd met $H $ en $T $.</span><span class="sxs-lookup"><span data-stu-id="76916-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="76916-174">We kunnen de Quantum-poorten in twee categorieën classificeren: Clifford Gates en de $T $-Gate.</span><span class="sxs-lookup"><span data-stu-id="76916-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="76916-175">Deze onderverdeling is nuttig omdat in veel Quantum-fout correctie schema's de zogenaamde Clifford-poorten gemakkelijk te implementeren zijn, dat wil zeggen dat ze zeer weinig bronnen nodig hebben voor de bewerkingen en qubits om fout tolerant te implementeren, terwijl niet-Clifford-poorten tamelijk kostbaar wanneer fout tolerantie is vereist.</span><span class="sxs-lookup"><span data-stu-id="76916-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="76916-176">De standaardset single-Qubit Clifford-Gates, [standaard opgenomen in Q #](xref:microsoft.quantum.libraries.standard.prelude), bevatten</span><span class="sxs-lookup"><span data-stu-id="76916-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="76916-177">$ $ H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ 1 &-1 \end{bmatrix}, \qquad S = \begin{bmatrix} 1 & 0 \\\\ 0 & i \end{bmatrix} = T ^ 2, \qquad X = \begin{bmatrix} 0 & 1 \\\\ 1 & 0 \end{bmatrix} = HT ^ 4U, $ $</span><span class="sxs-lookup"><span data-stu-id="76916-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="76916-178">$ $ Y = \begin{bmatrix} 0 &-i \\\\ i & 0 \end{bmatrix} = T ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{bmatrix}1 & 0\\\\ 0 &-1 \end{bmatrix} = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="76916-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="76916-179">Hier worden de bewerkingen $X $, $Y $ en $Z $ vaak gebruikt en worden [*Pauli Opera tors*](https://en.wikipedia.org/wiki/Pauli_matrices) genoemd na de maker Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="76916-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="76916-180">Samen met de niet-Clifford-poort (de $T $-Gate) kunnen deze bewerkingen worden samengesteld om een unitary-trans formatie op één Qubit te benaderen.</span><span class="sxs-lookup"><span data-stu-id="76916-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="76916-181">Zie [intrinsieke bewerkingen en functies](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions)voor meer informatie over deze bewerkingen, hun Bloch Sphere-representaties en Q #-implementaties.</span><span class="sxs-lookup"><span data-stu-id="76916-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="76916-182">Als voor beeld van hoe unitary-trans formaties kunnen worden gebouwd uit deze primitieven, komen de drie trans formaties in de bovenstaande Bloch-gebieden overeen met de poort reeks $ \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} $.</span><span class="sxs-lookup"><span data-stu-id="76916-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="76916-183">Hoewel het vorige de meest populaire primitieve poorten vormt voor het beschrijven van bewerkingen op het logische niveau van de stack (denk aan het logische niveau als het niveau van het Quantum algoritme), is het vaak handig om minder elementaire bewerkingen op het algoritme te overwegen niveau, bijvoorbeeld bewerkingen dichter bij een beschrijvings niveau van de functie.</span><span class="sxs-lookup"><span data-stu-id="76916-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="76916-184">Gelukkig heeft Q # ook methoden die beschikbaar zijn voor het implementeren van unitaries op een hoger niveau, waardoor het mogelijk is dat algoritmen op hoog niveau worden geïmplementeerd zonder dat alles expliciet wordt opsamengesteld naar Clifford en $T $-Gates.</span><span class="sxs-lookup"><span data-stu-id="76916-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="76916-185">De eenvoudigste manier om een dergelijke primitieve te zijn, is de enkele Qubit.</span><span class="sxs-lookup"><span data-stu-id="76916-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="76916-186">Drie rotaties met één Qubit worden meestal beschouwd: $R _x $, $R _y $ en $R _z $.</span><span class="sxs-lookup"><span data-stu-id="76916-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="76916-187">Als u de actie van de draai $R _x (\theta) $ wilt visualiseren, kunt u bijvoorbeeld een voor beeld van de rechter muisknop geven aan de richting van de $x $-as van de Bloch-bol en de vector met uw hand in een hoek van $ \ theta/2 $ radialen draaien.</span><span class="sxs-lookup"><span data-stu-id="76916-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="76916-188">Deze onduidelijke factor van $2 $ ontstaat uit het feit dat de rechthoekige vectoren $180 ^ \circ $ van elkaar worden weer gegeven op de Bloch-bol, maar eigenlijk $90 ^ \circ $ graden onafhankelijk van elkaar liggen.</span><span class="sxs-lookup"><span data-stu-id="76916-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="76916-189">De bijbehorende unitary-matrices zijn:</span><span class="sxs-lookup"><span data-stu-id="76916-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="76916-190">\begin{align *} & R_z (\theta) = e ^ {-I\theta z/2} = \begin{bmatrix} e ^ {-i \ theta/2} & 0\\\\ 0 & e ^ {i \ theta/2} \end{bmatrix}, \\\\ & R_x (\theta) = e ^ {-I\theta x/2} = HR_z (\theta) H = \begin{bmatrix} \cos (\ theta/2) &-i\sin (\ theta/2)\\\\-i\sin (\ theta/2) & \cos (\ theta/2) \end{bmatrix}, \\\\ & R_y (\theta) = e ^ {-I\theta y/2} = SHR_z (\theta) HS ^ \dagger = \begin{bmatrix} \cos (\ theta/2) &-\sin (\ theta/2)\\\\ \sin (\ theta/2) & \cos (\ theta/2) \end{bmatrix}. \end{align*}</span><span class="sxs-lookup"><span data-stu-id="76916-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="76916-191">Net zoals drie draaiingen kunnen samen worden gecombineerd om een wille keurige draaiing uit te voeren in drie dimensies, kan deze worden gezien vanuit de Bloch-weer gave van een wille keurige unitary-matrix, die ook kan worden geschreven als een reeks van drie rotaties.</span><span class="sxs-lookup"><span data-stu-id="76916-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="76916-192">Voor elke unitary matrix $U $ bestaat er $ \alpha, \beta, \gamma, \delta $ zodanig dat $U = e ^ {i\alpha} R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="76916-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="76916-193">$R _z (\theta) $ en $H $ vormen dus ook een universele Gate-set, hoewel het geen discrete set is, omdat $ \theta $ een wille keurige waarde kan hebben.</span><span class="sxs-lookup"><span data-stu-id="76916-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="76916-194">Om deze reden en als gevolg van toepassingen in Quantum simulatie zijn deze voortdurende poorten cruciaal voor de Quantum berekening, met name op het niveau van de Quantum algoritme.</span><span class="sxs-lookup"><span data-stu-id="76916-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="76916-195">Om fout tolerante hardware-implementatie te kunnen uitvoeren, worden deze uiteindelijk gecompileerd in afzonderlijke poort reeksen die nauw keurig deze rotaties benaderen.</span><span class="sxs-lookup"><span data-stu-id="76916-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
