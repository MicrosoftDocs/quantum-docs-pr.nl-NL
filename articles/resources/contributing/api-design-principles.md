---
title: 'Q# Ontwerp principes van API'
description: 'Q# Ontwerp principes van API'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 6b196cf1be584a3157c7a9eb8cf497fe1121dd7a
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92691824"
---
# <a name="no-locq-api-design-principles"></a><span data-ttu-id="3ab78-103">Q# Ontwerp principes van API</span><span class="sxs-lookup"><span data-stu-id="3ab78-103">Q# API Design Principles</span></span>

## <a name="introduction"></a><span data-ttu-id="3ab78-104">Inleiding</span><span class="sxs-lookup"><span data-stu-id="3ab78-104">Introduction</span></span>

<span data-ttu-id="3ab78-105">Als taal en als platform bieden gebruikers de mogelijkheid Q# om Quantum toepassingen te schrijven, uit te voeren, te begrijpen en te verkennen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-105">As a language and as a platform, Q# empowers users to write, run, understand, and explore quantum applications.</span></span>
<span data-ttu-id="3ab78-106">Om gebruikers in staat te stellen, wanneer we Q# bibliotheken ontwerpen, volgen we een aantal API-ontwerp principes voor het begeleiden van onze ontwerpen en om ons te helpen bij het maken van bruikbare bibliotheken voor de Quantum Development Community.</span><span class="sxs-lookup"><span data-stu-id="3ab78-106">In order to empower users, when we design Q# libraries, we follow a set of API design principles to guide our designs and to help us make usable libraries for the the quantum development community.</span></span>
<span data-ttu-id="3ab78-107">Dit artikel bevat een overzicht van deze principes en biedt voor beelden om te leren hoe u deze toepast tijdens het ontwerpen van Q# api's.</span><span class="sxs-lookup"><span data-stu-id="3ab78-107">This article lists these principles, and gives examples to help guide how to apply them when designing Q# APIs.</span></span>

> [!TIP]
> <span data-ttu-id="3ab78-108">Dit is een redelijk gedetailleerd document dat is bedoeld om de ontwikkeling van bibliotheken en diep gaande bibliotheek bijdragen te helpen begeleiden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-108">This is a fairly detailed document that's intended to help guide library development and in-depth library contributions.</span></span>
> <span data-ttu-id="3ab78-109">Waarschijnlijk zult u het het beste vinden als u uw eigen bibliotheken schrijft Q# of als u grotere functies bijwerkt naar de [ Q# opslag plaats van de tape wisselaar](https://github.com/microsoft/QuantumLibraries).</span><span class="sxs-lookup"><span data-stu-id="3ab78-109">You'll probably find it most useful if you're writing your own libraries in Q#, or if you're contributing larger features to the [Q# libraries repository](https://github.com/microsoft/QuantumLibraries).</span></span>
>
> <span data-ttu-id="3ab78-110">Als u daarentegen meer wilt weten hoe u een bijdrage levert aan de Quantum Development Kit in het algemeen, kunt u beginnen met de [bijdrage gids](xref:microsoft.quantum.contributing).</span><span class="sxs-lookup"><span data-stu-id="3ab78-110">On the other hand, if you're looking to learn how to contribute to the Quantum Development Kit more generally, we suggest starting with the [contribution guide](xref:microsoft.quantum.contributing).</span></span>
> <span data-ttu-id="3ab78-111">Als u meer algemene informatie wilt over de manier waarop we uw Q# code kunnen opmaken, bent u mogelijk geïnteresseerd in het uitchecken van de [stijl gids](xref:microsoft.quantum.contributing.style).</span><span class="sxs-lookup"><span data-stu-id="3ab78-111">If you're looking for more general information about how we recommend formatting your Q# code, you may be interested in checking out the [style guide](xref:microsoft.quantum.contributing.style).</span></span>

## <a name="general-principles"></a><span data-ttu-id="3ab78-112">Algemene principes</span><span class="sxs-lookup"><span data-stu-id="3ab78-112">General Principles</span></span>

<span data-ttu-id="3ab78-113">**Sleutel principe:** Stel Api's beschikbaar die de focus op Quantum toepassingen plaatsen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-113">**Key principle:** Expose APIs that places the focus on quantum applications.</span></span>

- <span data-ttu-id="3ab78-114">✅**Kies bewerkingen** en functie namen die de structuur van algoritmen en toepassingen op hoog niveau weer spie gelen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-114">✅ **DO** choose operation and function names that reflect the   high-level structure of algorithms and applications.</span></span>
- <span data-ttu-id="3ab78-115">⛔️ **geen** api's beschikbaar stellen die voornamelijk gericht zijn op implementatie details op laag niveau.</span><span class="sxs-lookup"><span data-stu-id="3ab78-115">⛔️ **DON'T** expose APIs that focus primarily on low-level   implementation details.</span></span>

<span data-ttu-id="3ab78-116">**Sleutel principe:** Begin elk API-ontwerp met voorbeeld cases om ervoor te zorgen dat Api's intuïtief zijn voor gebruik.</span><span class="sxs-lookup"><span data-stu-id="3ab78-116">**Key principle:** Start each API design with sample use cases to ensure that APIs are intuitive to use.</span></span>

- <span data-ttu-id="3ab78-117">✅**Zorg ervoor dat** elk onderdeel van een open bare API een bijbehorende use-case heeft, in plaats van te ontwerpen voor alle mogelijke toepassingen vanaf het begin.</span><span class="sxs-lookup"><span data-stu-id="3ab78-117">✅ **DO** ensure that each component of a public API has a corresponding use case, rather than trying to design for all possible uses from the start.</span></span>
    <span data-ttu-id="3ab78-118">Leg anders geen open bare Api's toe als ze nuttig zijn, maar zorg ervoor dat elk deel van een API een *concreet* voor beeld heeft waarin het handig is.</span><span class="sxs-lookup"><span data-stu-id="3ab78-118">Put differently, don't introduce public APIs in case they are useful, but make sure that each part of an API has a *concrete* example in which it will be useful.</span></span>

  <span data-ttu-id="3ab78-119">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-119">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-120">@"microsoft.quantum.canon.applytoeachca" kan worden gebruikt `ApplyToEachCA(H, _)` voor het voorbereiden van registers in een uniforme superpositie status, een veelvoorkomende taak in veel Quantum algoritmen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-120">@"microsoft.quantum.canon.applytoeachca" can be used as `ApplyToEachCA(H, _)` to prepare registers in a uniform superposition state, a common task in many quantum algorithms.</span></span> <span data-ttu-id="3ab78-121">Dezelfde bewerking kan ook worden gebruikt voor veel andere taken in voor bereiding, numerieke tekens en op Oracle gebaseerde algoritmen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-121">The same operation can also be used for many other tasks in preparation, numerics, and oracle-based algorithms.</span></span>

- <span data-ttu-id="3ab78-122">✅**Maak** brainstorm en workshop nieuwe API-ontwerpen om te controleren of ze intuïtief zijn en voldoen aan de voorgestelde gebruiks voorbeelden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-122">✅ **DO** brainstorm and workshop new API designs to double-check   that they are intuitive and meet proposed use cases.</span></span>

  <span data-ttu-id="3ab78-123">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-123">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-124">Inspecteer de huidige Q- \# code om te zien hoe nieuwe API-ontwerpen de bestaande implementaties kunnen vereenvoudigen en verduidelijken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-124">Inspect current Q\# code to see how new API designs could   simplify and clarify existing implementations.</span></span>
  - <span data-ttu-id="3ab78-125">Bekijk voorgestelde API-ontwerpen met vertegenwoordigers van primaire doel groepen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-125">Review proposed API designs with representatives of primary   audiences.</span></span>

<span data-ttu-id="3ab78-126">**Sleutel principe:** Ontwerp Api's om Lees bare code te ondersteunen en te stimuleren.</span><span class="sxs-lookup"><span data-stu-id="3ab78-126">**Key principle:** Design APIs to support and encourage readable code.</span></span>

- <span data-ttu-id="3ab78-127">✅Zorg **ervoor dat code kan worden gelezen** door domein experts en niet-experts.</span><span class="sxs-lookup"><span data-stu-id="3ab78-127">✅ **DO** ensure that code is readable by domain experts and   non-experts alike.</span></span>
- <span data-ttu-id="3ab78-128">✅**Plaats de** focus op de effecten van elke bewerking en functie binnen het algoritme op hoog niveau, met behulp van documentatie voor meer informatie over de implementatie, indien van toepassing.</span><span class="sxs-lookup"><span data-stu-id="3ab78-128">✅ **DO** place the focus on the effects of each operation and   function within the high-level algorithm, using documentation to   delve into implementation details as appropriate.</span></span>
- <span data-ttu-id="3ab78-129">✅Volg de algemene [Q- \# stijl gids](xref:microsoft.quantum.contributing.style) als **Dit** van toepassing is.</span><span class="sxs-lookup"><span data-stu-id="3ab78-129">✅ **DO** follow the common [Q\# style guide](xref:microsoft.quantum.contributing.style) whenever applicable.</span></span>

<span data-ttu-id="3ab78-130">**Sleutel principe:** Ontwerp Api's stabiel en om voorwaartse compatibiliteit te bieden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-130">**Key principle:** Design APIs to be stable and to provide forward compatibility.</span></span>

- <span data-ttu-id="3ab78-131">✅**DO** Verouderde api's op de juiste wijze af als er wijzigingen zijn vereist.</span><span class="sxs-lookup"><span data-stu-id="3ab78-131">✅ **DO** deprecate old APIs gracefully when breaking changes are   required.</span></span>

- <span data-ttu-id="3ab78-132">✅**Geef bewerkingen** en functies op waarmee de bestaande gebruikers code op de juiste wijze kan worden uitgevoerd tijdens de afschaffing.</span><span class="sxs-lookup"><span data-stu-id="3ab78-132">✅ **DO** provide "shim" operations and functions that allow   existing user code to operate correctly during deprecation.</span></span>

  <span data-ttu-id="3ab78-133">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-133">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-134">Bij het wijzigen van de naam van een bewerking `EstimateExpectation`   `EstimateAverage` die wordt aangeroepen in, wordt een nieuwe bewerking aangeroepen   `EstimateExpectation` die de oorspronkelijke bewerking aanroept met de nieuwe naam, zodat bestaande code correct kan blijven werken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-134">When renaming an operation called `EstimateExpectation` to   `EstimateAverage`, introduce a new operation called   `EstimateExpectation` that calls the original operation at   its new name, so that existing code can continue to work   correctly.</span></span>

- <span data-ttu-id="3ab78-135">✅**Gebruik het** @"microsoft.quantum.core.deprecated" kenmerk om afschaffing van de gebruiker te communiceren.</span><span class="sxs-lookup"><span data-stu-id="3ab78-135">✅ **DO** use the @"microsoft.quantum.core.deprecated" attribute to communicate deprecations to the user.</span></span>

- <span data-ttu-id="3ab78-136">✅ Als u de naam van een bewerking of functie **wijzigt, geeft** u de nieuwe naam op als een teken reeks invoer `@Deprecated` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-136">✅ When renaming an operation or function, **DO** provide the new   name as a string input to `@Deprecated`.</span></span>

- <span data-ttu-id="3ab78-137">⛔️ **geen** bestaande functies of bewerkingen verwijderen zonder een afschaffing van ten minste zes maanden voor Preview-versies of ten minste twee jaar voor ondersteunde releases.</span><span class="sxs-lookup"><span data-stu-id="3ab78-137">⛔️ **DON'T** remove existing functions or operations without a   deprecation period of at least six months for preview releases,   or at least two years for supported releases.</span></span>

## <a name="functions-and-operations"></a><span data-ttu-id="3ab78-138">Functies en bewerkingen</span><span class="sxs-lookup"><span data-stu-id="3ab78-138">Functions and Operations</span></span>

<span data-ttu-id="3ab78-139">**Sleutel principe:** zorg ervoor dat elke functie en bewerking een enkel goed gedefinieerd doel hebben in de API.</span><span class="sxs-lookup"><span data-stu-id="3ab78-139">**Key principle:** ensure that every function and operation has a single well-defined purpose within the API.</span></span>

- <span data-ttu-id="3ab78-140">⛔️ **geen** functies en bewerkingen beschikbaar stellen waarmee meerdere niet-gerelateerde taken worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-140">⛔️ **DON'T** expose functions and operations that perform multiple   unrelated tasks.</span></span>

<span data-ttu-id="3ab78-141">**Sleutel principe:** ontwerp functies en-bewerkingen die zo mogelijk kunnen worden gebruikt en om te anticiperen op toekomstige behoeften.</span><span class="sxs-lookup"><span data-stu-id="3ab78-141">**Key principle:** design functions and operations to be as reusable as possible, and to anticipate future needs.</span></span>

- <span data-ttu-id="3ab78-142">✅Ontwerp functies en-bewerkingen om goed te kunnen samen **werken** met andere functies en bewerkingen, zowel in dezelfde API als in eerdere bestaande bibliotheken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-142">✅ **DO** design functions and operations to compose well with other   functions and operations, both in the same API and in previously   existing libraries.</span></span>

  <span data-ttu-id="3ab78-143">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-143">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-144">Met deze @"microsoft.quantum.canon.delay" bewerking worden minimale veronderstellingen over de invoer gemaakt en kunnen deze worden gebruikt om toepassingen te vertragen van bewerkingen in de Q# standaard bibliotheek of zoals gedefinieerd door gebruikers.</span><span class="sxs-lookup"><span data-stu-id="3ab78-144">The @"microsoft.quantum.canon.delay" operation makes minimal assumptions about its input, and thus can be used to delay applications of either operations across the Q# standard library or as defined by users.</span></span>
    <!-- TODO: define bad example. -->

- <span data-ttu-id="3ab78-145">✅**Zorg** dat er louter deterministische, klassieke logica als functies beschikbaar zijn in plaats van bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-145">✅ **DO** expose purely deterministic classical logic as   as functions rather than operations.</span></span>

  <span data-ttu-id="3ab78-146">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-146">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-147">Een subroutine waarmee de drijvende-komma invoer kan worden gedeterministisch, en moet dus worden blootgesteld aan de gebruiker, `Squared : Double -> Double` in plaats van als een bewerking `Square : Double => Double` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-147">A subroutine which squares its floating-point input can be written deterministically, and so should be exposed to the user as `Squared : Double -> Double` rather than as an operation `Square : Double => Double`.</span></span> <span data-ttu-id="3ab78-148">Op die manier kan de subroutine op meer locaties worden aangeroepen (bijvoorbeeld: binnen andere functies) en kunnen er nuttige optimalisatie gegevens worden verstrekt aan de compiler die van invloed kan zijn op de prestaties en Optima Lise ring.</span><span class="sxs-lookup"><span data-stu-id="3ab78-148">This allows for the subroutine to be called in more places (e.g.: inside of other functions), and provides useful optimization information to the compiler that can affect performance and optimizations.</span></span>
  - <span data-ttu-id="3ab78-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` en `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` verschillen van de garanties die zijn aangebracht met betrekking tot determinism; beide zijn handig in verschillende omstandigheden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-149">`ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` and `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]` differ in the guarantees made with respect to   determinism; both are useful in different circumstances.</span></span>
  - <span data-ttu-id="3ab78-150">API-routines waarmee de toepassing van Quantum bewerkingen wordt getransformeerd, kunnen vaak op een deterministische manier worden uitgevoerd en kunnen daarom beschikbaar worden gemaakt als functies zoals   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-150">API routines that transform the application of quantum   operations can often be carried out in a deterministic     fashion and hence can be made available as functions such as   `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`.</span></span>

- <span data-ttu-id="3ab78-151">✅**Generaliseer** het invoer type zoveel mogelijk voor elke functie en bewerking, met behulp van type parameters als dat nodig is.</span><span class="sxs-lookup"><span data-stu-id="3ab78-151">✅ **DO** generalize the input type as much as reasonable for each   function and operation, using type parameters as needed.</span></span>

  <span data-ttu-id="3ab78-152">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-152">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-153">`ApplyToEach` heeft type `<'T>(('T => Unit), 'T[]) => Unit` in plaats van het specifieke type van de meest voorkomende toepassing, `((Qubit => Unit), Qubit[]) => Unit` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-153">`ApplyToEach` has type `<'T>(('T => Unit), 'T[]) => Unit` rather than the specific type of its most common   application, `((Qubit => Unit), Qubit[]) => Unit`.</span></span>

> [!TIP]
> <span data-ttu-id="3ab78-154">Het is belang rijk om toekomstige behoeften te anticiperen, maar het is ook belang rijk om concrete problemen voor uw gebruikers op te lossen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-154">It is important to anticipate future needs, but it is also important to solve concrete problems for your users.</span></span>
> <span data-ttu-id="3ab78-155">Op basis van dit belang rijk beginsel moet altijd zorgvuldig worden gekeken en gebalanceerd om het ontwikkelen van Api's "alleen in het geval" te voor komen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-155">Acting on this key principle thus always requires careful consideration and balancing to avoid developing APIs "just in case."</span></span>

<span data-ttu-id="3ab78-156">**Sleutel principe:** Kies invoer-en uitvoer typen voor functies en bewerkingen die voorspelbaar zijn en die het doel van een aanroep bare communicatie geven.</span><span class="sxs-lookup"><span data-stu-id="3ab78-156">**Key principle:** choose input and output types for functions and operations that are predictable, and that communicate the purpose of a callable.</span></span>

- <span data-ttu-id="3ab78-157">✅**Gebruik tuple** -typen om invoer en uitvoer logisch te groeperen die alleen aanzienlijk zijn wanneer deze samen worden beschouwd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-157">✅ **DO** use tuple types to logically group inputs and outputs that are only significant when considered together.</span></span> <span data-ttu-id="3ab78-158">U kunt in deze gevallen gebruikmaken van een door de gebruiker gedefinieerd type.</span><span class="sxs-lookup"><span data-stu-id="3ab78-158">Consider using a user-defined type in these cases.</span></span>

  <span data-ttu-id="3ab78-159">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-159">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-160">Een functie voor het uitvoeren van de lokale minima van een andere functie moet mogelijk grenzen van een zoek interval als invoer hebben, zodat dit `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` een juiste hand tekening kan zijn.</span><span class="sxs-lookup"><span data-stu-id="3ab78-160">A function to output the local minima of another function   may need to take bounds of a search interval as input, such   that `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` may be an appropriate signature.</span></span>
  - <span data-ttu-id="3ab78-161">Een bewerking voor het ramen van een afgeleide van een machine learning classificatie met behulp van de para meter Shift-techniek moet mogelijk zowel de verschoven als niet-verwerkte parameter vectoren als invoer hebben.</span><span class="sxs-lookup"><span data-stu-id="3ab78-161">An operation to estimate a derivative of a machine learning classifier using the parameter shift technique may need to take both the shifted and unshifted parameter vectors as inputs.</span></span> <span data-ttu-id="3ab78-162">`(unshifted : Double[], shifted : Double[])`In dit geval kan een invoer vergelijkbaar zijn met die van toepassing.</span><span class="sxs-lookup"><span data-stu-id="3ab78-162">An input similar to `(unshifted : Double[], shifted : Double[])` may be appropriate in this case.</span></span>

- <span data-ttu-id="3ab78-163">✅**Volg items** in de invoer-en uitvoer-Tuples consistent in de verschillende functies en bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-163">✅ **DO** order items in input and output tuples consistently   across different functions and operations.</span></span>

  <span data-ttu-id="3ab78-164">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-164">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-165">Als u twee of functions of bewerkingen overweegt die elk een rotatie hoek hebben en een doel-Qubit als invoer, moet u ervoor zorgen dat ze hetzelfde zijn gerangschikt in elke ingevoerde tuple.</span><span class="sxs-lookup"><span data-stu-id="3ab78-165">If considering two or functions or operations that each take a rotation angle and a target qubit as inputs, ensure that they are ordered the same in each input tuple.</span></span> <span data-ttu-id="3ab78-166">Dat wil zeggen, liever `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` en `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` aan `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` en `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-166">That is, prefer `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)` to `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` and `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="3ab78-167">**Sleutel principe:** ontwerp functies en bewerkingen die goed werken met Q- \# taal functies zoals gedeeltelijke toepassingen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-167">**Key principle:** design functions and operations to work well with Q\# language features such as partial application.</span></span>

- <span data-ttu-id="3ab78-168">✅**Bestel items** in invoer-Tuples, zodat de meest voorkomende invoer het eerst wordt uitgevoerd (dat wil zeggen: zodat gedeeltelijke toepassingen op dezelfde manier reageren op currying).</span><span class="sxs-lookup"><span data-stu-id="3ab78-168">✅ **DO** order items in input tuples such that the most commonly   applied inputs occur first (i.e.: so that partial application   acts similarly to currying).</span></span>

  <span data-ttu-id="3ab78-169">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-169">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-170">Een bewerking `ApplyRotation` waarbij een drijvende-komma nummer en een Qubit worden gebruikt als invoer wordt vaak gedeeltelijk toegepast met de drijvende-komma invoer voor gebruik met bewerkingen waarvoor een invoer van het type wordt verwacht `Qubit => Unit` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-170">An operation `ApplyRotation` that takes a floating-point number and a qubit as inputs may often be partially applied with the floating-point input first for use with operations that expect an input of type `Qubit => Unit`.</span></span> <span data-ttu-id="3ab78-171">Daarom is een hand tekening van `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span><span class="sxs-lookup"><span data-stu-id="3ab78-171">Thus, a signature of `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`</span></span>
      <span data-ttu-id="3ab78-172">werkt het meest consistent met een gedeeltelijke toepassing.</span><span class="sxs-lookup"><span data-stu-id="3ab78-172">would work most consistently with partial application.</span></span>
  - <span data-ttu-id="3ab78-173">Normaal gesp roken houdt dit in dat alle klassieke gegevens worden geplaatst vóór alle qubits in de invoer-Tuples, maar een goede arrest gebruiken en onderzoeken hoe uw API in de praktijk wordt genoemd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-173">Typically, this guidance means placing all classical data   before all qubits in input tuples, but use good judgment and   examine how your API is called in practice.</span></span>

## <a name="user-defined-types"></a><span data-ttu-id="3ab78-174">User-Defined typen</span><span class="sxs-lookup"><span data-stu-id="3ab78-174">User-Defined Types</span></span>

<span data-ttu-id="3ab78-175">**Belangrijkste methode:** gebruik door de gebruiker gedefinieerde typen om api's duidelijker en handiger te maken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-175">**Key principle:** use user-defined types to help make APIs more expressive and convenient to use.</span></span>

- <span data-ttu-id="3ab78-176">✅**Introduceer** nieuwe door de gebruiker gedefinieerde typen om nuttige steno te bieden voor lange en/of gecompliceerde typen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-176">✅ **DO** introduce new user-defined types to provide helpful   shorthand for long and/or complicated types.</span></span>

  <span data-ttu-id="3ab78-177">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-177">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-178">In gevallen waarin een bewerkings type met drie Qubit-matrix invoer meestal als invoer wordt beschouwd of als uitvoer wordt geretourneerd, waardoor een UDT zoals `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span><span class="sxs-lookup"><span data-stu-id="3ab78-178">In cases where an operation type with three qubit array inputs is commonly taken as an input or returned as an output, providing a UDT such as `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`</span></span>
      <span data-ttu-id="3ab78-179">kan u helpen een nuttige steno te bieden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-179">can help provide a useful shorthand.</span></span>

- <span data-ttu-id="3ab78-180">✅**Voer** nieuwe door de gebruiker gedefinieerde typen in om aan te geven dat een bepaald basis type alleen in een zeer bepaalde zin moet worden gebruikt.</span><span class="sxs-lookup"><span data-stu-id="3ab78-180">✅ **DO** introduce new user-defined types to indicate that a given   base type should only be used in a very particular sense.</span></span>

  <span data-ttu-id="3ab78-181">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-181">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-182">Een bewerking die specifiek moet worden geïnterpreteerd als een bewerking die klassieke gegevens in een Quantum REGI ster codeert, kan geschikt zijn voor een label met een door de gebruiker gedefinieerd type `newtype InputEncoder = (Apply : (Qubit[] => Unit))` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-182">An operation that should be interpreted specifically as an   operation that encodes classical data into a quantum   register may be appropriate to label with a user-defined   type `newtype InputEncoder = (Apply : (Qubit[] => Unit))`.</span></span>

- <span data-ttu-id="3ab78-183">✅**Introduceer** nieuwe door de gebruiker gedefinieerde typen met benoemde items die toekomstige uitbreid baarheid mogelijk maken (bijvoorbeeld: een structuur van resultaten die in de toekomst extra benoemde items kan bevatten).</span><span class="sxs-lookup"><span data-stu-id="3ab78-183">✅ **DO** introduce new user-defined types with named items that   allow for future extensibility (e.g.: a results structure that   may contain additional named items in the future).</span></span>

  <span data-ttu-id="3ab78-184">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-184">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-185">Wanneer een bewerking `TrainModel` een groot aantal configuratie opties beschikbaar stelt, worden deze opties weer gegeven als een nieuwe   `TrainingOptions` UDT en   `DefaultTrainingOptions : Unit -> TrainingOptions` kunnen gebruikers met een nieuwe functie specifieke, benoemde items in TrainingOptions UDT-waarden overschrijven, terwijl bibliotheken ontwikkel aars nog steeds nieuwe UDT-items kunnen toevoegen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-185">When an operation `TrainModel` exposes a large number of   configuration options, exposing these options as a new   `TrainingOptions` UDT and providing a new function   `DefaultTrainingOptions : Unit -> TrainingOptions` allows   users to override specific named items in TrainingOptions   UDT values while still allowing library developers to add   new UDT items as appropriate.</span></span>

- <span data-ttu-id="3ab78-186">✅**Declareer** benoemde items voor nieuwe door de gebruiker gedefinieerde typen in de voor keur om te vereisen dat gebruikers de juiste tuple-ontbouwing kennen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-186">✅ **DO** declare named items for new user-defined types in   preference to requiring users to know the correct tuple   deconstruction.</span></span>

  <span data-ttu-id="3ab78-187">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-187">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-188">Als u een complex getal in de polaire ontleding vertegenwoordigt, krijgt   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` u de voor keur   `newtype ComplexPolar = (Double, Double)` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-188">When representing a complex number in its polar   decomposition, prefer   `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` to   `newtype ComplexPolar = (Double, Double)`.</span></span>

<span data-ttu-id="3ab78-189">**Belang rijk:** gebruik door de gebruiker gedefinieerde typen op manieren om de cognitieve belasting te reduceren en niet dat de gebruiker aanvullende concepten en de nomenclatuur hoeft te leren.</span><span class="sxs-lookup"><span data-stu-id="3ab78-189">**Key principle:** use user-defined types in ways reduce  cognitive load and that don't require the user to learn additional concepts and nomenclature.</span></span>

- <span data-ttu-id="3ab78-190">⛔️ **geen** door de gebruiker gedefinieerde typen die de gebruiker nodig heeft om veelvuldig gebruik te maken van de operator voor uitpakken ( `!` ), of waarvoor vaak meerdere niveaus van het uitpakken nodig zijn.</span><span class="sxs-lookup"><span data-stu-id="3ab78-190">⛔️ **DON'T** introduce user-defined types that require the user to make frequent use of the unwrap operator (`!`), or that commonly require multiple levels of unwrapping.</span></span> <span data-ttu-id="3ab78-191">Mogelijke strategieën voor risico beperking zijn:</span><span class="sxs-lookup"><span data-stu-id="3ab78-191">Possible mitigation strategies include:</span></span>

  - <span data-ttu-id="3ab78-192">Wanneer u een door de gebruiker gedefinieerd type zichtbaar maakt met één item, kunt u een naam voor dat item definiëren.</span><span class="sxs-lookup"><span data-stu-id="3ab78-192">When exposing a user-defined type with a single item, consider defining a name for that item.</span></span> <span data-ttu-id="3ab78-193">Overweeg bijvoorbeeld bij voor `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` keur aan `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-193">For instance, consider `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` in preference to `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`.</span></span>

  - <span data-ttu-id="3ab78-194">Zorg ervoor dat andere functies en bewerkingen de ' verpakte ' UDT-instanties rechtstreeks kunnen accepteren.</span><span class="sxs-lookup"><span data-stu-id="3ab78-194">Ensuring that other functions and operations can accept   "wrapped" UDT instances directly.</span></span>

- <span data-ttu-id="3ab78-195">⛔️ **geen** nieuwe door de gebruiker gedefinieerde typen voor het dupliceren van ingebouwde typen, zonder extra betrouwbaarheid te bieden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-195">⛔️ **DON'T** introduce new user-defined types that duplicate   built-in types without providing additional expressiveness.</span></span>

  <span data-ttu-id="3ab78-196">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-196">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-197">Een UDT `newtype QubitRegister = Qubit[]` biedt geen extra duidelijkheid `Qubit[]` en is dus moeilijker te gebruiken zonder te voor deel.</span><span class="sxs-lookup"><span data-stu-id="3ab78-197">A UDT `newtype QubitRegister = Qubit[]` provides no   additional expressiveness over `Qubit[]`, and is thus harder   to use with no discernable benefit.</span></span>
  - <span data-ttu-id="3ab78-198">Een UDT `newtype LittleEndian = Qubit[]` -document geeft aan hoe het onderliggende REGI ster moet worden gebruikt en geïnterpreteerd, en biedt daarom een extra beschrijving van het basis type.</span><span class="sxs-lookup"><span data-stu-id="3ab78-198">A UDT `newtype LittleEndian = Qubit[]` documents how the   underlying register is to be used and interpreted, and thus   provides additional expressiveness over its base type.</span></span>

- <span data-ttu-id="3ab78-199">⛔️ **geen** accessor-functies, tenzij strikt vereist;   in dit geval is het zeer handig om benoemde items te noemen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-199">⛔️ **DON'T** introduce accessor functions unless strictly required;   strongly prefer named items in this case.</span></span>

  <span data-ttu-id="3ab78-200">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-200">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-201">Wanneer u een UDT introduceert `newtype Complex = (Double, Double)` , wijzigt u de definitie voor het   `newtype Complex = (Real : Double, Imag : Double)` introduceren van functies `GetReal : Complex -> Double` en   `GetImag : Complex -> Double` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-201">When introducing a UDT `newtype Complex = (Double, Double)`,   prefer modifying the definition to   `newtype Complex = (Real : Double, Imag : Double)` to introducing   functions `GetReal : Complex -> Double` and   `GetImag : Complex -> Double`.</span></span>

## <a name="namespaces-and-organization"></a><span data-ttu-id="3ab78-202">Naam ruimten en organisatie</span><span class="sxs-lookup"><span data-stu-id="3ab78-202">Namespaces and Organization</span></span>

<span data-ttu-id="3ab78-203">**Sleutel principe:** Kies naam ruimte namen die voorspelbaar zijn en waarmee duidelijk het doel van functies, bewerkingen en door de gebruiker gedefinieerde typen in elke naam ruimte kan worden gecommuniceerd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-203">**Key principle:** choose namespace names that are predictable and that clearly communicate the purpose of functions, operations, and user-defined types in each namespace.</span></span>

- <span data-ttu-id="3ab78-204">✅**Geef** naam ruimten op als `Publisher.Product.DomainArea` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-204">✅ **DO** name namespaces as `Publisher.Product.DomainArea`.</span></span>

  <span data-ttu-id="3ab78-205">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-205">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-206">Functies, bewerkingen en UDTs die door micro soft zijn gepubliceerd als onderdeel van de Quantum simulatie functie van de Quantum Development Kit, worden in de   `Microsoft.Quantum.Simulation` naam ruimte geplaatst.</span><span class="sxs-lookup"><span data-stu-id="3ab78-206">Functions, operations, and UDTs published by Microsoft as a   part of the quantum simulation feature of the Quantum   Development Kit are placed in the   `Microsoft.Quantum.Simulation` namespace.</span></span>
  - <span data-ttu-id="3ab78-207">`Microsoft.Quantum.Math` vertegenwoordigt een naam ruimte die door micro soft is gepubliceerd als onderdeel van de Quantum Development Kit die betrekking heeft op het wiskunde domein gebied.</span><span class="sxs-lookup"><span data-stu-id="3ab78-207">`Microsoft.Quantum.Math` represents a namespace   published by Microsoft as part of the Quantum Development   Kit pertaining to the mathematics domain area.</span></span>

- <span data-ttu-id="3ab78-208">✅**Plaats bewerkingen** , functies en door de gebruiker gedefinieerde typen die worden gebruikt voor specifieke functionaliteit in een naam ruimte die deze functionaliteit beschrijft, zelfs wanneer die functionaliteit wordt gebruikt in verschillende probleem domeinen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-208">✅ **DO** place operations, functions, and user-defined types used   for specific functionality into a namespace that describes that   functionality, even when that functionality is used across   different problem domains.</span></span>

  <span data-ttu-id="3ab78-209">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-209">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-210">Status voorbereiding-Api's die door micro soft zijn gepubliceerd als onderdeel van de Quantum Development Kit, worden opgenomen in   `Microsoft.Quantum.Preparation` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-210">State preparation APIs published by Microsoft as a part of   the Quantum Development Kit would be placed into   `Microsoft.Quantum.Preparation`.</span></span>
  - <span data-ttu-id="3ab78-211">Quantum simulatie Api's die door micro soft zijn gepubliceerd als onderdeel van de Quantum Development Kit, worden opgenomen in   `Microsoft.Quantum.Simulation` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-211">Quantum simulation APIs published by Microsoft as a part of the Quantum   Development Kit would be placed into   `Microsoft.Quantum.Simulation`.</span></span>

- <span data-ttu-id="3ab78-212">✅**Plaatsen bewerkingen** , functies en door de gebruiker gedefinieerde typen die alleen binnen specifieke domeinen worden gebruikt in naam ruimten die het domein van het hulp programma aangeven.</span><span class="sxs-lookup"><span data-stu-id="3ab78-212">✅ **DO** place operations, functions, and user-defined types used only within specific domains into namespaces indicating their domain of utility.</span></span> <span data-ttu-id="3ab78-213">Gebruik, indien nodig, subnaam ruimten om taken binnen elke domein-specifieke naam ruimte aan te duiden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-213">If needed, use subnamespaces to indicate focused tasks within each domain-specific namespace.</span></span>

  <span data-ttu-id="3ab78-214">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-214">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-215">De Quantum machine learning bibliotheek die door micro soft is gepubliceerd, wordt voornamelijk in de @"microsoft.quantum.machinelearning" naam ruimte geplaatst, maar voor beelden van gegevens sets worden door de @"microsoft.quantum.machinelearning.datasets"   naam ruimte verschaft.</span><span class="sxs-lookup"><span data-stu-id="3ab78-215">The quantum machine learning library published by Microsoft is largely   placed into the @"microsoft.quantum.machinelearning" namespace, but example   datasets are provided by the @"microsoft.quantum.machinelearning.datasets"   namespace.</span></span>
  - <span data-ttu-id="3ab78-216">Quantum chemie-Api's die door micro soft zijn gepubliceerd als onderdeel van de Quantum Development Kit, moeten in worden geplaatst `Microsoft.Quantum.Chemistry` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-216">Quantum chemistry APIs published by Microsoft as a part of the Quantum Development Kit should be placed into `Microsoft.Quantum.Chemistry`.</span></span> <span data-ttu-id="3ab78-217">De functionaliteit die specifiek is voor het implementeren van de Wigner-ontleding, kan in worden geplaatst `Microsoft.Quantum.Chemistry.JordanWigner` , zodat de primaire interface voor het domein gebied van de quantum chemie geen betrekking heeft op implementaties.</span><span class="sxs-lookup"><span data-stu-id="3ab78-217">Functionality specific to implementing the Jordan--Wigner decomposition may be placed in `Microsoft.Quantum.Chemistry.JordanWigner`, so that the primary interface for the quantum chemistry domain area is not concerned with implementations.</span></span>

<span data-ttu-id="3ab78-218">**Sleutel principe:** Gebruik naam ruimten en toegangs parameters samen om het API-Opper vlak dat wordt blootgesteld aan gebruikers te gebruiken en om interne gegevens te verbergen met betrekking tot de implementatie en het testen van uw Api's.</span><span class="sxs-lookup"><span data-stu-id="3ab78-218">**Key principle:** Use namespaces and access modifiers together to be intentional about the API surface exposed to users, and to hide internal details related to implementation and testing of your APIs.</span></span>

- <span data-ttu-id="3ab78-219">✅ Indien redelijk moeten alle functies en bewerkingen **worden uitgevoerd die** nodig zijn om een API te implementeren in dezelfde naam ruimte als de API die wordt geïmplementeerd, maar gemarkeerd met de sleutel woorden ' privé ' of ' intern ' om aan te geven dat ze geen deel uitmaken van het open bare API-Opper vlak voor een tape wisselaar.</span><span class="sxs-lookup"><span data-stu-id="3ab78-219">✅ Whenever reasonable, **DO** place all functions and operations needed to implement an API into the same namespace as the API being implemented, but marked with the "private" or "internal" keywords to indicate that they are not part of the public API surface for a library.</span></span> <span data-ttu-id="3ab78-220">Gebruik een naam die begint met een onderstrepings teken ( `_` ) om persoonlijke en interne bewerkingen en functies van open bare callables visueel te onderscheiden.</span><span class="sxs-lookup"><span data-stu-id="3ab78-220">Use a name beginning with an underscore (`_`) to visually distinguish private and internal operations and functions from public callables.</span></span>

  <span data-ttu-id="3ab78-221">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-221">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-222">De naam van de bewerking `_Features` geeft een functie aan die privé is voor een bepaalde naam ruimte en assembly, en moet vergezeld gaan van het `internal` sleutel woord.</span><span class="sxs-lookup"><span data-stu-id="3ab78-222">The operation name `_Features` indicates a function that is   private to a given namespace and assembly, and should be   accompanied by either the `internal` keyword.</span></span>

- <span data-ttu-id="3ab78-223">✅ In het zeldzame geval dat een uitgebreide set persoonlijke functies of bewerkingen nodig zijn om de API voor een bepaalde naam ruimte te implementeren, **moet u** deze in een nieuwe naam ruimte plaatsen die overeenkomt met de naam ruimte die wordt geïmplementeerd en eindigt op `.Private` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-223">✅ In the rare case that an extensive set of private functions or operations are needed to implement the API for a given namespace, **DO** place them in a new namespace matching the namespace being implemented and ending in `.Private`.</span></span>

- <span data-ttu-id="3ab78-224">✅**Plaats alle** eenheids tests in naam ruimten die overeenkomen met de naam ruimte onder testen en eindigend op `.Tests` .</span><span class="sxs-lookup"><span data-stu-id="3ab78-224">✅ **DO** place all unit tests into namespaces matching the     namespace under test and ending in `.Tests`.</span></span>

## <a name="naming-conventions-and-vocabulary"></a><span data-ttu-id="3ab78-225">Naam conventies en woordenlijst</span><span class="sxs-lookup"><span data-stu-id="3ab78-225">Naming Conventions and Vocabulary</span></span>

<span data-ttu-id="3ab78-226">**Sleutel principe:** Kies namen en terminologie die duidelijk, toegankelijk en leesbaar zijn in een verscheidenheid aan doel groepen, met inbegrip van beide quantums en experts.</span><span class="sxs-lookup"><span data-stu-id="3ab78-226">**Key principle:** Choose names and terminology that are clear, accessible, and readable across a diverse range of audiences, including both quantum novices and experts.</span></span>

- <span data-ttu-id="3ab78-227">⛔️ **geen** discriminerende of uitgesloten id-namen en terminologie in API-documentatie opmerkingen gebruiken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-227">⛔️ **DON'T** use discriminatory or exclusionary identifier names,   nor terminology in API documentation comments.</span></span>

- <span data-ttu-id="3ab78-228">✅**Gebruik API** -documentatie opmerkingen om relevante context, voor beelden en verwijzingen te bieden, met name voor meer moeilijke concepten.</span><span class="sxs-lookup"><span data-stu-id="3ab78-228">✅ **DO** use API documentation comments to provide relevant   context, examples, and references, especially for more difficult   concepts.</span></span>

- <span data-ttu-id="3ab78-229">⛔️ **geen** id-namen gebruiken die onnodig esoterische zijn, of waarvoor belang rijke Quantum algoritmen kennis hebben om te lezen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-229">⛔️ **DON'T** use identifier names that are unnecessarily esoteric,   or that require significant quantum algorithms knowledge to   read.</span></span>

  <span data-ttu-id="3ab78-230">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-230">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-231">Kies voor keur voor ' amplitude versterking ' naar ' Grover iteratie '.</span><span class="sxs-lookup"><span data-stu-id="3ab78-231">Prefer "amplitude amplification iteration" to "Grover   iteration."</span></span>

- <span data-ttu-id="3ab78-232">✅**Kies bewerkingen** en functie namen waarmee duidelijk het beoogde effect van een aanroepbaar en niet de implementatie wordt gecommuniceerd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-232">✅ **DO** choose operations and function names that clearly communicate the intended effect of a callable, and not its implementation.</span></span> <span data-ttu-id="3ab78-233">Houd er rekening mee dat de implementatie kan en moet worden beschreven in [API-documentatie opmerkingen](xref:microsoft.quantum.guide.filestructure#documentation-comments).</span><span class="sxs-lookup"><span data-stu-id="3ab78-233">Note that the implementation can and should be documented in [API documentation comments](xref:microsoft.quantum.guide.filestructure#documentation-comments).</span></span>

  <span data-ttu-id="3ab78-234">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-234">*Examples:*</span></span>
  - <span data-ttu-id="3ab78-235">De voor keur ' schatting overlappen ' op ' Hadamard test ', aangezien de laatste wordt gecommuniceerd hoe de voormalige wordt geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-235">Prefer "estimate overlap" to "Hadamard test," as the latter   communicates how the former is implemented.</span></span>

- <span data-ttu-id="3ab78-236">✅**Gebruik woorden** op een consistente manier in alle Q- \# api's:</span><span class="sxs-lookup"><span data-stu-id="3ab78-236">✅ **DO** use words in a consistent fashion across all Q\# APIs:</span></span>

  - <span data-ttu-id="3ab78-237">**Termen**</span><span class="sxs-lookup"><span data-stu-id="3ab78-237">**Verbs:**</span></span>

    - <span data-ttu-id="3ab78-238">**Assert** : Controleer of een veronderstelling over de status van een doel computer en de qubits-bewaringen mogelijk is door gebruik te maken van niet-fysieke resources.</span><span class="sxs-lookup"><span data-stu-id="3ab78-238">**Assert** : Check that an assumption about the state of a target machine and its qubits holds, possibly by using unphysical resources.</span></span> <span data-ttu-id="3ab78-239">Bewerkingen die gebruikmaken van deze term moeten altijd veilig kunnen worden verwijderd zonder dat dit van invloed is op de functionaliteit van bibliotheken en uitvoer bare Program ma's.</span><span class="sxs-lookup"><span data-stu-id="3ab78-239">Operations using this verb should always be safely removable without affecting the functionality of libraries and executable programs.</span></span> <span data-ttu-id="3ab78-240">In tegens telling tot feiten kunnen verklaringen in het algemeen afhankelijk zijn van externe status, zoals de status van een Qubit-REGI ster, de uitvoerings omgeving of dergelijke.</span><span class="sxs-lookup"><span data-stu-id="3ab78-240">Note that unlike facts, assertions may, in general, depend on external state, such as the state of a qubit register, the run environment or so forth.</span></span> <span data-ttu-id="3ab78-241">Als afhankelijkheid van de externe status is een soort neven effect, moeten beweringen worden weer gegeven als bewerkingen in plaats van functions.</span><span class="sxs-lookup"><span data-stu-id="3ab78-241">As dependency on external state is a kind of side effect, assertions must be exposed as operations rather than functions.</span></span>

    - <span data-ttu-id="3ab78-242">**Schatting** : als u een of meer mogelijk herhaalde metingen gebruikt, moet u een klassiek aantal van meet resultaten schatten.</span><span class="sxs-lookup"><span data-stu-id="3ab78-242">**Estimate** : Using one or more possibly repeated   measurements, estimate a classical quantity from   measurement results.</span></span>

      <span data-ttu-id="3ab78-243">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-243">*Examples:*</span></span>
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - <span data-ttu-id="3ab78-244">**Voorbereiden** : een Quantum bewerking of volg orde van bewerkingen Toep assen op een of meer qubits, aangenomen dat deze wordt gestart met een bepaalde begin status (doorgaans $ \ket{00\cdots 0} $), waardoor de status van die qubits naar een gewenste eind status kan worden gegroeid.</span><span class="sxs-lookup"><span data-stu-id="3ab78-244">**Prepare** : Apply a quantum operation or sequence of operations to one or more qubits assumed to start in a particular initial state (typically $\ket{00\cdots 0}$), causing the state of those qubits to evolve to a desired end state.</span></span> <span data-ttu-id="3ab78-245">Over het algemeen **kan** het optreden op andere statussen dan de opgegeven start status leiden tot een niet-gedefinieerde unitary-trans formatie, maar **moet** nog steeds zorgen dat een bewerking en de adjoint ' annuleren ' worden bewaard en er geen op worden toegepast.</span><span class="sxs-lookup"><span data-stu-id="3ab78-245">In general, acting on states other than the given starting state **MAY** result in an undefined unitary transformation, but **SHOULD** still preserve that an operation and its adjoint "cancel out" and apply a no-op.</span></span>

      <span data-ttu-id="3ab78-246">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-246">*Examples:*</span></span>
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - <span data-ttu-id="3ab78-247">**Meting** : een Quantum bewerking of een reeks bewerkingen Toep assen op een of meer qubits. er wordt een back-up van klassieke gegevens weer gegeven.</span><span class="sxs-lookup"><span data-stu-id="3ab78-247">**Measure** : Apply a quantum operation or sequence of   operations to one or more qubits, reading classical data   back out.</span></span>

      <span data-ttu-id="3ab78-248">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-248">*Examples:*</span></span>
      - @"Microsoft.Quantum.Intrinsic.Measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - <span data-ttu-id="3ab78-249">**Toep assen** : een Quantum bewerking of reeks bewerkingen Toep assen op een of meer qubits, waardoor de status van die qubits op een samenhangende manier kan worden gewijzigd.</span><span class="sxs-lookup"><span data-stu-id="3ab78-249">**Apply** : Apply a quantum operation or sequence of operations to one or more qubits, causing the state of those qubits to change in a coherent fashion.</span></span> <span data-ttu-id="3ab78-250">Dit woord is de meest algemene term in Q \# -nomenclatuur en **mag niet worden** gebruikt wanneer een meer specifieke term direct relevant is.</span><span class="sxs-lookup"><span data-stu-id="3ab78-250">This verb is the most general verb in Q\# nomenclature, and **SHOULD NOT BE** used when a more specific verb is more directly relevant.</span></span>

  - <span data-ttu-id="3ab78-251">**Zelfstandige naam woorden** :</span><span class="sxs-lookup"><span data-stu-id="3ab78-251">**Nouns** :</span></span>

    - <span data-ttu-id="3ab78-252">**Fact** : een Booleaanse voor waarde die alleen afhankelijk is van de invoer en niet van de status van een doel computer, de omgeving of de status van de qubits van de machine.</span><span class="sxs-lookup"><span data-stu-id="3ab78-252">**Fact** : A Boolean condition which depends only on its inputs and not on the state of a target machine, its environment, or the state of the machine's qubits.</span></span> <span data-ttu-id="3ab78-253">In tegens telling tot een bevestiging is een feit alleen gevoelig voor de *waarden* die aan dat feit worden gegeven.</span><span class="sxs-lookup"><span data-stu-id="3ab78-253">By contrast with an assertion, a fact is only sensitive to the *values* provided to that fact.</span></span> <span data-ttu-id="3ab78-254">Bijvoorbeeld:</span><span class="sxs-lookup"><span data-stu-id="3ab78-254">For example:</span></span>

      <span data-ttu-id="3ab78-255">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-255">*Examples:*</span></span>
      - <span data-ttu-id="3ab78-256">@"microsoft.quantum.diagnostics.equalityfacti": vertegenwoordigt een gelijkheids feit over twee integer-invoer; de gehele getallen die als invoer worden opgegeven, zijn gelijk aan elkaar of ze zijn niet onafhankelijk van een andere programma status.</span><span class="sxs-lookup"><span data-stu-id="3ab78-256">@"microsoft.quantum.diagnostics.equalityfacti": represents an equality fact about two integer inputs; either the integers provided as input are equal to each other, or they are not, independent of any other program state.</span></span>

    - <span data-ttu-id="3ab78-257">**Opties:** Een UDT met meerdere benoemde items die als optionele argumenten kunnen fungeren voor een functie of bewerking.</span><span class="sxs-lookup"><span data-stu-id="3ab78-257">**Options:** A UDT containing several named items that can act as "optional arguments" to a function or operation.</span></span> <span data-ttu-id="3ab78-258">Bijvoorbeeld:</span><span class="sxs-lookup"><span data-stu-id="3ab78-258">For example:</span></span>

      <span data-ttu-id="3ab78-259">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-259">*Examples:*</span></span>
      - <span data-ttu-id="3ab78-260">De @"microsoft.quantum.machinelearning.trainingoptions" UDT bevat benoemde items voor Learning rate, minibatch-grootte en andere Configureer bare para meters voor ml-training.</span><span class="sxs-lookup"><span data-stu-id="3ab78-260">The @"microsoft.quantum.machinelearning.trainingoptions" UDT includes named items for learning rate, minibatch size, and other configurable parameters for ML training.</span></span>

  - <span data-ttu-id="3ab78-261">**Bijvoegingen** :</span><span class="sxs-lookup"><span data-stu-id="3ab78-261">**Adjectives** :</span></span>

    - <span data-ttu-id="3ab78-262">⛔️ **Nieuw** : deze bijvoeger **mag niet** worden gebruikt, om Verwar ring met het gebruik als een werk woord te voor komen in veel programmeer talen (bijvoorbeeld: C++, C#, Java, type script, Power shell).</span><span class="sxs-lookup"><span data-stu-id="3ab78-262">⛔️ **New** : This adjective **SHOULD NOT** be used, as to avoid confusion   with its usage as a verb in many   programming languages (e.g.: C++, C#, Java, TypeScript, PowerShell).</span></span>

  - <span data-ttu-id="3ab78-263">Voor **zetsels:** In sommige gevallen kunnen preposities worden gebruikt om de rollen van zelfstandige naam woorden en termen in functie-en bewerkings namen verder te dubbel zinnigheid of te verduidelijken.</span><span class="sxs-lookup"><span data-stu-id="3ab78-263">**Prepositions:** In some cases, prepositions can be used to further disambiguate or clarify the roles of nouns and verbs in function and operation names.</span></span> <span data-ttu-id="3ab78-264">Zorg ervoor dat dit echter spaarzaam en consistent is.</span><span class="sxs-lookup"><span data-stu-id="3ab78-264">Care should be taken to do so sparingly and consistently, however.</span></span>

    - <span data-ttu-id="3ab78-265">**Als:** Hiermee wordt aangegeven dat de invoer en uitvoer van een functie dezelfde informatie vertegenwoordigen, maar dat de uitvoer de gegevens vertegenwoordigt **als** een *X* in plaats van de oorspronkelijke weer gave.</span><span class="sxs-lookup"><span data-stu-id="3ab78-265">**As:** Represents that a function's input and output represent the same information, but that the output represents that information **as** an *X* instead of its original representation.</span></span> <span data-ttu-id="3ab78-266">Dit is met name gebruikelijk voor functies van type conversie.</span><span class="sxs-lookup"><span data-stu-id="3ab78-266">This is especially common for type conversion functions.</span></span>

      <span data-ttu-id="3ab78-267">*Voorbeelden:*</span><span class="sxs-lookup"><span data-stu-id="3ab78-267">*Examples:*</span></span>
      - <span data-ttu-id="3ab78-268">`IntAsDouble(2)` Hiermee wordt aangegeven dat zowel de invoer ( `2` ) als de uitvoer ( `2.0` ) op kwalitatieve manier dezelfde informatie vertegenwoordigen, maar met verschillende \# gegevens typen van Q.</span><span class="sxs-lookup"><span data-stu-id="3ab78-268">`IntAsDouble(2)` indicates that both the input (`2`) and the output (`2.0`)   represent qualitatively the same information, but using   different Q\# data types to do so.</span></span>

    - <span data-ttu-id="3ab78-269">**Van:** Om consistentie te garanderen, mag deze voor positie   **niet** worden gebruikt om type conversie functies of een ander geval waar **dat** van toepassing is, aan te geven.</span><span class="sxs-lookup"><span data-stu-id="3ab78-269">**From:** To ensure consistency, this preposition   **SHOULD NOT** be used to indicate type conversion   functions or any other case where **As** is appropriate.</span></span>

    - <span data-ttu-id="3ab78-270">⛔️ **:** deze voor positie **mag niet** worden gebruikt, zodat Verwar ring met het gebruik als een werk woord in veel programmeer talen wordt voor komen.</span><span class="sxs-lookup"><span data-stu-id="3ab78-270">⛔️ **To:** This preposition **SHOULD NOT** be used, as to   avoid confusion with its usage as a verb in many   programming languages.</span></span>
