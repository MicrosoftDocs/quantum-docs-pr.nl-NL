---
title: Wat zijn Q# en de QDK?
description: Lees hier meer over Q#, een programmeertaal van Microsoft voor het ontwikkelen van toepassingen voor kwantumcomputers en een cruciaal onderdeel van de Quantum Development Kit van Microsoft
author: natke
ms.author: nakersha
ms.date: 10/22/2019
ms.topic: article
uid: microsoft.quantum.overview.qsharp
ms.openlocfilehash: a4bf21887e34ac85f75e5e0b9a033138464fd09d
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: HT
ms.contentlocale: nl-NL
ms.lasthandoff: 02/28/2020
ms.locfileid: "77906998"
---
# <a name="what-are-q-and-the-qdk"></a><span data-ttu-id="e1df3-103">Wat zijn Q# en de QDK?</span><span class="sxs-lookup"><span data-stu-id="e1df3-103">What are Q# and the QDK?</span></span>

<span data-ttu-id="e1df3-104">Q# is een programmeertaal met functies die speciaal zijn ontworpen voor gebruik in kwantumcomputing.</span><span class="sxs-lookup"><span data-stu-id="e1df3-104">Q# is a programming language with features specifically designed for use with quantum computing.</span></span>
<span data-ttu-id="e1df3-105">Als belangrijk onderdeel van de Quantum Development Kit van Microsoft biedt Q# kwantumprogrammeurs een framework waarmee ze zich kunnen concentreren op de algoritmen zonder dat ze zich zorgen hoeven te maken over technische details zoals het optimaliseren van de gate-sequence of de fysieke implementatie van een kwantumcomputer.</span><span class="sxs-lookup"><span data-stu-id="e1df3-105">As a key component of Microsoft's Quantum Development Kit (QDK), it provides quantum programmers a framework that allows you to focus on the algorithms without having to worry about technical details like gate sequence optimization or the physical implementation of a quantum computer.</span></span>

<span data-ttu-id="e1df3-106">De QDK omvat een verscheidenheid aan hulpprogramma's, waarmee ontwikkelaars alles hebben dat nodig is om kwantumprogramma's te schrijven.</span><span class="sxs-lookup"><span data-stu-id="e1df3-106">The QDK comprises a wide range of tools which give developers everything they need to start writing quantum programs.</span></span>
<span data-ttu-id="e1df3-107">Naast de Q#-taal omvat de QDK:</span><span class="sxs-lookup"><span data-stu-id="e1df3-107">Alongside the Q# language, the QDK includes:</span></span>
* <span data-ttu-id="e1df3-108">de *Q#-bibliotheken*, waarmee ontwikkelaars gelijk aan de slag kunnen om echte kwantumtoepassingen te maken</span><span class="sxs-lookup"><span data-stu-id="e1df3-108">the *Q# libraries*, which allow developers to hit the ground running and create real-world quantum applications today</span></span>
* <span data-ttu-id="e1df3-109">verschillende *doelmachines* waarop Q#-programma's kunnen worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="e1df3-109">various *target machines* on which Q# programs can be run.</span></span> <span data-ttu-id="e1df3-110">Dit zijn onder andere tools voor resource-inschatting en simulatoren voor grotere kwantumprogramma's, evenals een volledige kwantumsimulator, die zich als een ruisvrije kwantumcomputer gedraagt.</span><span class="sxs-lookup"><span data-stu-id="e1df3-110">These include resource estimators and simulators for larger quantum programs, as well as a full-state quantum simulator, which behaves as a noise-free quantum computer.</span></span> <span data-ttu-id="e1df3-111">Deze laatste is zeer nuttig bij het experimenteren met ideeën, foutopsporing van programma's en leren over kwantumfysica, maar alleen efficiënt voor programma's met relatief weinig qubits.</span><span class="sxs-lookup"><span data-stu-id="e1df3-111">The latter is very useful for tinkering with ideas, debugging programs, and learning about quantum physics, but only efficient for programs with relatively few qubits.</span></span> <span data-ttu-id="e1df3-112">We kijken ernaar uit dat we in de toekomst hardware voor kwantumcomputing als doelmachines beschikbaar kunnen maken.</span><span class="sxs-lookup"><span data-stu-id="e1df3-112">We're very much looking forward to making quantum computing hardware available as target machines in the future.</span></span>
* <span data-ttu-id="e1df3-113">*hulpprogramma's* om het gebruik van Q# zo naadloos mogelijk te maken, zoals uitbreidingen voor Visual Studio en VS Code en pakketten voor gebruik met Python en Jupyter Notebook.</span><span class="sxs-lookup"><span data-stu-id="e1df3-113">*tools* for making work with Q# as seamless as possible, such as extensions for Visual Studio and VS Code, and packages for use with Python and Jupyter Notebooks.</span></span>
* <span data-ttu-id="e1df3-114">*API-documentatie* om Q# te combineren met klassieke host-talen zoals Python en C#</span><span class="sxs-lookup"><span data-stu-id="e1df3-114">*API documentation* for pairing Q# with classical host languages such as Python and C#</span></span>

<span data-ttu-id="e1df3-115">Toepassingen die zijn ontwikkeld met de Quantum Development Kit van Microsoft bestaan doorgaans uit twee delen:</span><span class="sxs-lookup"><span data-stu-id="e1df3-115">Applications developed with Microsoft's Quantum Development Kit typically consist of two parts:</span></span>
1. <span data-ttu-id="e1df3-116">Een of meer kwantumalgoritmen, geïmplementeerd met behulp van de kwantumprogrammeertaal Q# en aangeroepen door het klassieke host-programma.</span><span class="sxs-lookup"><span data-stu-id="e1df3-116">One or more quantum algorithms, implemented using the Q# quantum programming language, and invoked by the classical host program.</span></span> <span data-ttu-id="e1df3-117">Deze bestaan uit:</span><span class="sxs-lookup"><span data-stu-id="e1df3-117">These consist of</span></span> 
    - <span data-ttu-id="e1df3-118">Q#-bewerkingen: subroutines met kwantumbewerkingen, en</span><span class="sxs-lookup"><span data-stu-id="e1df3-118">Q# operations: subroutines containing quantum operations, and</span></span> 
    - <span data-ttu-id="e1df3-119">Q#-functies: klassieke subroutines die worden gebruikt binnen het kwantumalgoritme.</span><span class="sxs-lookup"><span data-stu-id="e1df3-119">Q# functions: classical subroutines used within the quantum algorithm.</span></span>
2. <span data-ttu-id="e1df3-120">Een klassiek programma, geïmplementeerd in een klassieke programmeertaal als Python of C#, dat als het belangrijkste toegangspunt fungeert en Q#-bewerkingen aanroept om een kwantumalgoritme uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="e1df3-120">A classical program, implemented in a classical programming language like Python or C#, that serves as the main entry point and will invoke Q# operations when it wants to execute a quantum algorithm.</span></span>

## <a name="write-quantum-programs-not-quantum-circuits"></a><span data-ttu-id="e1df3-121">Kwantumprogramma's schrijven, geen kwantumcircuits</span><span class="sxs-lookup"><span data-stu-id="e1df3-121">Write quantum programs, not quantum circuits</span></span>

<span data-ttu-id="e1df3-122">In het begintijdperk van de kwantumcomputing werden algoritmen gevisualiseerd als schema's, vergelijkbaar met circuitschema's in klassieke computing.</span><span class="sxs-lookup"><span data-stu-id="e1df3-122">In the early days of quantum computing algorithms were visualized as diagrams similarly to circuit diagrams in classical computing.</span></span>
<span data-ttu-id="e1df3-123">Hoewel het circuitmodel jarenlang nuttig is geweest in het onderzoek naar kwantumcomputing, zijn we bij Microsoft van mening dat kwantumcircuits nog maar het begin zijn voor ontwikkelaars en dat ze kwantumalgoritmen en -toepassingen kunnen ontwikkelen met Q#.</span><span class="sxs-lookup"><span data-stu-id="e1df3-123">While the circuit model has been useful for many years in quantum computing research, here at Microsoft, we believe that developers can go beyond quantum circuits and develop quantum algorithms and applications using Q#.</span></span>
<span data-ttu-id="e1df3-124">Bij het ontwikkelen van de Q#-taal hebben we rekening gehouden met wat we hebben geleerd in tientallen jaren ontwikkeling van klassieke software om kwantumontwikkelaars te voorzien van een high-level taal die specifiek is gericht op kwantumcomputing.</span><span class="sxs-lookup"><span data-stu-id="e1df3-124">The Q# language was built to take advantage of what we’ve learned through decades of classical software development, and empower quantum developers with high-level language functionality targeted for quantum computing.</span></span>

## <a name="how-does-q-work"></a><span data-ttu-id="e1df3-125">Hoe werkt Q#?</span><span class="sxs-lookup"><span data-stu-id="e1df3-125">How does Q# work?</span></span>

<span data-ttu-id="e1df3-126">De programmeertaal Q# biedt een intuïtieve set met typen, bewerkingen en logische expressies voor het ontwikkelen van algoritmen zonder dat u rekening hoeft te houden met de interne logica van de kwantumcomputer.</span><span class="sxs-lookup"><span data-stu-id="e1df3-126">The Q# programming language provides you with an intuitive set of types, operations, and logic expressions to develop algorithms without having to worry about the internal logic of the quantum computer.</span></span>

<span data-ttu-id="e1df3-127">Een van de fundamentele bouwstenen van Q# is het `Qubit`-type, dat niet kan worden gekopieerd en ook niet rechtstreeks toegankelijk is, net als een echte qubit.</span><span class="sxs-lookup"><span data-stu-id="e1df3-127">One of the fundamental building blocks of Q# is the `Qubit` type, which cannot be copied or directly accessed, just like a real qubit.</span></span>
<span data-ttu-id="e1df3-128">In plaats daarvan kunnen we deze meten en het resultaat van de meting opslaan in een `Result`-variabele; een Q#-type dat twee mogelijke waarden kan aannemen: `Zero` en `One`.</span><span class="sxs-lookup"><span data-stu-id="e1df3-128">Instead, we can measure it and store the outcome of the measurement in a `Result` variable, a Q# type that can take two possible values: `Zero` and `One`.</span></span>
<span data-ttu-id="e1df3-129">Constructies zoals deze garanderen dat algoritmen altijd de wetten van de kwantumfysica respecteren en correct kunnen worden uitgevoerd op kwantumcomputers of simulators.</span><span class="sxs-lookup"><span data-stu-id="e1df3-129">Constructs like this one guarantee that algorithms always respect the laws of quantum physics and can run correctly on quantum computers or simulators.</span></span>

<span data-ttu-id="e1df3-130">Q# bevat ook functies van klassieke logica zoals voorwaarden en lussen, met een aantal nuanceringen om ervoor te zorgen dat alle kwantumregels worden nageleefd.</span><span class="sxs-lookup"><span data-stu-id="e1df3-130">Q# also includes classical logic features like conditionals and loops with some subtleties to make sure that all the quantum rules are being respected.</span></span>
<span data-ttu-id="e1df3-131">U kunt bijvoorbeeld de manier beperken waarop lussen worden uitgevoerd om ervoor te zorgen dat quantumbewerkingen niet worden aangeroepen binnen functies die alleen deterministische klassieke subroutines kunnen bevatten.</span><span class="sxs-lookup"><span data-stu-id="e1df3-131">For example, constraining the way loops are executed to ensure that quantum operations are not called within functions which may only contain deterministic classical subroutines.</span></span>

<span data-ttu-id="e1df3-132">Programma's geschreven in Q# zijn vaak gekoppeld aan een hostprogramma dat is geschreven in C# of Python, waarmee klassieke code en kwantumcode op een handige manier kunnen worden geordend.</span><span class="sxs-lookup"><span data-stu-id="e1df3-132">Q# programs are often paired with a host program written in C# or Python, which can provide convenient organization of classical and quantum code.</span></span>
<span data-ttu-id="e1df3-133">Naast de ondersteuning van talen zoals C# en Python biedt de QDK ondersteuning voor Jupyter-notebooks met de Jupyter-kernel IQ#.</span><span class="sxs-lookup"><span data-stu-id="e1df3-133">In addition to supporting languages such as C# and Python, the QDK provides Jupyter Notebook support with the IQ# Jupyter kernel.</span></span>

## <a name="what-can-i-use-q-for"></a><span data-ttu-id="e1df3-134">Waar kan ik Q# voor gebruiken?</span><span class="sxs-lookup"><span data-stu-id="e1df3-134">What can I use Q# for?</span></span>

### <a name="use-q-to-learn-quantum-computing"></a><span data-ttu-id="e1df3-135">Kwantumcomputing leren met Q#</span><span class="sxs-lookup"><span data-stu-id="e1df3-135">Use Q# to learn quantum computing</span></span>

<span data-ttu-id="e1df3-136">Tot nu toe was kennis van het circuitmodel nodig om te leren werken met kwantumcomputing, teneinde de algoritmen te begrijpen in de vorm van geordende reeksen kwantum-gates en metingen.</span><span class="sxs-lookup"><span data-stu-id="e1df3-136">Until now, to learn quantum computing you needed to learn the circuit model to understand the algorithms in the form of ordered sequences of quantum gates and measurements.</span></span> <span data-ttu-id="e1df3-137">Met Q# kunt u een ander traject volgen: kwantumcomputing leren door kwantumprogramma's te schrijven.</span><span class="sxs-lookup"><span data-stu-id="e1df3-137">With Q# you can take another path: learn quantum computing by writing quantum programs.</span></span>

### <a name="use-q-to-design-quantum-algorithms"></a><span data-ttu-id="e1df3-138">Q# gebruiken om kwantumalgoritmen te ontwerpen</span><span class="sxs-lookup"><span data-stu-id="e1df3-138">Use Q# to design quantum algorithms</span></span>

<span data-ttu-id="e1df3-139">Er zijn steeds meer bibliotheken en door de gebruiker gedefinieerde typen beschikbaar voor Q# waarmee u hulpprogramma's en functies kunt implementeren om zo geavanceerde kwantumalgoritmen te maken.</span><span class="sxs-lookup"><span data-stu-id="e1df3-139">Q# provides you with an increasing number of libraries and user-defined types that will help you to implement tools and build advanced quantum algorithms.</span></span> <span data-ttu-id="e1df3-140">Stel dat u de twee qubits q1 en q2 moet verstrengelen.</span><span class="sxs-lookup"><span data-stu-id="e1df3-140">For example, you need to entangle two-qubits q1 and q2?</span></span> <span data-ttu-id="e1df3-141">In plaats van afzonderlijk de benodigde gates toe te passen om dit te realiseren, kunt u de al ingebouwde bewerking `PrepareEntangledState([q1], [q2])` gebruiken.</span><span class="sxs-lookup"><span data-stu-id="e1df3-141">Instead of applying individually the necessary gates to get the qubits entangled you can use the already built-in operation `PrepareEntangledState([q1], [q2])`.</span></span>

### <a name="use-q-to-estimate-quantum-resources"></a><span data-ttu-id="e1df3-142">Q# gebruiken om een schatting te maken van kwantumbronnen</span><span class="sxs-lookup"><span data-stu-id="e1df3-142">Use Q# to estimate quantum resources</span></span>

<span data-ttu-id="e1df3-143">U kunt de uitvoering van uw Q#-programma simuleren met behulp van de full-state kwantumsimulator die wordt geleverd bij de Quantum Development Kit (QDK).</span><span class="sxs-lookup"><span data-stu-id="e1df3-143">You can simulate the execution of your Q# program using the full state quantum simulator that is provided with the Quantum Development Kit (QDK).</span></span>  <span data-ttu-id="e1df3-144">De QDK biedt ook bronschattingen die u inzicht geven in de prestaties van Q#-programma's die te groot zijn om te worden uitgevoerd op een simulator.</span><span class="sxs-lookup"><span data-stu-id="e1df3-144">The QDK also provides resource estimators that give you insights on the performance of Q# programs that are too large to be run on a simulator.</span></span>  <span data-ttu-id="e1df3-145">Dit is zeer nuttig voor ontwerpers van algoritmen omdat ze hun programma's kunnen afstemmen op het gebruik van minder bronnen (bijvoorbeeld minder qubits waarop minder bewerkingen worden uitgevoerd), om te worden uitgevoerd op oudere kwantumhardware op kleinere schaal.</span><span class="sxs-lookup"><span data-stu-id="e1df3-145">This is highly valuable for algorithm designers, because they can tune their programs to use fewer resources (e.g. fewer number of qubits running for fewer numbers of operations), to run on earlier smaller scale quantum hardware.</span></span>

### <a name="use-q-to-validate-hardware-performance"></a><span data-ttu-id="e1df3-146">Q# gebruiken om de prestaties van hardware te valideren</span><span class="sxs-lookup"><span data-stu-id="e1df3-146">Use Q# to validate hardware performance</span></span>

<span data-ttu-id="e1df3-147">Het mooie van Q# is dat een programma maar eenmaal hoeft te worden geschreven en vervolgens zowel kan worden uitgevoerd op kwantumsimulators voor foutopsporing, als op verschillende hardware voor kwantumcomputers.</span><span class="sxs-lookup"><span data-stu-id="e1df3-147">The beauty of Q# is that a program can be written once and run on quantum simulators for debugging, and run on different quantum computer hardware.</span></span>  <span data-ttu-id="e1df3-148">Benchmarkprogramma's die zijn geschreven in Q# kunnen worden uitgevoerd voor het valideren van de prestaties van hardware en het vergelijken van resultaten wanneer kwantumcomputers zich ontwikkelen en er nieuwe kwantumcomputers beschikbaar komen.</span><span class="sxs-lookup"><span data-stu-id="e1df3-148">Benchmark programs written in Q# can be run to validate hardware performance and compare results as quantum computers evolve and new quantum computers become available.</span></span>  

## <a name="next-steps"></a><span data-ttu-id="e1df3-149">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="e1df3-149">Next steps</span></span>

* [<span data-ttu-id="e1df3-150">Waar leer ik meer over kwantumcomputing?</span><span class="sxs-lookup"><span data-stu-id="e1df3-150">How do I learn about quantum computing?</span></span>](xref:microsoft.quantum.overview.learn)
* [<span data-ttu-id="e1df3-151">Aan de slag met de Microsoft Quantum Development Kit</span><span class="sxs-lookup"><span data-stu-id="e1df3-151">Get started with the Microsoft Quantum Development Kit</span></span>](xref:microsoft.quantum.welcome)
