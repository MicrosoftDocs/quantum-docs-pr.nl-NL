---
title: Intrinsieke bewerkingen en functies in de QDK
description: Meer informatie over de intrinsieke bewerkingen en functies in de QDK, waaronder klassieke functies en unitary, rotatie-en meet bewerkingen.
author: QuantumWriter
uid: microsoft.quantum.libraries.standard.prelude
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 283504a5f5635a4996c804e514a6f52eb4966d22
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868437"
---
# <a name="the-prelude"></a><span data-ttu-id="b30cf-103">De prelude</span><span class="sxs-lookup"><span data-stu-id="b30cf-103">The Prelude</span></span> #

<span data-ttu-id="b30cf-104">De Q# compiler en de doel computers die deel uitmaken van de Quantum Development Kit bieden een reeks ingebouwde functies en bewerkingen die kunnen worden gebruikt bij het schrijven van Quantum Program ma's in Q# .</span><span class="sxs-lookup"><span data-stu-id="b30cf-104">The Q# compiler and the target machines included with the Quantum Development Kit provide a set of intrinsic functions and operations that can be used when writing quantum programs in Q#.</span></span>

## <a name="intrinsic-operations-and-functions"></a><span data-ttu-id="b30cf-105">Intrinsieke bewerkingen en functies</span><span class="sxs-lookup"><span data-stu-id="b30cf-105">Intrinsic Operations and Functions</span></span> ##

<span data-ttu-id="b30cf-106">De intrinsieke bewerkingen die in de standaard bibliotheek zijn gedefinieerd, vallen ongeveer in een van de volgende categorieën:</span><span class="sxs-lookup"><span data-stu-id="b30cf-106">The intrinsic operations defined in the standard library roughly fall into one of several categories:</span></span>

- <span data-ttu-id="b30cf-107">Essentiële klassieke functies die zijn verzameld in de <xref:microsoft.quantum.core> naam ruimte.</span><span class="sxs-lookup"><span data-stu-id="b30cf-107">Essential classical functions, collected in the <xref:microsoft.quantum.core> namespace.</span></span>
- <span data-ttu-id="b30cf-108">Bewerkingen voor unitaries die bestaan uit [Clifford en $T $ Gates](xref:microsoft.quantum.concepts.qubit).</span><span class="sxs-lookup"><span data-stu-id="b30cf-108">Operations representing unitaries composed of [Clifford and $T$ gates](xref:microsoft.quantum.concepts.qubit).</span></span>
- <span data-ttu-id="b30cf-109">Bewerkingen die betrekking hebben op rotaties over verschillende Opera tors.</span><span class="sxs-lookup"><span data-stu-id="b30cf-109">Operations representing rotations about various operators.</span></span>
- <span data-ttu-id="b30cf-110">Bewerkingen geïmplementeerd metingen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-110">Operations implementing measurements.</span></span>

<span data-ttu-id="b30cf-111">Omdat de Clifford + $T $ Gate-set is ingesteld op [Universal](xref:microsoft.quantum.concepts.multiple-qubits) voor Quantum Computing, zijn deze bewerkingen voldoende om een Quantum algoritme te implementeren in negligibly kleine fout.</span><span class="sxs-lookup"><span data-stu-id="b30cf-111">Since the Clifford + $T$ gate set is [universal](xref:microsoft.quantum.concepts.multiple-qubits) for quantum computing, these operations suffice to approximately implement any quantum algorithm within negligibly small error.</span></span>
<span data-ttu-id="b30cf-112">Door draaiing te bieden, Q# kan de programmeur binnen de single Qubit unitary-en CNOT-poort bibliotheek werken.</span><span class="sxs-lookup"><span data-stu-id="b30cf-112">By providing rotations as well, Q# allows the programmer to work within the single qubit unitary and CNOT gate library.</span></span> <span data-ttu-id="b30cf-113">Deze bibliotheek is veel gemakkelijker te zien, omdat het niet vereist is dat de programmeur rechtstreeks de Clifford + $T $ decompileren en omdat er zeer efficiënte methoden bestaan voor het samen stellen van één Qubit unitaries in Clifford en $T $ Gates (Zie [hier](xref:microsoft.quantum.more-information) voor meer informatie).</span><span class="sxs-lookup"><span data-stu-id="b30cf-113">This library is much easier to think about because it does not  require the programmer to directly express the Clifford + $T$ decomposition and because highly efficient methods exist for compiling single qubit unitaries into Clifford and $T$ gates (see [here](xref:microsoft.quantum.more-information) for more information).</span></span>

<span data-ttu-id="b30cf-114">Waar mogelijk, de bewerkingen die zijn gedefinieerd in de prelude die op qubits zijn toegestaan voor het Toep assen van de `Controlled` Variant, zodat de doel computer de juiste ontleding uitvoert.</span><span class="sxs-lookup"><span data-stu-id="b30cf-114">Where possible, the operations defined in the prelude which act on qubits allow for applying the `Controlled` variant, such that the target machine will perform the appropriate decomposition.</span></span>

<span data-ttu-id="b30cf-115">Veel van de functies en bewerkingen die in dit gedeelte van de prelude zijn gedefinieerd, bevinden zich in de @"microsoft.quantum.intrinsic" naam ruimte, zodat Q# de meeste bron bestanden een instructie hebben die `open Microsoft.Quantum.Intrinsic;` direct volgt op de oorspronkelijke naam ruimte declaratie.</span><span class="sxs-lookup"><span data-stu-id="b30cf-115">Many of the functions and operations defined in this portion of the prelude are in the @"microsoft.quantum.intrinsic" namespace, such that most Q# source files will have an `open Microsoft.Quantum.Intrinsic;` directive immediately following the initial namespace declaration.</span></span>
<span data-ttu-id="b30cf-116">De <xref:microsoft.quantum.core> naam ruimte wordt automatisch geopend, zodat functies zoals <xref:microsoft.quantum.core.length> kan worden gebruikt zonder een `open` instructie.</span><span class="sxs-lookup"><span data-stu-id="b30cf-116">The <xref:microsoft.quantum.core> namespace is automatically opened, so that functions such as <xref:microsoft.quantum.core.length> can be used without an `open` statement at all.</span></span>

### <a name="common-single-qubit-unitary-operations"></a><span data-ttu-id="b30cf-117">Algemene single-Qubit unitary-bewerkingen</span><span class="sxs-lookup"><span data-stu-id="b30cf-117">Common Single-Qubit Unitary Operations</span></span> ###

<span data-ttu-id="b30cf-118">De prelude definieert ook veel veelvoorkomende [bewerkingen met één Qubit](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span><span class="sxs-lookup"><span data-stu-id="b30cf-118">The prelude also defines many common [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span></span>
<span data-ttu-id="b30cf-119">Voor al deze bewerkingen zijn zowel de `Controlled` als- `Adjoint` functors toegestaan.</span><span class="sxs-lookup"><span data-stu-id="b30cf-119">All of these operations allow both the `Controlled` and `Adjoint` functors.</span></span>

#### <a name="pauli-operators"></a><span data-ttu-id="b30cf-120">Pauli-Opera tors</span><span class="sxs-lookup"><span data-stu-id="b30cf-120">Pauli Operators</span></span> ####

<span data-ttu-id="b30cf-121">Met de <xref:microsoft.quantum.intrinsic.x> bewerking wordt de Pauli $X $-operator geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-121">The <xref:microsoft.quantum.intrinsic.x> operation implements the Pauli $X$ operator.</span></span>
<span data-ttu-id="b30cf-122">Dit wordt soms ook wel de `NOT` poort genoemd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-122">This is sometimes also known as the `NOT` gate.</span></span>
<span data-ttu-id="b30cf-123">Deze heeft hand tekening `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-123">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-124">Dit komt overeen met de unitary met één Qubit:</span><span class="sxs-lookup"><span data-stu-id="b30cf-124">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="b30cf-125">\begin{Equation} \begin{bmatrix} 0 & 1 \\ \\ % controle: dit maakt momenteel gebruik van de quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-125">\begin{equation} \begin{bmatrix} 0 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="b30cf-126">1 & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="b30cf-126">1 & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="b30cf-127">Met de <xref:microsoft.quantum.intrinsic.y> bewerking wordt de Pauli $Y $-operator geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-127">The <xref:microsoft.quantum.intrinsic.y> operation implements the Pauli $Y$ operator.</span></span>
<span data-ttu-id="b30cf-128">Deze heeft hand tekening `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-128">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-129">Dit komt overeen met de unitary met één Qubit:</span><span class="sxs-lookup"><span data-stu-id="b30cf-129">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="b30cf-130">\begin{Equation} \begin{bmatrix} 0 &-i \\ \\ % controle: dit maakt momenteel gebruik van de quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-130">\begin{equation} \begin{bmatrix} 0 & -i \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="b30cf-131">Ik & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="b30cf-131">i & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="b30cf-132">Met de <xref:microsoft.quantum.intrinsic.z> bewerking wordt de Pauli $Z $-operator geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-132">The <xref:microsoft.quantum.intrinsic.z> operation implements the Pauli $Z$ operator.</span></span>
<span data-ttu-id="b30cf-133">Deze heeft hand tekening `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-133">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-134">Dit komt overeen met de unitary met één Qubit:</span><span class="sxs-lookup"><span data-stu-id="b30cf-134">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="b30cf-135">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % controle: dit maakt momenteel gebruik van de quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-135">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="b30cf-136">0 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="b30cf-136">0 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="b30cf-137">Hieronder ziet u de trans formaties die zijn toegewezen aan de [Bloch-bol](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (de rotatieas in elke case is rood gemarkeerd):</span><span class="sxs-lookup"><span data-stu-id="b30cf-137">Below we see these transformations mapped to the [Bloch sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (the rotation axis in each case is highlighted red):</span></span>

![Pauli-bewerkingen die zijn toegewezen aan de Bloch-bol](~/media/prelude_pauliBloch.png)

<span data-ttu-id="b30cf-139">Het is belang rijk te weten dat het Toep assen van dezelfde Pauli-Gate twee maal op dezelfde Qubit de bewerking annuleert (omdat u nu een volledige draaiing van 2π (360 °) over het Opper vlak naar de Bloch-bol hebt uitgevoerd, waardoor er op het begin punt weer een bericht binnenkomt.</span><span class="sxs-lookup"><span data-stu-id="b30cf-139">It is important to note that applying the same Pauli gate twice to the same qubit cancels out the operation (because you have now performed a full rotation of 2π (360°) over the surface to the Bloch Sphere, thus arriving back at the starting point).</span></span> <span data-ttu-id="b30cf-140">Dit brengt ons de volgende identiteit:</span><span class="sxs-lookup"><span data-stu-id="b30cf-140">This brings us to the following identity:</span></span>

<span data-ttu-id="b30cf-141">$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \boldone $ $</span><span class="sxs-lookup"><span data-stu-id="b30cf-141">$$ X^2=Y^2=Z^2=\boldone $$</span></span>

<span data-ttu-id="b30cf-142">Dit kan worden visualised op de Bloch-bol:</span><span class="sxs-lookup"><span data-stu-id="b30cf-142">This can be visualised on the Bloch sphere:</span></span>

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a><span data-ttu-id="b30cf-144">Andere single-Qubit Cliffords</span><span class="sxs-lookup"><span data-stu-id="b30cf-144">Other Single-Qubit Cliffords</span></span> ####

<span data-ttu-id="b30cf-145">Met de <xref:microsoft.quantum.intrinsic.h> bewerking wordt de Hadamard-Gate geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-145">The <xref:microsoft.quantum.intrinsic.h> operation implements the Hadamard gate.</span></span>
<span data-ttu-id="b30cf-146">Hiermee worden de Pauli $X $ en $Z $ assen van de doel-Qubit verwisseld, zodat $H \ket {0} = \ket{+} \mathrel{: =} (\ket {0} + \ket {1} )/\sqrt {2} $ en $H \ket{+} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-146">This interchanges the Pauli $X$ and $Z$ axes of the target qubit, such that $H\ket{0} = \ket{+} \mathrel{:=} (\ket{0} + \ket{1}) / \sqrt{2}$ and $H\ket{+} = \ket{0}$.</span></span>
<span data-ttu-id="b30cf-147">Het heeft hand tekening `(Qubit => Unit is Adj + Ctl)` en komt overeen met de single-Qubit unitary:</span><span class="sxs-lookup"><span data-stu-id="b30cf-147">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="b30cf-148">\begin{Equation} \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ % controle: dit maakt momenteel gebruik van de quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-148">\begin{equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="b30cf-149">1 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="b30cf-149">1 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="b30cf-150">De Hadamard-poort is met name belang rijk, omdat deze kan worden gebruikt voor het maken van een super positie van $ \ket {0} $ en $ \ket {1} $ States.</span><span class="sxs-lookup"><span data-stu-id="b30cf-150">The Hadamard gate is particularly important as it can be used to create a superposition of the $\ket{0}$ and $\ket{1}$ states.</span></span> <span data-ttu-id="b30cf-151">In de weer gave van de Bloch-bol is het het gemakkelijkst om dit te zien als een rotatie van $ \ket{\psi} $ rond de x-as met $ \pi $ radialen ($ 180 ^ \circ $), gevolgd door een (rechtsom) draaiing rond de y-as met $ \ pi/2 $ radialen ($ 90 ^ \circ $):</span><span class="sxs-lookup"><span data-stu-id="b30cf-151">In the Bloch sphere representation, it is easiest to think of this as a rotation of $\ket{\psi}$ around the x-axis by $\pi$ radians ($180^\circ$) followed by a (clockwise) rotation around the y-axis by $\pi/2$ radians ($90^\circ$):</span></span>

![Bewerking Hadamard is toegewezen aan de Bloch-bol](~/media/prelude_hadamardBloch.png)

<span data-ttu-id="b30cf-153">Met deze <xref:microsoft.quantum.intrinsic.s> bewerking wordt de Phase-gate $S $ geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-153">The <xref:microsoft.quantum.intrinsic.s> operation implements the phase gate $S$.</span></span>
<span data-ttu-id="b30cf-154">Dit is de matrix wortel van de Pauli $Z $-bewerking.</span><span class="sxs-lookup"><span data-stu-id="b30cf-154">This is the matrix square root of the Pauli $Z$ operation.</span></span>
<span data-ttu-id="b30cf-155">Dat wil zeggen $S ^ 2 = Z $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-155">That is, $S^2 = Z$.</span></span>
<span data-ttu-id="b30cf-156">Het heeft hand tekening `(Qubit => Unit is Adj + Ctl)` en komt overeen met de single-Qubit unitary:</span><span class="sxs-lookup"><span data-stu-id="b30cf-156">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="b30cf-157">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % controle: dit maakt momenteel gebruik van de quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-157">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="b30cf-158">0 & \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="b30cf-158">0 & i \end{bmatrix} \end{equation}</span></span>

#### <a name="rotations"></a><span data-ttu-id="b30cf-159">Rouleringen</span><span class="sxs-lookup"><span data-stu-id="b30cf-159">Rotations</span></span> ####

<span data-ttu-id="b30cf-160">Naast de bovenstaande Pauli-en Clifford-bewerkingen biedt de Q# prelude diverse manieren om draaiingen uit te drukken.</span><span class="sxs-lookup"><span data-stu-id="b30cf-160">In addition to the Pauli and Clifford operations above, the Q# prelude provides a variety of ways of expressing rotations.</span></span>
<span data-ttu-id="b30cf-161">Zoals beschreven in [Single-Qubit bewerkingen](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), is de mogelijkheid om te draaien essentieel voor Quantum algoritmen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-161">As described in [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), the ability to rotate is critical to quantum algorithms.</span></span>

<span data-ttu-id="b30cf-162">We beginnen met het opnieuw aanroepen van een bewerking met één Qubit met de $H $ en $T $ Gates, waarbij $H $ de Hadamard-bewerking is, en waarbij \begin{Equation} T \mathrel{: =} \begin{bmatrix} 1 & 0 \\ \\ % controle: dit maakt momenteel gebruik van de Quad back Swagger hack.</span><span class="sxs-lookup"><span data-stu-id="b30cf-162">We start by recalling that we can express any single-qubit operation using the $H$ and $T$ gates, where $H$ is the Hadamard operation, and where \begin{equation} T \mathrel{:=} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quad back whack hack.</span></span>
<span data-ttu-id="b30cf-163">0 & e ^ {i \pi/4} \end{bmatrix} \end{Equation} dit is de vierkantswortel van de <xref:microsoft.quantum.intrinsic.s> bewerking, bijvoorbeeld $T ^ 2 = S $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-163">0 & e^{i \pi / 4} \end{bmatrix} \end{equation} This is the square root of the <xref:microsoft.quantum.intrinsic.s> operation, such that $T^2 = S$.</span></span>
<span data-ttu-id="b30cf-164">De $T $ Gate wordt geïmplementeerd door de <xref:microsoft.quantum.intrinsic.t> bewerking en heeft hand tekening `(Qubit => Unit is Adj + Ctl)` , wat aangeeft dat het een unitary-bewerking is op een enkele Qubit.</span><span class="sxs-lookup"><span data-stu-id="b30cf-164">The $T$ gate is in turn implemented by the <xref:microsoft.quantum.intrinsic.t> operation, and has signature `(Qubit => Unit is Adj + Ctl)`, indicating that it is a unitary operation on a single-qubit.</span></span>

<span data-ttu-id="b30cf-165">Hoewel dit in principe voldoende is om een wille keurige bewerking met één Qubit te beschrijven, hebben verschillende doel machines mogelijk een efficiëntere weer gave voor rotaties over Pauli-Opera Tors, zodat de prelude een aantal manieren bevat om dergelijke draaiingen te convienentlyen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-165">Even though this is in principle sufficient to describe any arbitrary single-qubit operation, different target machines may have more efficient representations for rotations about Pauli operators, such that the prelude includes a variety of ways to convienently express such rotations.</span></span>
<span data-ttu-id="b30cf-166">De meest algemene van deze is de <xref:microsoft.quantum.intrinsic.r> bewerking, die een rotatie rond een opgegeven Pauli-as implementeert, \Begin{Equation} R (\sigma, \phi) \mathrel{: =} \exp (-i \phi \sigma/2), \end{Equation} waarbij $ \sigma $ een Pauli-operator is, $ \phi $ is een hoek en waarbij $ \exp $ de matrix exponentiële aangeeft.</span><span class="sxs-lookup"><span data-stu-id="b30cf-166">The most basic of these is the <xref:microsoft.quantum.intrinsic.r> operation, which implements a rotation around a specified Pauli axis, \begin{equation} R(\sigma, \phi) \mathrel{:=} \exp(-i \phi \sigma / 2), \end{equation} where $\sigma$ is a Pauli operator, $\phi$ is an angle, and where $\exp$ represents the matrix exponential.</span></span>
<span data-ttu-id="b30cf-167">Het heeft hand tekening `((Pauli, Double, Qubit) => Unit is Adj + Ctl)` , waarbij de eerste twee delen van de invoer de klassieke argumenten $ \sigma $ en $ \phi $ bevatten die nodig zijn om de unitary-operator op te geven $R (\sigma, \phi) $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-167">It has signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, where the first two parts of the input represent the classical arguments $\sigma$ and $\phi$ needed to specify the unitary operator $R(\sigma, \phi)$.</span></span>
<span data-ttu-id="b30cf-168">We kunnen $ \sigma $ en $ \phi $ deels Toep assen om een bewerking te verkrijgen waarvan het type van een single-Qubit unitary is.</span><span class="sxs-lookup"><span data-stu-id="b30cf-168">We can partially apply $\sigma$ and $\phi$ to obtain an operation whose type is that of a single-qubit unitary.</span></span>
<span data-ttu-id="b30cf-169">Bijvoorbeeld, is van het `R(PauliZ, PI() / 4, _)` type `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-169">For example, `R(PauliZ, PI() / 4, _)` has type `(Qubit => Unit is Adj + Ctl)`.</span></span>

> [!NOTE]
> <span data-ttu-id="b30cf-170">De <xref:microsoft.quantum.intrinsic.r> bewerking deelt de invoer hoek met 2 en vermenigvuldigt deze met-1.</span><span class="sxs-lookup"><span data-stu-id="b30cf-170">The <xref:microsoft.quantum.intrinsic.r> operation divides the input angle by 2 and multiplies it by -1.</span></span>
> <span data-ttu-id="b30cf-171">Voor $Z $ rotations betekent dit dat $ \ket {0} $ eigenstate wordt geroteerd door $-\phi/$2 en dat $ \ket {1} $ eigenstate wordt geroteerd door $ \phi/$2, zodat $ \ket {1} $ eigenstate wordt geroteerd door $ \phi $ ten opzichte van $ \ket {0} $ eigenstate.</span><span class="sxs-lookup"><span data-stu-id="b30cf-171">For $Z$ rotations, this means that the $\ket{0}$ eigenstate is rotated by $-\phi / 2$ and the $\ket{1}$ eigenstate is rotated by $\phi / 2$, so that the $\ket{1}$ eigenstate is rotated by $\phi$ relative to the $\ket{0}$ eigenstate.</span></span>
>
> <span data-ttu-id="b30cf-172">Dit betekent met name dat `T` en `R(PauliZ, PI() / 8, _)` anders alleen door een irrelevante [globale fase](xref:microsoft.quantum.glossary#global-phase).</span><span class="sxs-lookup"><span data-stu-id="b30cf-172">In particular, this means that `T` and `R(PauliZ, PI() / 8, _)` differ only by an irrelevant [global phase](xref:microsoft.quantum.glossary#global-phase).</span></span>
> <span data-ttu-id="b30cf-173">Daarom wordt $T $ ook wel de $ \frac{\pi} {8} $-Gate genoemd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-173">For this reason, $T$ is sometimes known as the $\frac{\pi}{8}$-gate.</span></span>
>
> <span data-ttu-id="b30cf-174">Houd er ook rekening mee dat draait om `PauliI` simpelweg een globale fase van $ \phi/$2 toe te staan.</span><span class="sxs-lookup"><span data-stu-id="b30cf-174">Note also that rotating around `PauliI` simply applies a global phase of $\phi / 2$.</span></span> <span data-ttu-id="b30cf-175">Hoewel deze fasen niet van belang zijn, zoals in [de conceptuele documenten](xref:microsoft.quantum.concepts.qubit)is gevoerd, zijn ze relevant voor beheerde `PauliI` draaiingen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-175">While such phases are irrelevant, as argued in [the conceptual documents](xref:microsoft.quantum.concepts.qubit), they are relevant for controlled `PauliI` rotations.</span></span>

<span data-ttu-id="b30cf-176">Binnen Quantum-algoritmen is het vaak handig om rotaties als dyadic fracties te expresseren, zodat $ \phi = \pi k/2 ^ n $ voor sommige $k \in \mathbb{Z} $ en $n \in \mathbb{N} $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-176">Within quantum algorithms, it is often useful to express rotations as dyadic fractions, such that $\phi = \pi k / 2^n$ for some $k \in \mathbb{Z}$ and $n \in \mathbb{N}$.</span></span>
<span data-ttu-id="b30cf-177"><xref:microsoft.quantum.intrinsic.rfrac>Met deze bewerking wordt een rotatie rond een opgegeven Pauli-as met deze Conventie geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-177">The <xref:microsoft.quantum.intrinsic.rfrac> operation implements a rotation around a specified Pauli axis using this convention.</span></span>
<span data-ttu-id="b30cf-178">Het verschil <xref:microsoft.quantum.intrinsic.r> is dat de draai hoek wordt opgegeven als twee invoer typen `Int` , geïnterpreteerd als een dyadic Fractie.</span><span class="sxs-lookup"><span data-stu-id="b30cf-178">It differs from <xref:microsoft.quantum.intrinsic.r> in that the rotation angle is specified as two inputs of type `Int`, interpreted as a dyadic fraction.</span></span>
<span data-ttu-id="b30cf-179">Daarom `RFrac` heeft hand tekening `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-179">Thus, `RFrac` has signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-180">Het implementeert de single-Qubit unitary $ \exp (i \pi k \sigma/2 ^ n) $, waarbij $ \sigma $ de Pauli matrix is die overeenkomt met het eerste argument, $k $ het tweede argument is en $n $ het derde argument is.</span><span class="sxs-lookup"><span data-stu-id="b30cf-180">It implements the single-qubit unitary $\exp(i \pi k \sigma / 2^n)$, where $\sigma$ is the Pauli matrix corresponding to the first argument, $k$ is the second argument, and $n$ is the third argument.</span></span>
<span data-ttu-id="b30cf-181">`RFrac(_,k,n,_)`is hetzelfde als `R(_,-πk/2^n,_)` . Houd er rekening mee dat de hoek de *negatieve* waarde van de Fractie.</span><span class="sxs-lookup"><span data-stu-id="b30cf-181">`RFrac(_,k,n,_)` is the same as `R(_,-πk/2^n,_)`; note that the angle is the *negative* of the fraction.</span></span>

<span data-ttu-id="b30cf-182">Met de <xref:microsoft.quantum.intrinsic.rx> bewerking wordt een draaiing rond de Pauli $X $ as geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-182">The <xref:microsoft.quantum.intrinsic.rx> operation implements a rotation around the Pauli $X$ axis.</span></span>
<span data-ttu-id="b30cf-183">Deze heeft hand tekening `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-183">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-184">`Rx(_, _)`is hetzelfde als `R(PauliX, _, _)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-184">`Rx(_, _)` is the same as `R(PauliX, _, _)`.</span></span>

<span data-ttu-id="b30cf-185">Met de <xref:microsoft.quantum.intrinsic.ry> bewerking wordt een draaiing rond de Pauli $Y $ as geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-185">The <xref:microsoft.quantum.intrinsic.ry> operation implements a rotation around the Pauli $Y$ axis.</span></span>
<span data-ttu-id="b30cf-186">Deze heeft hand tekening `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-186">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-187">`Ry(_, _)`is hetzelfde als `R(PauliY,_ , _)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-187">`Ry(_, _)` is the same as `R(PauliY,_ , _)`.</span></span>

<span data-ttu-id="b30cf-188">Met de <xref:microsoft.quantum.intrinsic.rz> bewerking wordt een draaiing rond de Pauli $Z $ as geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-188">The <xref:microsoft.quantum.intrinsic.rz> operation implements a rotation around the Pauli $Z$ axis.</span></span>
<span data-ttu-id="b30cf-189">Deze heeft hand tekening `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-189">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-190">`Rz(_, _)`is hetzelfde als `R(PauliZ, _, _)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-190">`Rz(_, _)` is the same as `R(PauliZ, _, _)`.</span></span>

<span data-ttu-id="b30cf-191"><xref:microsoft.quantum.intrinsic.r1>Met de bewerking wordt een rotatie geïmplementeerd met de opgegeven hoeveelheid rond $ \ket {1} $, de $-$1 eigenstate van $Z $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-191">The <xref:microsoft.quantum.intrinsic.r1> operation implements a rotation by the given amount around $\ket{1}$, the $-1$ eigenstate of $Z$.</span></span>
<span data-ttu-id="b30cf-192">Deze heeft hand tekening `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-192">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-193">`R1(phi,_)`is hetzelfde als `R(PauliZ,phi,_)` gevolgd door `R(PauliI,-phi,_)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-193">`R1(phi,_)` is the same as `R(PauliZ,phi,_)` followed by `R(PauliI,-phi,_)`.</span></span>

<span data-ttu-id="b30cf-194"><xref:microsoft.quantum.intrinsic.r1frac>Met de bewerking wordt een gedeeltelijke draaiing geïmplementeerd met de opgegeven hoeveelheid rond de Z = 1 eigenstate.</span><span class="sxs-lookup"><span data-stu-id="b30cf-194">The <xref:microsoft.quantum.intrinsic.r1frac> operation implements a fractional rotation by the given amount around the Z=1 eigenstate.</span></span>
<span data-ttu-id="b30cf-195">Deze heeft hand tekening `((Int,Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-195">It has signature `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-196">`R1Frac(k,n,_)`is hetzelfde als `RFrac(PauliZ,-k.n+1,_)` gevolgd door `RFrac(PauliI,k,n+1,_)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-196">`R1Frac(k,n,_)` is the same as `RFrac(PauliZ,-k.n+1,_)` followed by `RFrac(PauliI,k,n+1,_)`.</span></span>

<span data-ttu-id="b30cf-197">Hieronder ziet u een voor beeld van een rotatie bewerking (rond de Pauli $Z $ as, in dit geval) die is toegewezen aan de Bloch-bol:</span><span class="sxs-lookup"><span data-stu-id="b30cf-197">An example of a rotation operation (around the Pauli $Z$ axis, in this instance) mapped onto the Bloch sphere is shown below:</span></span>

![Rotatie bewerking die is toegewezen aan de Bloch-bol](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a><span data-ttu-id="b30cf-199">Multi-Qubit bewerkingen</span><span class="sxs-lookup"><span data-stu-id="b30cf-199">Multi-Qubit Operations</span></span> ####

<span data-ttu-id="b30cf-200">Naast de bovenstaande bewerkingen met één Qubit definieert de prelude ook enkele multi-Qubit bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-200">In addition to the single-qubit operations above, the prelude also defines several multi-qubit operations.</span></span>

<span data-ttu-id="b30cf-201">Ten eerste <xref:microsoft.quantum.intrinsic.cnot> voert de bewerking een standaard Controlled- `NOT` Gate, \begin{Equation} \operatorname{CNOT} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \\ \\ 0 & 0 & 1 & 0 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="b30cf-201">First, the <xref:microsoft.quantum.intrinsic.cnot> operation performs a standard controlled-`NOT` gate, \begin{equation} \operatorname{CNOT} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span></span>
<span data-ttu-id="b30cf-202">\end{Equation} heeft een hand tekening, waarmee wordt aangegeven `((Qubit, Qubit) => Unit is Adj + Ctl)` dat $ \operatorname{CNOT} $ unitarily op twee afzonderlijke qubits.</span><span class="sxs-lookup"><span data-stu-id="b30cf-202">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`, representing that $\operatorname{CNOT}$ acts unitarily on two individual qubits.</span></span>
<span data-ttu-id="b30cf-203">`CNOT(q1, q2)`is hetzelfde als `(Controlled X)([q1], q2)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-203">`CNOT(q1, q2)` is the same as `(Controlled X)([q1], q2)`.</span></span>
<span data-ttu-id="b30cf-204">Omdat de `Controlled` functor voor het beheren van een REGI ster toestaat, gebruiken we de matrix letterlijke waarde `[q1]` om aan te geven dat we alleen het ene besturings element willen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-204">Since the `Controlled` functor allows for controlling on a register, we use the array literal `[q1]` to indicate that we want only the one control.</span></span>

<span data-ttu-id="b30cf-205">Met de <xref:microsoft.quantum.intrinsic.ccnot> bewerking wordt een niet-Gate met dubbele controle uitgevoerd, ook wel bekend als de Toffoli-poort.</span><span class="sxs-lookup"><span data-stu-id="b30cf-205">The <xref:microsoft.quantum.intrinsic.ccnot> operation performs doubly-controlled NOT gate, sometimes also known as the Toffoli gate.</span></span>
<span data-ttu-id="b30cf-206">Deze heeft hand tekening `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-206">It has signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-207">`CCNOT(q1, q2, q3)`is hetzelfde als `(Controlled X)([q1, q2], q3)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-207">`CCNOT(q1, q2, q3)` is the same as `(Controlled X)([q1, q2], q3)`.</span></span>

<span data-ttu-id="b30cf-208"><xref:microsoft.quantum.intrinsic.swap>Met deze bewerking worden de Quantum statussen van twee qubits gewisseld.</span><span class="sxs-lookup"><span data-stu-id="b30cf-208">The <xref:microsoft.quantum.intrinsic.swap> operation swaps the quantum states of two qubits.</span></span>
<span data-ttu-id="b30cf-209">Dat wil zeggen, implementeert de unitary-matrix \begin{Equation} \operatorname{SWAP} \mathrel{: =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="b30cf-209">That is, it implements the unitary matrix \begin{equation} \operatorname{SWAP} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span></span>
<span data-ttu-id="b30cf-210">\end{Equation} heeft een hand tekening `((Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-210">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="b30cf-211">`SWAP(q1,q2)`is gelijk aan `CNOT(q1, q2)` gevolgd door `CNOT(q2, q1)` en vervolgens `CNOT(q1, q2)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-211">`SWAP(q1,q2)` is equivalent to `CNOT(q1, q2)` followed by `CNOT(q2, q1)` and then `CNOT(q1, q2)`.</span></span>

> [!NOTE]
> <span data-ttu-id="b30cf-212">De SWAP-Gate is *niet* hetzelfde als de elementen van een variabele met type `Qubit[]` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-212">The SWAP gate is *not* the same as rearranging the elements of a variable with type `Qubit[]`.</span></span>
> <span data-ttu-id="b30cf-213">Met Toep assen `SWAP(q1, q2)` wordt een wijziging in de status van de qubits waarnaar `q1` wordt verwezen door en `q2` , en `let swappedRegister = [q2, q1];` is alleen van invloed op de manier waarop we verwijzen naar die qubits.</span><span class="sxs-lookup"><span data-stu-id="b30cf-213">Applying `SWAP(q1, q2)` causes a change to the state of the qubits referred to by `q1` and `q2`, while `let swappedRegister = [q2, q1];` only affects how we refer to those qubits.</span></span>
> <span data-ttu-id="b30cf-214">Daarnaast kan `(Controlled SWAP)([q0], (q1, q2))` `SWAP` de status van een derde Qubit worden opgegeven, wat niet kan worden aangegeven door elementen opnieuw te rangschikken.</span><span class="sxs-lookup"><span data-stu-id="b30cf-214">Moreover, `(Controlled SWAP)([q0], (q1, q2))` allows for `SWAP` to be conditioned on the state of a third qubit, which we cannot represent by rearranging elements.</span></span>
> <span data-ttu-id="b30cf-215">De Controlled-SWAP-Gate, ook wel bekend als de Fredkin-poort, is krachtig genoeg om alle klassieke berekeningen uit te sluiten.</span><span class="sxs-lookup"><span data-stu-id="b30cf-215">The controlled-SWAP gate, also known as the Fredkin gate, is powerful enough to include all classical computation.</span></span>

<span data-ttu-id="b30cf-216">Ten slotte biedt de prelude twee bewerkingen voor het weer geven van exponenten van de Pauli Opera tors van meerdere Qubit.</span><span class="sxs-lookup"><span data-stu-id="b30cf-216">Finally, the prelude provides two operations for representing exponentials of multi-qubit Pauli operators.</span></span>
<span data-ttu-id="b30cf-217">De <xref:microsoft.quantum.intrinsic.exp> bewerking voert een rotatie uit op basis van een tensor-product van Pauli-matrices, zoals vertegenwoordigd door de multi-Qubit unitary \Begin{Equation} \operatorname{exp} (\vec{\sigma}, \phi) \mathrel{: =} \exp\left (i \phi \ sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation} waarbij $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ is een opeenvolging van single-Qubit Pauli-Opera tors en, waarbij $ \phi $ een hoek is.</span><span class="sxs-lookup"><span data-stu-id="b30cf-217">The <xref:microsoft.quantum.intrinsic.exp> operation performs a rotation based on a tensor product of Pauli matrices, as represented by the multi-qubit unitary \begin{equation} \operatorname{Exp}(\vec{\sigma}, \phi) \mathrel{:=} \exp\left(i \phi \sigma_0 \otimes \sigma_1 \otimes \cdots \otimes \sigma_n \right), \end{equation} where $\vec{\sigma} = (\sigma_0, \sigma_1, \dots, \sigma_n)$ is a sequence of single-qubit Pauli operators, and where $\phi$ is an angle.</span></span>
<span data-ttu-id="b30cf-218">De `Exp` rotatie vertegenwoordigt $ \vec{\sigma} $ als een matrix met `Pauli` elementen, zodat het een hand tekening heeft `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-218">The `Exp` rotation represents $\vec{\sigma}$ as an array of `Pauli` elements, such that it has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="b30cf-219">De <xref:microsoft.quantum.intrinsic.expfrac> bewerking voert dezelfde draaiing uit met behulp van de dyadic-fractie notatie die hierboven wordt beschreven.</span><span class="sxs-lookup"><span data-stu-id="b30cf-219">The <xref:microsoft.quantum.intrinsic.expfrac> operation performs the same rotation, using the dyadic fraction notation discussed above.</span></span>
<span data-ttu-id="b30cf-220">Deze heeft hand tekening `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-220">It has signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

> [!WARNING]
> <span data-ttu-id="b30cf-221">Exponentieel van het tensor product van Pauli-Opera tors zijn niet hetzelfde als tensor-producten van de exponenten van Pauli-Opera tors.</span><span class="sxs-lookup"><span data-stu-id="b30cf-221">Exponentials of the tensor product of Pauli operators are not the same as tensor products of the exponentials of Pauli operators.</span></span>
> <span data-ttu-id="b30cf-222">Dat wil zeggen, $e ^ {i (Z \otimes Z) \phi} \ne e ^ {i Z \phi} \otimes e ^ {i Z \phi} $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-222">That is, $e^{i (Z \otimes Z) \phi} \ne e^{i Z \phi} \otimes e^{i Z \phi}$.</span></span>

### <a name="measurements"></a><span data-ttu-id="b30cf-223">Metingen</span><span class="sxs-lookup"><span data-stu-id="b30cf-223">Measurements</span></span> ###

<span data-ttu-id="b30cf-224">Bij het meten moet de + 1-eigenvalue van de operator worden gemeten, overeenkomt met een `Zero` resultaat en de eigenvalue-1 tot een `One` resultaat.</span><span class="sxs-lookup"><span data-stu-id="b30cf-224">When measuring, the +1 eigenvalue of the operator being measured corresponds to a `Zero` result, and the -1 eigenvalue to a `One` result.</span></span>

> [!NOTE]
> <span data-ttu-id="b30cf-225">Hoewel deze Conventie mogelijk oneven lijkt, heeft deze twee zeer goede voor delen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-225">While this convention might seem odd, it has two very nice advantages.</span></span>
> <span data-ttu-id="b30cf-226">Ten eerste, waarbij het resultaat $ \ket {0} $ wordt weer gegeven door de `Result` waarde `Zero` , terwijl $ \ket {1} $ overeenkomt met `One` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-226">First, observing the outcome $\ket{0}$ is represented by the `Result` value `Zero`, while observing $\ket{1}$ corresponds to `One`.</span></span>
> <span data-ttu-id="b30cf-227">Ten tweede kunnen we schrijven dat de eigenvalue $ \lambda $ die overeenkomt met een resultaat $r $ $ \lambda = (-1) ^ r $ is.</span><span class="sxs-lookup"><span data-stu-id="b30cf-227">Second, we can write out that the eigenvalue $\lambda$ corresponding to a result $r$ is $\lambda = (-1)^r$.</span></span>

<span data-ttu-id="b30cf-228">Meting bewerkingen ondersteunen noch de `Adjoint` `Controlled` functor.</span><span class="sxs-lookup"><span data-stu-id="b30cf-228">Measurement operations support neither the `Adjoint` nor the `Controlled` functor.</span></span>

<span data-ttu-id="b30cf-229">Met deze <xref:microsoft.quantum.intrinsic.measure> bewerking wordt een gemeen schappelijke meting uitgevoerd van een of meer qubits in het opgegeven product van Pauli-Opera tors.</span><span class="sxs-lookup"><span data-stu-id="b30cf-229">The <xref:microsoft.quantum.intrinsic.measure> operation performs a joint measurement of one or more qubits in the specified product of Pauli operators.</span></span>
<span data-ttu-id="b30cf-230">Als de matrix Pauli en Qubit verschillende lengten hebben, mislukt de bewerking.</span><span class="sxs-lookup"><span data-stu-id="b30cf-230">If the Pauli array and qubit array are different lengths, then the operation fails.</span></span>
<span data-ttu-id="b30cf-231">`Measure`heeft hand tekening `((Pauli[], Qubit[]) => Result)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-231">`Measure` has signature `((Pauli[], Qubit[]) => Result)`.</span></span>

<span data-ttu-id="b30cf-232">Houd er rekening mee dat een gezamenlijke meting niet hetzelfde is als het meten van elk Qubit afzonderlijk.</span><span class="sxs-lookup"><span data-stu-id="b30cf-232">Note that a joint measurement is not the same as measuring each qubit individually.</span></span>
<span data-ttu-id="b30cf-233">Bekijk bijvoorbeeld de status $ \ket {11} = \ket {1} \otimes \Ket {1} = X\otimes X \ket {00} $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-233">For example, consider the state $\ket{11} = \ket{1} \otimes \ket{1} = X\otimes X \ket{00}$.</span></span>
<span data-ttu-id="b30cf-234">Voor het meten van $Z _0 $ en $Z _1 $ elke afzonderlijke, krijgen we de resultaten $r _0 = $1 en $r _1 = $1.</span><span class="sxs-lookup"><span data-stu-id="b30cf-234">Measuring $Z_0$ and $Z_1$ each individually, we get the results $r_0 = 1$ and $r_1 = 1$.</span></span>
<span data-ttu-id="b30cf-235">Meten $Z _0 Z_1 $, krijgen we echter het enige resultaat $r _ {\textrm{joint}} = $0, waarmee wordt aangegeven dat de paren van $ \ket {11} $ positief zijn.</span><span class="sxs-lookup"><span data-stu-id="b30cf-235">Measuring $Z_0 Z_1$, however, we get the single result $r_{\textrm{joint}} = 0$, representing that the pairity of $\ket{11}$ is positive.</span></span>
<span data-ttu-id="b30cf-236">Plaats een andere $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\textrm{joint}}) $.</span><span class="sxs-lookup"><span data-stu-id="b30cf-236">Put differently, $(-1)^{r_0 + r_1} = (-1)^r_{\textrm{joint}})$.</span></span>
<span data-ttu-id="b30cf-237">Omdat we de pariteit van deze meting *alleen* leren kennen, blijven de Quantum gegevens die worden weer gegeven in de superpositie tussen de 2 2-Qubit statussen van positieve pariteit, $ \ket {00} $ en $ \ket {11} $, behouden.</span><span class="sxs-lookup"><span data-stu-id="b30cf-237">Critically, since we *only* learn the parity from this measurement, any quantum information represented in the superposition between the two two-qubit states of positive parity, $\ket{00}$ and $\ket{11}$, is preserved.</span></span>
<span data-ttu-id="b30cf-238">Deze eigenschap is op een later tijdstip essentieel, omdat de fout correctie wordt besproken.</span><span class="sxs-lookup"><span data-stu-id="b30cf-238">This property will be essential later, as we discuss error correction.</span></span>

<span data-ttu-id="b30cf-239">Voor het gemak biedt de prelude ook twee andere bewerkingen voor het meten van qubits.</span><span class="sxs-lookup"><span data-stu-id="b30cf-239">For convenience, the prelude also provides two other operations for measuring qubits.</span></span>
<span data-ttu-id="b30cf-240">Ten eerste, omdat het uitvoeren van metingen met één Qubit heel gebruikelijk is, definieert de prelude een steno voor deze aanvraag.</span><span class="sxs-lookup"><span data-stu-id="b30cf-240">First, since performing single-qubit measurements is quite common, the prelude defines a shorthand for this case.</span></span>
<span data-ttu-id="b30cf-241">De <xref:microsoft.quantum.intrinsic.m> bewerking meet de Pauli $Z $-operator op één Qubit en heeft hand tekening `(Qubit => Result)` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-241">The <xref:microsoft.quantum.intrinsic.m> operation measures the Pauli $Z$ operator on a single qubit, and has signature `(Qubit => Result)`.</span></span>
<span data-ttu-id="b30cf-242">`M(q)`is gelijk aan `Measure([PauliZ], [q])` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-242">`M(q)` is equivalent to `Measure([PauliZ], [q])`.</span></span>

<span data-ttu-id="b30cf-243">De <xref:microsoft.quantum.measurement.multim> meet de Pauli $Z $-operator *afzonderlijk* op elk van een matrix van qubits en retourneert de *matrix* met waarden die zijn `Result` verkregen voor elke qubit.</span><span class="sxs-lookup"><span data-stu-id="b30cf-243">The <xref:microsoft.quantum.measurement.multim> measures the Pauli $Z$ operator *separately* on each of an array of qubits, returning the *array* of `Result` values obtained for each qubit.</span></span>
<span data-ttu-id="b30cf-244">In sommige gevallen kan dit worden geoptimaliseerd.</span><span class="sxs-lookup"><span data-stu-id="b30cf-244">In some cases this can be optimized.</span></span> <span data-ttu-id="b30cf-245">Deze heeft hand tekening ( `Qubit[] => Result[])` .</span><span class="sxs-lookup"><span data-stu-id="b30cf-245">It has signature (`Qubit[] => Result[])`.</span></span>
<span data-ttu-id="b30cf-246">`MultiM(qs)`is gelijk aan:</span><span class="sxs-lookup"><span data-stu-id="b30cf-246">`MultiM(qs)` is equivalent to:</span></span>

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a><span data-ttu-id="b30cf-247">Uitbreidings functies en-bewerkingen</span><span class="sxs-lookup"><span data-stu-id="b30cf-247">Extension Functions and Operations</span></span> ##

<span data-ttu-id="b30cf-248">Daarnaast definieert de prelude een uitgebreide set wiskundige en type conversie functies op .NET-niveau voor gebruik in Q# code.</span><span class="sxs-lookup"><span data-stu-id="b30cf-248">In addition, the prelude defines a rich set of mathematical and type conversion functions at the .NET level for use within Q# code.</span></span>
<span data-ttu-id="b30cf-249">Zo <xref:microsoft.quantum.math> definieert de naam ruimte nuttige bewerkingen zoals <xref:microsoft.quantum.math.sin> en <xref:microsoft.quantum.math.log> .</span><span class="sxs-lookup"><span data-stu-id="b30cf-249">For instance, the <xref:microsoft.quantum.math> namespace defines useful operations such as <xref:microsoft.quantum.math.sin> and <xref:microsoft.quantum.math.log>.</span></span>
<span data-ttu-id="b30cf-250">De implementatie van de Quantum Development Kit maakt gebruik van de klassieke .NET-basis klassen bibliotheek en kan daarom een extra communicatie tussen Quantum Program ma's en hun klassieke Stuur Programma's tot stand brengen.</span><span class="sxs-lookup"><span data-stu-id="b30cf-250">The implementation provided by the Quantum Development Kit uses the classical .NET base class library, and thus may involve an additional communications round trip between quantum programs and their classical drivers.</span></span>
<span data-ttu-id="b30cf-251">Hoewel dit geen probleem voor een lokale Simulator voordoet, kan dit een prestatie probleem zijn bij het gebruik van een externe Simulator of een echte hardware als doel computer.</span><span class="sxs-lookup"><span data-stu-id="b30cf-251">While this does not present a problem for a local simulator, this can be a performance issue when using a remote simulator or actual hardware as a target machine.</span></span>
<span data-ttu-id="b30cf-252">Op die manier kan een individuele doel computer deze invloed op de prestaties beperken door deze bewerkingen te overschrijven met versies die efficiënter zijn voor dat specifieke systeem.</span><span class="sxs-lookup"><span data-stu-id="b30cf-252">That said, an individual target machine may mitigate this performance impact by overriding these operations with versions that are more efficient for that particular system.</span></span>

### <a name="math"></a><span data-ttu-id="b30cf-253">Berekeningen</span><span class="sxs-lookup"><span data-stu-id="b30cf-253">Math</span></span> ###

<span data-ttu-id="b30cf-254">De <xref:microsoft.quantum.math> naam ruimte biedt veel nuttige functies van de [ `System.Math` klasse](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1)van de .net-basis klasse-bibliotheek.</span><span class="sxs-lookup"><span data-stu-id="b30cf-254">The <xref:microsoft.quantum.math> namespace provides many useful functions from the .NET base class library's [`System.Math` class](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1).</span></span>
<span data-ttu-id="b30cf-255">Deze functies kunnen op dezelfde manier worden gebruikt als andere Q# functies:</span><span class="sxs-lookup"><span data-stu-id="b30cf-255">These functions can be used in the same manner as any other Q# functions:</span></span>

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

<span data-ttu-id="b30cf-256">Wanneer een statische methode van .NET is overbelast op basis van het type van de argumenten, wordt de bijbehorende Q# functie vermeld met een achtervoegsel dat het type invoer aangeeft:</span><span class="sxs-lookup"><span data-stu-id="b30cf-256">Where a .NET static method has been overloaded based on the type of its arguments, the corresponding Q# function is annotated with a suffix indicating the type of its input:</span></span>

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a><span data-ttu-id="b30cf-257">Bitsgewijze bewerkingen</span><span class="sxs-lookup"><span data-stu-id="b30cf-257">Bitwise Operations</span></span> ###

<span data-ttu-id="b30cf-258">Ten slotte <xref:microsoft.quantum.bitwise> biedt de naam ruimte verschillende handige functies voor het bewerken van gehele getallen via bitsgewijze Opera tors.</span><span class="sxs-lookup"><span data-stu-id="b30cf-258">Finally, the <xref:microsoft.quantum.bitwise> namespace provides several useful functions for manipulating integers through bitwise operators.</span></span>
<span data-ttu-id="b30cf-259"><xref:microsoft.quantum.bitwise.parity>Retourneert bijvoorbeeld de bitsgewijze pariteit van een geheel getal als een ander geheel getal.</span><span class="sxs-lookup"><span data-stu-id="b30cf-259">For instance, <xref:microsoft.quantum.bitwise.parity> returns the bitwise parity of an integer as another integer.</span></span>
