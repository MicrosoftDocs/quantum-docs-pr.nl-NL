---
title: 'Gegevens structuren in de :::no-loc(Q#)::: standaard bibliotheken'
description: 'Meer informatie over gegevens structuren, Oracle en dynamische generatoren in de micro soft- :::no-loc(Q#)::: standaard bibliotheken.'
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: c3ce5d531618c269d15be3e4eb58ecbb597a022c
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692241"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="a52b1-103">Gegevens structuren en model lering</span><span class="sxs-lookup"><span data-stu-id="a52b1-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="a52b1-104">Klassieke gegevens structuren</span><span class="sxs-lookup"><span data-stu-id="a52b1-104">Classical Data Structures</span></span> ##

<span data-ttu-id="a52b1-105">Naast door de gebruiker gedefinieerde typen voor het weer geven van Quantum concepten, biedt Canon ook bewerkingen, functies en typen voor het werken met klassieke gegevens die worden gebruikt in het beheer van Quantum systemen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="a52b1-106">De <xref:Microsoft.Quantum.Arrays.Reversed> functie neemt bijvoorbeeld een matrix als invoer en retourneert dezelfde matrix in omgekeerde volg orde.</span><span class="sxs-lookup"><span data-stu-id="a52b1-106">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="a52b1-107">Dit kan vervolgens worden gebruikt voor een matrix van het type `Qubit[]` om te voor komen dat overbodige $ \operatorname{swap} $ Gates worden toegepast bij de conversie tussen Quantum representaties van gehele getallen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="a52b1-108">We hebben in de vorige sectie gezien dat typen van het formulier `(Int, Int -> T)` handig kunnen zijn voor het weer geven van wille keurige toegangs verzamelingen <xref:Microsoft.Quantum.Arrays.LookupFunction> . de functie biedt daarom een handige manier om dergelijke typen van matrix typen samen te stellen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:Microsoft.Quantum.Arrays.LookupFunction> function provides a convenient way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="a52b1-109">Paarsgewijs</span><span class="sxs-lookup"><span data-stu-id="a52b1-109">Pairs</span></span> ###

<span data-ttu-id="a52b1-110">De Canon ondersteunt de functionele stijl notatie voor paren, een aanvulling op de toegang tot Tuples door het ontbouwen:</span><span class="sxs-lookup"><span data-stu-id="a52b1-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="a52b1-111">Matrices</span><span class="sxs-lookup"><span data-stu-id="a52b1-111">Arrays</span></span> ###

<span data-ttu-id="a52b1-112">De Canon biedt verschillende functies voor het bewerken van matrices.</span><span class="sxs-lookup"><span data-stu-id="a52b1-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="a52b1-113">Deze functies zijn van het type para meters en kunnen dus worden gebruikt met matrices van elk :::no-loc(Q#)::: type.</span><span class="sxs-lookup"><span data-stu-id="a52b1-113">These functions are type-parameterized, and thus can be used with arrays of any :::no-loc(Q#)::: type.</span></span>
<span data-ttu-id="a52b1-114">De <xref:Microsoft.Quantum.Arrays.Reversed> functie retourneert bijvoorbeeld een nieuwe matrix waarvan de elementen in omgekeerde volg orde van de invoer worden weer gegeven.</span><span class="sxs-lookup"><span data-stu-id="a52b1-114">For instance, the <xref:Microsoft.Quantum.Arrays.Reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="a52b1-115">Dit kan worden gebruikt om te wijzigen hoe een Quantum register wordt weer gegeven bij het aanroepen van bewerkingen:</span><span class="sxs-lookup"><span data-stu-id="a52b1-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="a52b1-116">De <xref:Microsoft.Quantum.Arrays.Subarray> functie kan ook worden gebruikt om de volg orde van de elementen van een matrix te wijzigen of er subsets van te maken:</span><span class="sxs-lookup"><span data-stu-id="a52b1-116">Similarly, the <xref:Microsoft.Quantum.Arrays.Subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="a52b1-117">In combi natie met Datatransport besturing kunnen matrix manipulatie functies, zoals, <xref:Microsoft.Quantum.Arrays.Zipped> een krachtige manier bieden om Quantum Program ma's uit te voeren:</span><span class="sxs-lookup"><span data-stu-id="a52b1-117">When combined with flow control, array manipulation functions such as <xref:Microsoft.Quantum.Arrays.Zipped> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zipped([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="a52b1-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="a52b1-118">Oracles</span></span> ##

<span data-ttu-id="a52b1-119">In de [fase schatting](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) en [amplitude versterking](https://en.wikipedia.org/wiki/Amplitude_amplification) wordt het concept van een Oracle regel matig weer gegeven.</span><span class="sxs-lookup"><span data-stu-id="a52b1-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="a52b1-120">Hier verwijst de term Oracle naar een blackbox-Quantum-subroutine die wordt toegepast op een set qubits en die het antwoord als een fase retourneert.</span><span class="sxs-lookup"><span data-stu-id="a52b1-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="a52b1-121">Deze subroutine kan vaak worden beschouwd als een invoer voor een Quantum algoritme die de Oracle accepteert, naast enkele andere para meters, en past een reeks Quantum bewerkingen toe en behandelt een aanroep naar deze Quantum subroutine alsof het een fundamenteel poort is.</span><span class="sxs-lookup"><span data-stu-id="a52b1-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="a52b1-122">Uiteraard moet, om het grotere algoritme te implementeren, een concreet ontbinding van de Oracle in fundamentele Gates worden gegeven, maar een dergelijke ontbinding is niet nodig om inzicht te krijgen in het algoritme dat de Oracle aanroept.</span><span class="sxs-lookup"><span data-stu-id="a52b1-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="a52b1-123">In :::no-loc(Q#)::: wordt deze abstractie vertegenwoordigd door gebruik te maken van die bewerkingen waarden voor de eerste klasse, zodat de bewerkingen kunnen worden door gegeven aan implementaties van Quantum algoritmen in een Black Box-vorm.</span><span class="sxs-lookup"><span data-stu-id="a52b1-123">In :::no-loc(Q#):::, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="a52b1-124">Daarnaast worden door de gebruiker gedefinieerde typen gebruikt voor het labelen van de verschillende Oracle-representaties op een type veilige manier, waardoor het moeilijk is om verschillende soorten Black Box-bewerkingen per ongeluk te verkleinen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidentally conflate different kinds of black box operations.</span></span>

<span data-ttu-id="a52b1-125">Dergelijke Oracle worden weer gegeven in een aantal verschillende contexten, waaronder beroemde-voor beelden zoals de zoek-en Quantum-simulatie algoritmen [van Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) .</span><span class="sxs-lookup"><span data-stu-id="a52b1-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="a52b1-126">Hier richten we ons op de Oracle die nodig zijn voor slechts twee toepassingen: amplitude versterking en fase schatting.</span><span class="sxs-lookup"><span data-stu-id="a52b1-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="a52b1-127">We bespreken eerst amplitude versterking van Oracle, voordat u verdergaat met de fase schatting.</span><span class="sxs-lookup"><span data-stu-id="a52b1-127">We will first discuss amplitude amplification oracles before proceeding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="a52b1-128">Met amplitude verhogen Oracle</span><span class="sxs-lookup"><span data-stu-id="a52b1-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="a52b1-129">Het proces van de amplitude versterking strekt ertoe een rotatie uit te voeren tussen een initiële staat en een eind status door een reeks reflecties van de staat toe te passen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="a52b1-130">Om het algoritme te laten functioneren, moet deze beide statussen worden opgegeven.</span><span class="sxs-lookup"><span data-stu-id="a52b1-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="a52b1-131">Deze specificaties worden gegeven door twee Oracle.</span><span class="sxs-lookup"><span data-stu-id="a52b1-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="a52b1-132">Deze Oracle werken door de invoer in twee spaties, een ' doel-' subruimte en een ' eerste ' subruimte te breken.</span><span class="sxs-lookup"><span data-stu-id="a52b1-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="a52b1-133">De Oracle-producten identificeren dergelijke subruimten, vergelijkbaar met de manier waarop Pauli-Opera tors twee ruimten identificeren, door een $ \pm $1-fase op deze ruimten toe te passen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="a52b1-134">Het belangrijkste verschil is dat deze ruimten geen halve ruimte in deze toepassing hoeven te zijn.</span><span class="sxs-lookup"><span data-stu-id="a52b1-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="a52b1-135">Houd er ook rekening mee dat deze twee subruimten meestal niet wederzijds worden exclusief: er zijn vectoren die lid zijn van beide spaties.</span><span class="sxs-lookup"><span data-stu-id="a52b1-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="a52b1-136">Als dat niet het geval is, zou de amplitude versterking geen effect hebben, zodat de eerste subruimte niet-nul overlapt met de doel-subruimte.</span><span class="sxs-lookup"><span data-stu-id="a52b1-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="a52b1-137">We zullen de eerste Oracle aanduiden die we nodig hebben voor een amplitude versterking van $P \_ $0, gedefinieerd om de volgende actie te kunnen ondernemen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="a52b1-138">Voor alle statussen $ \ket{x} $ in de "eerste" subruimte $P \_ 0 \ket{x} =-\ket{x} $ en voor alle staten $ \ket{y} $ die zich niet in deze subruimte bevinden, hebben we $P \_ 0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="a52b1-139">De Oracle die de doel-subruimte markeert, $P _1 $ heeft precies hetzelfde formulier.</span><span class="sxs-lookup"><span data-stu-id="a52b1-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="a52b1-140">Voor alle statussen $ \ket{x} $ in de doel-subruimte (bijvoorbeeld voor alle statussen die u wilt laten uitvoeren), $P _1 \ Ket {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="a52b1-141">Op dezelfde manier geldt dat voor alle staten $ \ket{y} $ die zich niet in de doel ruimte bevinden $P _1 \ Ket {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="a52b1-142">Deze twee reflecties worden vervolgens gecombineerd om een operator te vormen die één stap van de amplitude versterking aanneemt, $Q =-P_0 P_1 $, waarbij het totale minteken alleen belang rijk is om te overwegen in beheerde toepassingen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="a52b1-143">De versterkings versterking van de amplitude gaat vervolgens door een initiële status, $ \ket{\psi} $, die zich in de eerste subruimte bevindt en voert vervolgens $ \ket{\psi} \mapsto Q ^ m \ket{\psi} $ uit.</span><span class="sxs-lookup"><span data-stu-id="a52b1-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="a52b1-144">Het uitvoeren van een dergelijke iteratie garandeert dat als er een begin status is die overlap $ \sin ^ 2 (\theta) $ met de gemarkeerde ruimte bevat en na $m $ iteraties deze overlap ping wordt $ \sin ^ 2 ([2 min. + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="a52b1-145">Daarom wilt u $m $ kiezen als een gratis para meter, zodat $ [2 min. + 1] \theta = \ pi/2 $; dergelijke stijve keuzes zijn echter niet zo belang rijk voor sommige vormen van amplitude versterking, zoals het verhogen van een amplitude van het vaste punt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="a52b1-146">Met dit proces kan ons een status voorbereiden in de gemarkeerde subruimte met behulp van quadratically minder query's naar de Mark-functie en de status voorbereidings functie dan zou kunnen worden uitgevoerd op een strikt klassiek apparaat.</span><span class="sxs-lookup"><span data-stu-id="a52b1-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="a52b1-147">Daarom is amplitude versterking een belang rijke bouw steen voor veel toepassingen van Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="a52b1-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="a52b1-148">Om inzicht te krijgen in hoe u het algoritme kunt gebruiken, is het handig om een voor beeld te bieden dat een constructie van de Oracle biedt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="a52b1-149">Overweeg het uitvoeren van de Grover-algoritme voor het zoeken naar data bases in deze instelling.</span><span class="sxs-lookup"><span data-stu-id="a52b1-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="a52b1-150">In de zoek opdracht van Grover is het doel om de status te transformeren $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket {0} $ in een van (mogelijk) veel gemarkeerde statussen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="a52b1-151">Om verder te vereenvoudigen, laten we eens kijken naar het geval waarin de enige status is ingesteld op $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="a52b1-152">Vervolgens zijn er twee Oracle-ontwerpen: een die alleen de initiële status $ \ket{+} ^ {\otimes n} $ markeert met een minteken en een andere die de gemarkeerde status $ \ket $ markeert {0} met een minteken.</span><span class="sxs-lookup"><span data-stu-id="a52b1-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="a52b1-153">De laatste Gate kan worden geïmplementeerd met behulp van de volgende proces bewerking, met behulp van de controle stroom bewerkingen in de Canon:</span><span class="sxs-lookup"><span data-stu-id="a52b1-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="a52b1-154">Deze Oracle is vervolgens een speciaal geval van de <xref:Microsoft.Quantum.Canon.RAll1> bewerking, waardoor het mogelijk is om te roteren met een wille keurige fase in plaats van de reflectie Case $ \phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-154">This oracle is then a special case of the <xref:Microsoft.Quantum.Canon.RAll1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="a52b1-155">In dit geval `RAll1` is de <xref:Microsoft.Quantum.Intrinsic.R1> prelude-bewerking vergelijkbaar met het draaien van $ \ket{11\cdots1} $ in plaats van de single-Qubit status $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-155">In this case, `RAll1` is similar to the <xref:Microsoft.Quantum.Intrinsic.R1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="a52b1-156">De Oracle die de eerste subruimte markeert, kan op dezelfde manier worden samengesteld.</span><span class="sxs-lookup"><span data-stu-id="a52b1-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="a52b1-157">In pseudocode:</span><span class="sxs-lookup"><span data-stu-id="a52b1-157">In pseudocode:</span></span>

1. <span data-ttu-id="a52b1-158">$H $ Gates op elke qubit Toep assen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="a52b1-159">$X $ Gates op elke qubit Toep assen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="a52b1-160">Pas een door $n $1 beheerde $Z $-Gate toe op de $n ^ {\Text{th}} $ Qubit.</span><span class="sxs-lookup"><span data-stu-id="a52b1-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="a52b1-161">$X $ Gates op elke qubit Toep assen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="a52b1-162">$H $ Gates op elke qubit Toep assen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="a52b1-163">Deze keer worden ook gedemonstreerd met <xref:Microsoft.Quantum.Canon.ApplyWith> de <xref:Microsoft.Quantum.Canon.RAll1> bewerking die hierboven wordt beschreven:</span><span class="sxs-lookup"><span data-stu-id="a52b1-163">This time, we also demonstrate using <xref:Microsoft.Quantum.Canon.ApplyWith> together with the <xref:Microsoft.Quantum.Canon.RAll1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="a52b1-164">We kunnen deze twee Oracle vervolgens samen combi neren om te roteren tussen de twee staten en deterministischly transformeren $ \ket{+} ^ {\otimes n} $ to $ \ket {0} $ met behulp van een aantal lagen van Hadamard-Gates dat proportioneel is aan $ \sqrt{2 ^ n} $ (ie $m \propto \sqrt{2 ^ n} $) ten opzichte van de ongeveer $2 ^ n $ lagen die nodig zouden zijn voor het niet-deterministisch voorbereiden van de $ \ket {0} $-status door de eerste toestand voor te bereiden en te meten, totdat het resultaat $0 $ wordt waargenomen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="a52b1-165">Fase schatting Oracle</span><span class="sxs-lookup"><span data-stu-id="a52b1-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="a52b1-166">Voor een gefaseerde schatting zijn de Oracle enigszins natuurlijk iets meer.</span><span class="sxs-lookup"><span data-stu-id="a52b1-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="a52b1-167">De beoogde fase schatting is het ontwerpen van een subroutine die kan worden gesampling van de eigenvalues van een unitary-matrix.</span><span class="sxs-lookup"><span data-stu-id="a52b1-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="a52b1-168">Deze methode is onmisbaar in de Quantum simulatie omdat voor veel fysieke problemen in schei-en materiaal wetenschappen deze eigenvalues de grond staat Energies van Quantum systemen, die ons waardevolle informatie biedt over de fase diagrammen van materialen en reactie dynamiek voor moleculen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-168">This method is indispensable in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="a52b1-169">Elk soort fase schatting heeft een invoer unitary nodig.</span><span class="sxs-lookup"><span data-stu-id="a52b1-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="a52b1-170">Deze unitary wordt standaard beschreven door een van de twee typen Oracle.</span><span class="sxs-lookup"><span data-stu-id="a52b1-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="a52b1-171">Beide Oracle-typen die hieronder worden beschreven, zijn opgenomen in de voor beelden.</span><span class="sxs-lookup"><span data-stu-id="a52b1-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="a52b1-172">Zie het [ **PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation)-voor beeld voor meer informatie over continue query Oracle.</span><span class="sxs-lookup"><span data-stu-id="a52b1-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation).</span></span>
> <span data-ttu-id="a52b1-173">Zie het [ **IsingPhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation)-voor beeld voor meer informatie over discrete query-Oracle.</span><span class="sxs-lookup"><span data-stu-id="a52b1-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/phase-estimation).</span></span>

<span data-ttu-id="a52b1-174">Het eerste type Oracle, waarmee we een discrete query Oracle aanroepen en met het door de gebruiker gedefinieerde type vertegenwoordigen <xref:Microsoft.Quantum.Oracles.DiscreteOracle> , bestaat uit een unitary matrix.</span><span class="sxs-lookup"><span data-stu-id="a52b1-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:Microsoft.Quantum.Oracles.DiscreteOracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="a52b1-175">Als $U $ de unitary is waarvan de eigenvalues een schatting wil maken, is de Oracle voor $U $ gewoon een standaard voor een subroutine waarmee $U $ wordt geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="a52b1-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="a52b1-176">Een voor beeld: het kan $U $ nemen als de hierboven gedefinieerde Oracle-$Q $ voor de schatting van de amplitude.</span><span class="sxs-lookup"><span data-stu-id="a52b1-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="a52b1-177">De eigenvalues van deze matrix kan worden gebruikt om de overlap ping te ramen tussen de eerste en de doel status, $ \sin ^ 2 (\theta) $, met behulp van quadratically minder steek proeven dan het enige wat zou nodig zouden zijn.</span><span class="sxs-lookup"><span data-stu-id="a52b1-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="a52b1-178">Dit verdient de toepassing van de fase schatting met behulp van de Grover Oracle $Q $ als invoer van de moniker van de amplitude schatting.</span><span class="sxs-lookup"><span data-stu-id="a52b1-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="a52b1-179">Een andere algemene toepassing, veel gebruikt in Quantum-metrologies, is een schatting van een kleine draai hoek.</span><span class="sxs-lookup"><span data-stu-id="a52b1-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="a52b1-180">Met andere woorden, we willen $ \theta $ schatten voor een onbekende rotatie poort van het formulier $R _z (\theta) $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="a52b1-181">In dergelijke gevallen zou de subroutine waarmee we werken om deze vaste waarde van $ \theta $ voor de poort te leren kennen, $ $ \begin{align} U & = R_z (\theta) \\ \\ & = \begin{bmatrix} e ^ {-i \theta/2} & 0 \\ \\ 0 & e ^ {i \ theta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="a52b1-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="a52b1-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="a52b1-182">\end{align} $$</span></span>

<span data-ttu-id="a52b1-183">Het tweede type Oracle dat in fase schatting wordt gebruikt, is de continue query Oracle, vertegenwoordigd door het <xref:Microsoft.Quantum.Oracles.ContinuousOracle> type.</span><span class="sxs-lookup"><span data-stu-id="a52b1-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:Microsoft.Quantum.Oracles.ContinuousOracle> type.</span></span>
<span data-ttu-id="a52b1-184">Een continue query in Oracle voor fase schatting neemt de vorm $U (t) $ waarbij $t $ een klassiek bekend reëel getal is.</span><span class="sxs-lookup"><span data-stu-id="a52b1-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="a52b1-185">Als we $U $ een vast unitary hebben, neemt de doorlopende query Oracle het formulier $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="a52b1-186">Hierdoor kunnen we matrixen opvragen, zoals $ \sqrt{U} $, die niet rechtstreeks in het discrete query model kunnen worden geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="a52b1-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="a52b1-187">Dit type Oracle is waardevol wanneer u een bepaalde unitary niet doorzoekt, maar de eigenschappen van de generator van de unitary wilt weten.</span><span class="sxs-lookup"><span data-stu-id="a52b1-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="a52b1-188">In een dynamische Quantum simulatie is het doel bijvoorbeeld om Quantum circuits te ontwikkelen die nauw $U (t) = e ^ {-i H t} $ voor een Hermitian matrix $H $ en ontwikkelings tijd $t $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="a52b1-189">De eigenvalues van $U (t) $ zijn direct gerelateerd aan de eigenvalues van $H $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="a52b1-190">Als u dit wilt zien, kunt u een eigenvector van $H $: $H \ket{E} = E\ket {E} $ overwegen. het is eenvoudig om te zien van de definitie van de matrix exponentieel dat $U (t) \ket{E} = e ^ {i\phi} \ Ket {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="a52b1-191">Door de eigenphase van $U (t) $ te schatten, geeft u de eigenvalue $E $ op, ervan uitgaande dat de eigenvector $ \ket{E} $ wordt ingevoerd in het fase schattings algoritme.</span><span class="sxs-lookup"><span data-stu-id="a52b1-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="a52b1-192">In dit geval kan de waarde $t $ echter worden gekozen op basis van de keuze van de gebruiker, omdat voor een voldoende kleine waarde van $t $ de eigenvalue $E $ kan worden teruggedraaid via $E =-\ Phi/t $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="a52b1-193">Aangezien Quantum simulatie methoden de mogelijkheid bieden om een gedeeltelijke evolutie uit te voeren, is dit een extra vrijheid bij het uitvoeren van een query op de unitary, met name hoewel het discrete query model alleen unitaries van het formulier toestaat $U ^ j $ voor het Toep assen van een geheel getal $j $ de continue query in Oracle kan unitaries van het formulier benaderen $U ^ t $ voor echte waarden $t $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="a52b1-194">Dit is belang rijk voor het samen voegen van elke laatste ounce van efficiëntie voor de fase schattings algoritmen, omdat hiermee precies het experiment kan worden gekozen waarmee de meeste informatie over $E $; de methoden op basis van discrete query's moeten in het gedrang komen door het beste gehele aantal query's in het algoritme te kiezen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="a52b1-195">Als concreet voor beeld moet u rekening houden met het probleem bij het schatten van de draai hoek van een Gate, maar de verwerkings frequentie van een Roteer Quantum systeem.</span><span class="sxs-lookup"><span data-stu-id="a52b1-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="a52b1-196">De unitary die een dergelijke Quantum dynamiek beschrijft, is $U (t) = R_z (2 \ Omega t) $ voor ontwikkelings tijd $t $ en onbekende frequentie $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="a52b1-197">In deze context kunnen we $U (t) $ voor elke $t $ simuleren met behulp van één $R _z-Gate en zo dat zelf niet hoeft te worden beperkt tot afzonderlijke query's voor de unitary.</span><span class="sxs-lookup"><span data-stu-id="a52b1-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="a52b1-198">Een dergelijk doorlopende model heeft ook de eigenschap die de frequenties groter dan $2 \ PI $ kan worden geleerd van fase schattings processen die doorlopende query's gebruiken omdat de fase-informatie die anders zou worden gemaskeerd door de vertakking van de functie logaritme kan worden onthuld op basis van de resultaten van experimenten die worden uitgevoerd op niet-proportionele waarden van $t $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="a52b1-199">Daarom zijn problemen zoals deze continue query modellen voor de fase schatting Oracle niet alleen geschikt, maar ook de voor keur voor het discrete query model.</span><span class="sxs-lookup"><span data-stu-id="a52b1-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="a52b1-200">Daarom :::no-loc(Q#)::: heeft de functionaliteit voor beide vormen van query's en kan deze door de gebruiker worden afgestemd op een fase schattings algoritme om te voldoen aan de behoeften en het type Oracle dat beschikbaar is.</span><span class="sxs-lookup"><span data-stu-id="a52b1-200">For this reason :::no-loc(Q#)::: has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="a52b1-201">Model lering van dynamische generator</span><span class="sxs-lookup"><span data-stu-id="a52b1-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="a52b1-202">Generatoren van tijd-ontwikkeling beschrijven hoe statussen door de tijd worden ontwikkeld.</span><span class="sxs-lookup"><span data-stu-id="a52b1-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="a52b1-203">Zo wordt de dynamiek van een Quantum status $ \ket{\psi} $ geregeld door de Schrödinger-vergelijking $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ met een Hermitian matrix $H $, de Hamiltonian, als de generator van bewegingen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="a52b1-204">Op basis van een initiële status $ \ket{\psi (0)} $ op tijdstip $t = $0, de formele oplossing voor deze vergelijking op het moment $t $ kan zijn: in principe, geschreven $ $ \begin{align} \ket{\psi (t)} = U (t) \ket{\psi (0)}, \end{align} $ $, waarbij de matrix exponentiële $U (t) = e ^ {-i H t} $ wordt aangeduid als de operator unitary time-evolutie.</span><span class="sxs-lookup"><span data-stu-id="a52b1-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="a52b1-205">Hoewel we ons richten op de genera tors van dit formulier, is het belang rijk dat het concept uitgebreid van toepassing is, zoals voor de simulatie van open Quantum systemen, of op meer abstracte differentiële vergelijkingen.</span><span class="sxs-lookup"><span data-stu-id="a52b1-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="a52b1-206">Een primair doel van dynamische simulatie is het implementeren van de operator voor tijd ontwikkeling op een versleutelde Quantum status in qubits van een quantum computer.</span><span class="sxs-lookup"><span data-stu-id="a52b1-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="a52b1-207">In veel gevallen kan de Hamiltonian worden opgesplitst in een som van enkele $d $ gecompliceerde termen</span><span class="sxs-lookup"><span data-stu-id="a52b1-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="a52b1-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="a52b1-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="a52b1-209">Wanneer tijd-ontwikkeling per term eenvoudig is om op een quantum computer te implementeren.</span><span class="sxs-lookup"><span data-stu-id="a52b1-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="a52b1-210">Als $H _j $ bijvoorbeeld een Pauli is $X _1X_2 $-operator die wordt uitgevoerd op de eerste en 2e elementen van het Qubit `qubits` -REGI ster, kan de tijd worden gepasseerd voor elke tijd $t $ kan eenvoudigweg worden geïmplementeerd door de bewerking `Exp([PauliX,PauliX], t, qubits[1..2])` aan te roepen, die hand tekening heeft `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="a52b1-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="a52b1-211">Zoals verderop in Hamiltonian simulatie wordt beschreven, is één oplossing een benadering van de tijd evolutie van $H $ met een reeks eenvoudige bewerkingen</span><span class="sxs-lookup"><span data-stu-id="a52b1-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="a52b1-212">$ $ \begin{align} U (t) & = \left (e ^ {-iH \_ 0 t/r} e ^ {-IH \_ 1 t/r} \cdots e ^ {-IH \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="a52b1-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="a52b1-213">waarbij het gehele getal $r > $0 de aanpassings fout bepaalt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="a52b1-214">De model bibliotheek voor dynamische Generator biedt een framework voor het systematisch coderen van gecompliceerde generators in termen van eenvoudigere Generators.</span><span class="sxs-lookup"><span data-stu-id="a52b1-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="a52b1-215">Een dergelijke beschrijving kan vervolgens worden door gegeven aan de simulatie bibliotheek voor het implementeren van tijd evolutie door een simulatie algoritme van keuze, waarbij veel details automatisch worden verwerkt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="a52b1-216">De dynamische Generator bibliotheek die hieronder wordt beschreven, is opgenomen in de voor beelden.</span><span class="sxs-lookup"><span data-stu-id="a52b1-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="a52b1-217">Voor een voor beeld op basis van het Ising-model raadpleegt u het [ **IsingGenerators**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators)-voor beeld.</span><span class="sxs-lookup"><span data-stu-id="a52b1-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/generators).</span></span>
> <span data-ttu-id="a52b1-218">Voor een voor beeld op basis van moleculaire water stof raadpleegt u de voor beelden van [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) en [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) .</span><span class="sxs-lookup"><span data-stu-id="a52b1-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line) and [**H2SimulationGUI**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/gui) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="a52b1-219">Volledige beschrijving van een generator</span><span class="sxs-lookup"><span data-stu-id="a52b1-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="a52b1-220">Op het hoogste niveau bevindt zich een volledige beschrijving van een Hamiltonian in het door de `EvolutionGenerator` gebruiker gedefinieerde type dat twee onderdelen heeft.:</span><span class="sxs-lookup"><span data-stu-id="a52b1-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="a52b1-221">Het door de `GeneratorSystem` gebruiker gedefinieerde type is een klassieke beschrijving van de Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="a52b1-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="a52b1-222">Het eerste element `Int` van de tuple slaat het aantal termen $d $ op in de Hamiltonian, en het tweede element `(Int -> GeneratorIndex)` is een functie die een gehele index in $ \{ 0, 1,..., d-1 $ toewijst \} aan een door de `GeneratorIndex` gebruiker gedefinieerd type waarmee elke primitieve term in de Hamiltonian uniek wordt geïdentificeerd.</span><span class="sxs-lookup"><span data-stu-id="a52b1-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="a52b1-223">Houd er rekening mee dat door het verzamelen van voor waarden in de Hamiltonian als een functie in plaats van een matrix `GeneratorIndex[]` te gebruiken, dit de mogelijkheid biedt om op basis van de `GeneratorIndex` waarde die het meest geschikt is bij het beschrijven van Hamiltonians met een groot aantal voor waarden.</span><span class="sxs-lookup"><span data-stu-id="a52b1-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="a52b1-224">Het is van cruciaal belang dat we geen conventies opleggen voor de primitieve termen die zijn geïdentificeerd door de `GeneratorIndex` eenvoudige simulatie.</span><span class="sxs-lookup"><span data-stu-id="a52b1-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="a52b1-225">Primitieve termen kunnen bijvoorbeeld worden Pauli Opera tors zoals hierboven beschreven, maar ze kunnen ook Fermionic Annihilation zijn en Opera tors maken die vaak worden gebruikt in de vorm van quantum chemie.</span><span class="sxs-lookup"><span data-stu-id="a52b1-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="a52b1-226">Op zichzelf is een ' `GeneratorIndex` Onwaar ', wat betekent dat er niet wordt beschreven hoe tijd-evolutie door de term waar deze naar wijst, kan worden geïmplementeerd als een Quantum circuit.</span><span class="sxs-lookup"><span data-stu-id="a52b1-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="a52b1-227">Dit probleem wordt opgelost door een door `EvolutionSet` de gebruiker gedefinieerd type op te geven waarmee een `GeneratorIndex` van de canonieke sets wordt toegewezen aan een unitary-operator, de `EvolutionUnitary` , uitgedrukt als een Quantum circuit.</span><span class="sxs-lookup"><span data-stu-id="a52b1-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="a52b1-228">De `EvolutionSet` definieert de Conventie van de manier waarop een `GeneratorIndex` Structured is en definieert ook de mogelijke reeks `GeneratorIndex` .</span><span class="sxs-lookup"><span data-stu-id="a52b1-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="a52b1-229">Pauli operator Generators</span><span class="sxs-lookup"><span data-stu-id="a52b1-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="a52b1-230">Een concreet en nuttig voor beeld van generatoren zijn Hamiltonians die een som zijn van Pauli-Opera Tors, elk mogelijk met een andere coëfficiënt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="a52b1-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $ waarbij elke $ \hat-H_j $ nu wordt getrokken van de Pauli groep.</span><span class="sxs-lookup"><span data-stu-id="a52b1-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="a52b1-232">Voor dergelijke systemen bieden we het `PauliEvolutionSet()` type `EvolutionSet` dat een conventie definieert voor de manier waarop een element van de Pauli-groep en een coëfficiënt kunnen worden geïdentificeerd door een `GeneratorIndex` , die de volgende hand tekening heeft.</span><span class="sxs-lookup"><span data-stu-id="a52b1-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="a52b1-233">In onze code ring specificeert de eerste para meter `Int[]` een Pauli teken reeks, waarbij $ \Hat I\rightarrow $0, $ \Hat X\rightarrow $1, $ \Hat Y\rightarrow $2, en $ \Hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="a52b1-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="a52b1-234">Met de tweede para meter wordt `Double[]` de coëfficiënt van de Pauli-teken reeks opgeslagen in de Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="a52b1-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="a52b1-235">Houd er rekening mee dat alleen het eerste element van deze matrix wordt gebruikt.</span><span class="sxs-lookup"><span data-stu-id="a52b1-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="a52b1-236">De derde para meter `Int[]` indexeert de qubits die door deze Pauli teken reeks wordt toegepast en mag geen dubbele elementen bevatten.</span><span class="sxs-lookup"><span data-stu-id="a52b1-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="a52b1-237">Daarom kan de Hamiltonian term $0,4 \hat X_0 \hat Y_8 \hat I_2 \hat Z_1 $ worden weer gegeven als</span><span class="sxs-lookup"><span data-stu-id="a52b1-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="a52b1-238">De `PauliEvolutionSet()` is een functie waarmee een `GeneratorIndex` van dit formulier wordt toegewezen aan een `EvolutionUnitary` met de volgende hand tekening.</span><span class="sxs-lookup"><span data-stu-id="a52b1-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="a52b1-239">De eerste para meter vertegenwoordigt een tijd duur, die wordt vermenigvuldigd met de coëfficiënt in de `GeneratorIndex` , van unitary-evolutie.</span><span class="sxs-lookup"><span data-stu-id="a52b1-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="a52b1-240">De tweede para meter is het Qubit registreren van de unitary.</span><span class="sxs-lookup"><span data-stu-id="a52b1-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="a52b1-241">Time-Dependent-Generators</span><span class="sxs-lookup"><span data-stu-id="a52b1-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="a52b1-242">In veel gevallen zijn we ook geïnteresseerd in het model leren van tijd afhankelijke generatoren, zoals kan optreden in de Schrödinger-vergelijking $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = \hat H (t) \ket{\psi (t)}, \end{align} $ $, waarbij de generator $ \hat H (t) $ nu tijd afhankelijk is.</span><span class="sxs-lookup"><span data-stu-id="a52b1-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="a52b1-243">De uitbrei ding van de tijd onafhankelijke genera tors hierboven is eenvoudig.</span><span class="sxs-lookup"><span data-stu-id="a52b1-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="a52b1-244">In plaats van een probleem `GeneratorSystem` te hebben met het Hamiltonian voor alle keren $t $, hebben we het type dat door de `GeneratorSystemTimeDependent` gebruiker is gedefinieerd.</span><span class="sxs-lookup"><span data-stu-id="a52b1-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="a52b1-245">De eerste para meter is een doorlopende schema parameter $s \in [0, 1] $, en functies van dit type retour neren een `GeneratorSystem` voor dat schema.</span><span class="sxs-lookup"><span data-stu-id="a52b1-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="a52b1-246">Houd er rekening mee dat de plannings parameter lineair kan zijn gerelateerd aan de para meter voor fysieke tijd, bijvoorbeeld $s = t/T $, voor een totale tijd van simulatie $T $.</span><span class="sxs-lookup"><span data-stu-id="a52b1-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="a52b1-247">In het algemeen hoeft dit echter niet het geval te zijn.</span><span class="sxs-lookup"><span data-stu-id="a52b1-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="a52b1-248">Op dezelfde manier is voor een volledige beschrijving van deze generator een `EvolutionSet` , en dus een door de `EvolutionSchedule` gebruiker gedefinieerd type gedefinieerd.</span><span class="sxs-lookup"><span data-stu-id="a52b1-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
