---
title: Quantum karakte Rise ring en statistieken
description: Meer informatie over de meting statistieken van fase schattingen worden gebruikt om resultaat waarden in Quantum Program ma's te schatten.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: 989806eeb58a0a50a00e9338c7ea653e1e47d7f4
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857227"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="b3dec-103">Quantum karakte Rise ring en statistieken</span><span class="sxs-lookup"><span data-stu-id="b3dec-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="b3dec-104">Het is essentieel dat u de gevolgen van bewerkingen kunt kenmerken om nuttige Quantum algoritmen te ontwikkelen.</span><span class="sxs-lookup"><span data-stu-id="b3dec-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="b3dec-105">Dit is lastig omdat elke meting van een Quantum systeem Maxi maal één stukje informatie oplevert.</span><span class="sxs-lookup"><span data-stu-id="b3dec-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="b3dec-106">Als u een eigenvalue wilt leren, kunt u alleen een Quantum status, de resultaten van een groot aantal metingen samen voegen, zodat de gebruiker de vele informatie die nodig is om deze concepten weer te geven, kan beschikken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="b3dec-107">De Quantum statussen zijn vooral complexe omdat de [theorema geen](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) enkele manier is om een wille keurige Quantum status te leren kennen uit één exemplaar van de status, omdat u hierdoor kopieën van de status kunt maken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="b3dec-108">Deze afspiegeling van de Quantum status van de gebruiker wordt weer gegeven in het feit dat Q# niet duidelijk is of zelfs definieert wat een staat *is* voor Quantum Program ma's.</span><span class="sxs-lookup"><span data-stu-id="b3dec-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="b3dec-109">We gaan de Quantum karakte Rise ring ook behandelen door bewerkingen en Staten als Black Box uit te dienen. Deze benadering heeft veel gang bare aandelen met de experimentele praktijk van Quantum karakte Rise ring, verificatie en validatie (QCVV).</span><span class="sxs-lookup"><span data-stu-id="b3dec-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="b3dec-110">Karakte Rise ring is verschillend van de vele andere bibliotheken die eerder zijn besproken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="b3dec-111">Het doel is hier minder te weten te komen over de klassieke informatie over het systeem, in plaats van een unitary-trans formatie uit te voeren op een status vector.</span><span class="sxs-lookup"><span data-stu-id="b3dec-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="b3dec-112">Deze bibliotheken moeten daarom zowel de klassieke als de Quantum gegevens verwerking overvloeien.</span><span class="sxs-lookup"><span data-stu-id="b3dec-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="b3dec-113">Schatting van iteratieve fase</span><span class="sxs-lookup"><span data-stu-id="b3dec-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="b3dec-114">Het weer geven van Quantum-Program ma's in termen van de Quantum karakte Rise ring stelt een nuttig alternatief voor de Quantum-fase schatting voor.</span><span class="sxs-lookup"><span data-stu-id="b3dec-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="b3dec-115">Dat wil zeggen dat in plaats van een $n $-Qubit-REGI ster een binaire weer gave van de fase kan bevatten, zoals in de Quantum Phase-schatting, kunnen we de fase schatting bekijken als het proces waarmee een *klassieke* agent eigenschappen van een Quantum systeem via metingen leert.</span><span class="sxs-lookup"><span data-stu-id="b3dec-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="b3dec-116">We gaan in de Quantum case door gebruik te maken van Phase kickback om toepassingen van een Black Box-bewerking te scha kelen in draaiingen met een onbekende hoek, maar de ancilla Qubit te meten die we tijdens elke stap direct na de draaiing draaien.</span><span class="sxs-lookup"><span data-stu-id="b3dec-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="b3dec-117">Dit heeft het voor deel dat er slechts één extra Qubit is vereist voor het uitvoeren van de fase kickback die wordt beschreven in de Quantum case, aangezien we de fase van de meet resultaten tijdens elke stap op een iteratieve manier leren.</span><span class="sxs-lookup"><span data-stu-id="b3dec-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="b3dec-118">Elk van de hieronder voorgestelde methoden gebruikt een andere strategie voor het ontwerpen van experimenten en verschillende methoden voor gegevens verwerking om de fase te leren.</span><span class="sxs-lookup"><span data-stu-id="b3dec-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="b3dec-119">Ze hebben allemaal een uniek voor deel, variërend van het gebruik van strikte fout grenzen, de mogelijkheden voor het opnemen van eerdere informatie, het verdragen van fouten of het uitvoeren van geheugen limitted klassieke computers.</span><span class="sxs-lookup"><span data-stu-id="b3dec-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="b3dec-120">In het bespreken van iteratieve fase-schattingen wordt een unitary-$U $ gegeven als een Black-Box-bewerking.</span><span class="sxs-lookup"><span data-stu-id="b3dec-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="b3dec-121">Zoals beschreven in de sectie over Oracle in [gegevens structuren](xref:microsoft.quantum.libraries.data-structures), Q# modellen Canon dergelijke bewerkingen door het door de <xref:Microsoft.Quantum.Oracles.DiscreteOracle> gebruiker gedefinieerde type, gedefinieerd door het type tuple `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="b3dec-122">Als `U : DiscreteOracle` en vervolgens `U(m)` $U ^ m $ wordt geïmplementeerd voor `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="b3dec-123">Bij deze definitie wordt elke stap van een iteratieve fase schatting uitgevoerd door een hulp Qubit in de $ \ket{+} $-status voor te bereiden, samen met de aanvankelijke status $ \ket{\phi} $, wordt ervan uitgegaan dat er een [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) van $U is (m) $, dat wil zeggen $U (m) \ket{\phi} = e ^ {im\phi} \ Ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="b3dec-124">Vervolgens wordt een gecontroleerde toepassing van `U(m)` gebruikt, waarbij de status $ \left (R \_ 1 (m \phi) \ket{+} \right) \ket{\phi} $ wordt voor bereid.</span><span class="sxs-lookup"><span data-stu-id="b3dec-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="b3dec-125">Net als in het Quantum geval is het effect van een beheerde toepassing van de Oracle `U(m)` precies hetzelfde als het effect van het Toep assen van $R _1 $ voor de onbekende fase op $ \ket{+} $, zodat we de effecten van $U $ op deze eenvoudigere manier kunnen beschrijven.</span><span class="sxs-lookup"><span data-stu-id="b3dec-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="b3dec-126">Zo kunt u met het algoritme het besturings element Qubit draaien door $R _1 (-m\theta) $ toe te passen om een status te verkrijgen $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="b3dec-127">De hulp Qubit die wordt gebruikt als besturings element voor `U(m)` , wordt vervolgens in de $X $-basis gemeten om één klassiek te verkrijgen `Result` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="b3dec-128">Op dit moment is het opnieuw samen stellen van de fase van de `Result` waarden die zijn verkregen via iteratieve fase schatting een klassiek statistisch Afleidings probleem.</span><span class="sxs-lookup"><span data-stu-id="b3dec-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="b3dec-129">Het vinden van de waarde van $m $ waarmee de opgedane informatie wordt gemaximaliseerd op basis van een vaste methode voor het afwijzen van een afwijzen, is gewoon een probleem met statistieken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="b3dec-130">We benadrukken dit door een korte beschrijving te geven van de iteratieve fase schatting op theoretisch niveau in de Bayesiaanse para meter schatting formeelheid voordat u doorgaat met het beschrijven van de statistische algoritmen die zijn opgenomen in de Q# Canon voor het oplossen van dit probleem met de klassieke interferentie.</span><span class="sxs-lookup"><span data-stu-id="b3dec-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="b3dec-131">Schatting van iteratieve fase zonder Eigenstates</span><span class="sxs-lookup"><span data-stu-id="b3dec-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="b3dec-132">Als er een invoer status wordt opgegeven die geen eigenstate is, dat wil zeggen dat als $U (m) \ket{\phi \_ j} = e ^ {im\phi \_ j} $, het proces voor fase schatting niet-deterministisch de Quantum status naar een enkele energie-eigenstate omleidt.</span><span class="sxs-lookup"><span data-stu-id="b3dec-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="b3dec-133">De eigenstate waarmee deze uiteindelijk wordt geconvergeerd, is de eigenstate die het meest waarschijnlijk is om de waargenomen te produceren `Result` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="b3dec-134">In het bijzonder voert één stap van PE de volgende niet-unitary-trans formatie uit voor een status \begin{align} \ sum_j \sqrt{\Pr (\phi \_ j)} \ket{\phi \_ j} \mapsto \sum \_ j\frac {\ SQRT {\ PR (\phi \_ j)} \sqrt{\Pr (\Text{result} | \phi \_ j)} \Ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j)} \_ \_ }.</span><span class="sxs-lookup"><span data-stu-id="b3dec-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_k \Pr(\text{Result}|\phi\_k)}}.</span></span>
<span data-ttu-id="b3dec-135">\end{align} omdat dit proces wordt herhaald over meerdere `Result` waarden, wordt eigenstates die geen maximale waarden hebben van $ \ prod_k \pr (\Text{result} \_ k | \phi \_ j) $ exponentieel onderdrukt.</span><span class="sxs-lookup"><span data-stu-id="b3dec-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="b3dec-136">Als gevolg hiervan wordt het debehandelings proces meestal geconvergeerd aan statussen met één eigenvalue als de experimenten goed worden gekozen.</span><span class="sxs-lookup"><span data-stu-id="b3dec-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="b3dec-137">Bayes ' theorema heeft verder gesuggereerd dat de status van de fase schatting wordt geschreven in de vorm \begin{align} \frac{\sqrt{\Pr (\phi \_ j)} \sqrt{\Pr (\Text{result} | \phi \_ j)} \ket{\phi \_ j}} {\sqrt{\Pr (\phi \_ j) \Sum \_ j \Pr (\Text{result} | \phi \_ j)}} = \ sum_j \sqrt{\Pr (\phi \_ j | \Text{result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="b3dec-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="b3dec-138">\end{align} hier $ \Pr (\phi \_ j | \Text{result}) $ kan interpretted zijn als de kans dat één zou toegeven aan elke hypo these over de eigenstates gegeven:</span><span class="sxs-lookup"><span data-stu-id="b3dec-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="b3dec-139">kennis van de Quantum status voordat deze wordt gemeten;</span><span class="sxs-lookup"><span data-stu-id="b3dec-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="b3dec-140">kennis van de eigenstates van $U $ en,</span><span class="sxs-lookup"><span data-stu-id="b3dec-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="b3dec-141">kennis van de eigenvalues van $U $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="b3dec-142">Het leren van deze drie dingen is vaak exponentieel hard op een klassieke computer.</span><span class="sxs-lookup"><span data-stu-id="b3dec-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="b3dec-143">Het hulp programma voor de fase schatting treedt, in geen enkele mate, van het feit dat het een dergelijke Quantum lerende taak kan uitvoeren zonder dat ze daar kennis van hebben.</span><span class="sxs-lookup"><span data-stu-id="b3dec-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="b3dec-144">De fase-schatting voor deze reden wordt weer gegeven in een aantal Quantum algoritmen die exponentiële speedups bieden.</span><span class="sxs-lookup"><span data-stu-id="b3dec-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="b3dec-145">Schatting van de Bayesiaanse-fase</span><span class="sxs-lookup"><span data-stu-id="b3dec-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="b3dec-146">Zie het [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) -voor beeld voor meer informatie over de Bayesiaanse-fase schatting in de praktijk.</span><span class="sxs-lookup"><span data-stu-id="b3dec-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="b3dec-147">Het idee van een schatting van de Bayesiaanse-fase is eenvoudig.</span><span class="sxs-lookup"><span data-stu-id="b3dec-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="b3dec-148">U verzamelt meting statistieken vanuit het fase-schattings protocol en vervolgens verwerkt u de resultaten met behulp van Bayesiaanse deinterferentie en geeft u een schatting van de para meter op.</span><span class="sxs-lookup"><span data-stu-id="b3dec-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="b3dec-149">Deze verwerking geeft u een schatting van de eigenvalue en de onzekerheid in die schatting.</span><span class="sxs-lookup"><span data-stu-id="b3dec-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="b3dec-150">U kunt hiermee ook adaptieve experimenten uitvoeren en eerdere gegevens gebruiken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="b3dec-151">Het nadeel van de methoden is dat deze reken kracht zwaarder wordt.</span><span class="sxs-lookup"><span data-stu-id="b3dec-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="b3dec-152">Als u wilt weten hoe dit Bayesiaanse wordt gebruikt, kunt u het beste een enkel resultaat verwerken `Zero` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="b3dec-153">Houd er rekening mee dat $X = \ket{+} \bra{+}-\ket {-} \bra {-} $, zodanig dat $ \ket{+} $ de enige positieve eigenstate is van $X $ die overeenkomt met `Zero` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="b3dec-154">De kans dat wordt geobserveerd `Zero` voor een [ `PauliX` meting](xref:microsoft.quantum.concepts.pauli) op de eerste Qubit op basis van een invoer status $ \Ket{\psi}\ket{\phi} $ is \begin{Equation} \Pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="b3dec-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="b3dec-155">\end{equation} in het geval van een iteratie fase-schatting hebben we dat $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, dat wil zeggen \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: fase-est-kans}.</span><span class="sxs-lookup"><span data-stu-id="b3dec-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="b3dec-156">\end{align} dat wil zeggen de schatting van de iteratie fase bestaat uit het leren van de trillings frequentie van een sinusoidal-functie, gezien de mogelijkheid om een munt te spie gelen met een afwijking van die sinusoid.</span><span class="sxs-lookup"><span data-stu-id="b3dec-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="b3dec-157">De volgende traditionele klassieke terminologie noemen we $ \eqref{EQ: phase-est-kans.} $ de *waarschijnlijke functie* voor schatting van iteratieve fase.</span><span class="sxs-lookup"><span data-stu-id="b3dec-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="b3dec-158">Gezien een `Result` van de waarschijnlijke functie van de iteratieve fase schatting, kunnen we Bayes-regel gebruiken om te bepalen wat de fase ervan moet zijn om deze waarneming te volgen.</span><span class="sxs-lookup"><span data-stu-id="b3dec-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="b3dec-159">Betonief, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} waarbij $d \in \\ {\texttt{Zero}, \texttt{One} \\ } $ is een `Result` , en waarbij $ \Pr (\phi) $ de eerdere opvattingen over $ \phi $ beschrijft.</span><span class="sxs-lookup"><span data-stu-id="b3dec-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="b3dec-160">Vervolgens wordt de herhaalde aard van de iteratieve fase-schatting expliciet gemaakt, omdat de posterior-distributie $ \Pr (\phi | d) $ onze opvattingen onmiddellijk voorafgaat aan de waarneming van de volgende `Result` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="b3dec-161">Op elk gewenst moment tijdens deze procedure kunnen we de fase $ \hat{\phi} $, zoals \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \Text{data}] = \int \phi \Pr (\phi | \Text{data}) {\mathrm d} \phi, \end{Equation}, waarbij $ \Text{data} $ staat voor de gehele record van alle `Result` verkregen waarden rapporteren.</span><span class="sxs-lookup"><span data-stu-id="b3dec-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="b3dec-162">De exacte Bayesiaanse-deinterferentie is in de praktijk onbepaald.</span><span class="sxs-lookup"><span data-stu-id="b3dec-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="b3dec-163">Om dit voor stel te zien, willen we een $n $-bit-variabele $x $ leren.</span><span class="sxs-lookup"><span data-stu-id="b3dec-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="b3dec-164">De vorige distributie $ \Pr (x) $ heeft ondersteuning voor meer dan $2 ^ n $ hypothetische waarden van $x $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="b3dec-165">Dit betekent dat als er een zeer nauw keurige schatting van $x $, de schatting van de Bayesiaanse-fase mogelijk een verboden geheugen en verwerkings tijd nodig heeft.</span><span class="sxs-lookup"><span data-stu-id="b3dec-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="b3dec-166">Hoewel voor sommige toepassingen, zoals Quantum simulatie, de nauw keurigheid van de limitted niet van toepassing is op andere toepassingen, zoals het algoritme van Shor, kunt u geen gebruik maken van de exacte Bayesiaanse-afleiding binnen de fase-schattings stap.</span><span class="sxs-lookup"><span data-stu-id="b3dec-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="b3dec-167">Daarom bieden we ook implementaties voor het benaderen van Bayesiaanse-methoden, zoals een [wille keurige Walkie fase schatting (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) en ook niet-Bayesiaanse benaderingen zoals een [robuuste fase schatting](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="b3dec-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="b3dec-168">Robuuste fase schatting</span><span class="sxs-lookup"><span data-stu-id="b3dec-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="b3dec-169">Een Bayesiaanse-reconstructie van een fase in het ergste geval is een periode van een schatting van *het aantal meet* resultaten.</span><span class="sxs-lookup"><span data-stu-id="b3dec-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="b3dec-170">De meeste praktische schattings algoritmen nemen voor de reconstructie enige kwaliteit mee in de wederopbouw, in ruil voor een hoeveelheid klassieke naverwerking die in plaats daarvan met het aantal gemaakte metingen wordt geschaald.</span><span class="sxs-lookup"><span data-stu-id="b3dec-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="b3dec-171">Een voor beeld van een efficiënte, klassieke, verwerkings stap is het algoritme voor het schatten van de [robuuste fase](https://arxiv.org/abs/1502.02677), met de hand tekening en de invoer hierboven beschreven.</span><span class="sxs-lookup"><span data-stu-id="b3dec-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="b3dec-172">Hierbij wordt ervan uitgegaan dat de invoer unitary Black-vakken $U $ worden verpakt als `DiscreteOracle` type en daarom alleen query's op gehele getallen van het bestuurd-$U $ worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="b3dec-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="b3dec-173">Als de invoer status in het `Qubit[]` REGI ster een eigenstate is $U \ket{\psi} = e ^ {i\phi} \ Ket {\ psi} $, retourneert het inschattings algoritme voor de robuuste fase een schatting $ \hat{\phi}\in [-\pi, \pi) $ van $ \phi $ as a `Double` .</span><span class="sxs-lookup"><span data-stu-id="b3dec-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="b3dec-174">De belangrijkste functie van een robuuste fase schatting, die wordt gedeeld met de meeste andere nuttige varianten, is dat de reconstructie kwaliteit van $ \hat{\phi} $ in een bepaalde zin Heisenberg-Limited is.</span><span class="sxs-lookup"><span data-stu-id="b3dec-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="b3dec-175">Dit betekent dat als de afwijking van $ \hat{\phi} $ van de werkelijke waarde $ \sigma $ is, $ \sigma $ inversisch wordt geschaald in verhouding tot het totale aantal query's $Q $ is gemaakt naar Controlled-$U $, d.w.z. $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="b3dec-176">Nu is de definitie van afwijking afhankelijk van verschillende schattings algoritmen.</span><span class="sxs-lookup"><span data-stu-id="b3dec-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="b3dec-177">In sommige gevallen kan het betekenen dat er ten minste $ \mathcal{O} (1) $ waarschijnlijk is, de schattings fout $ | \hat{\phi}-\phi | \_ \circ\le \sigma $ op een van de ronde maat eenheden $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="b3dec-178">Voor een stabiele fase schatting is de afwijking gelijk aan de variantie $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\mod \_ {2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $ als de periodieke fasen worden uitgepakt op een enkel eindig interval $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="b3dec-179">Nauw keuriger is de standaard afwijking in de robuuste fase schatting van de ongelijke waarde $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ Pi/Q, \end{align} $ $, waarbij de ondergrens wordt bereikt in de grens van asymptot large $Q $, en de bovengrens gegarandeerd zelfs voor kleine steek proeven.</span><span class="sxs-lookup"><span data-stu-id="b3dec-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="b3dec-180">Houd er rekening mee dat $n $ geselecteerd door de `bitsPrecision` invoer, die impliciet $Q $ definieert.</span><span class="sxs-lookup"><span data-stu-id="b3dec-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="b3dec-181">Andere relevante gegevens zijn onder meer de geringe overhead van $1 $ ancilla Qubit, of de procedure is niet-adaptief, wat inhoudt dat de vereiste reeks Quantum experimenten onafhankelijk is van de tussenliggende meet resultaten.</span><span class="sxs-lookup"><span data-stu-id="b3dec-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="b3dec-182">In deze en komende voor beelden, waarbij de keuze van het algoritme voor fase schatting belang rijk is, moet één van beide verwijzen naar de documentatie, zoals @"microsoft.quantum.characterization.robustphaseestimation" en de publicaties waarnaar wordt verwezen, voor meer informatie en voor de implementatie ervan.</span><span class="sxs-lookup"><span data-stu-id="b3dec-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="b3dec-183">Er zijn veel voor beelden van het gebruik van robuuste fase schatting.</span><span class="sxs-lookup"><span data-stu-id="b3dec-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="b3dec-184">Zie het [ **simulatie** voorbeeld](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), het [ **SimpleIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)-voor beeld en het [ **Hubbard model**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard)-voor beeld, voor een schatting van de fase bij het extra heren van de grond energie van het verschillende fysieke systeem.</span><span class="sxs-lookup"><span data-stu-id="b3dec-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="b3dec-185">Continue Oracle</span><span class="sxs-lookup"><span data-stu-id="b3dec-185">Continuous Oracles</span></span> ###

<span data-ttu-id="b3dec-186">We kunnen ook generaliseren vanuit het Oracle-model dat hierboven wordt gebruikt om te zorgen voor continue time-Oracle, gemodelleerd door het type Canon <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="b3dec-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="b3dec-187">Houd er rekening mee dat in plaats van één unitary-operator $U $ een familie van unitary-Opera tors $U (t) $ voor $t \in \mathbb{R} $, $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="b3dec-188">Dit is een zwakkere instructie dan in de afzonderlijke situatie, omdat we een kunnen maken <xref:Microsoft.Quantum.Oracles.DiscreteOracle> door $t = m \, \delta t $ te beperken voor sommige vaste $ \delta t $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="b3dec-189">De [theorema van stenen](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ voor een bepaalde operator $H $, waarbij $ \exp $ de matrix exponentiële is, zoals beschreven in [Geavanceerde matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="b3dec-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="b3dec-190">Een eigenstate $ \ket{\phi} $ van $H $ zodanig dat $H \ket{\phi} = \phi \ket{\phi} $ is dan ook een eigenstate van $U (t) $ voor alle $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="b3dec-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="b3dec-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="b3dec-191">\end{equation}</span></span>

<span data-ttu-id="b3dec-192">De nauw keurige analyse die wordt besproken voor de schatting van de [Bayesiaanse-fase](#bayesian-phase-estimation) kan worden toegepast. de waarschijnlijke functie is precies hetzelfde als voor dit algemenere Oracle-model: $ $ \Pr (\texttt{Zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="b3dec-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="b3dec-193">$ $ Bovendien, als $U $ een simulatie is van een dynamische generator, zoals het geval is voor [Hamiltonian-simulatie](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), interpreteert $ \phi $ als energie.</span><span class="sxs-lookup"><span data-stu-id="b3dec-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="b3dec-194">Met het gebruik van een fase-schatting met doorlopende query's kunnen we het gesimuleerde [Energy-spectrum van moleculen](https://arxiv.org/abs/quant-ph/0604193), [materialen](https://arxiv.org/abs/1510.03859) of [veld theoriesen](https://arxiv.org/abs/1111.3633v2) , zonder dat we de keuze van experimenten moeten doen, omdat $t $ een geheel getal moet zijn.</span><span class="sxs-lookup"><span data-stu-id="b3dec-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="b3dec-195">Schatting wille keurige Walkie fase</span><span class="sxs-lookup"><span data-stu-id="b3dec-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="b3dec-196">Q# voorziet in een handige benadering van de schatting van de Bayesiaanse-fase die is ontworpen voor het gebruik van close-to-Quantum apparaten.</span><span class="sxs-lookup"><span data-stu-id="b3dec-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="b3dec-197">Deze methode is zowel adaptief als volledig deterministisch, waardoor bijna optimaal kan worden geschaald in de geschatte fase $ \hat{\phi} $ met weinig geheugen overhead.</span><span class="sxs-lookup"><span data-stu-id="b3dec-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="b3dec-198">In het protocol wordt gebruikgemaakt van een geschatte methode voor het afwijzen van Bayesiaanse die ervan uitgaat dat de eerdere distributie Gaussiaans is.</span><span class="sxs-lookup"><span data-stu-id="b3dec-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="b3dec-199">Met deze Gaussiaanse veronderstelling kunnen we een analytische formule voor het experiment gebruiken waarmee de posterior variantie wordt geminimaliseerd.</span><span class="sxs-lookup"><span data-stu-id="b3dec-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="b3dec-200">Op basis van het resultaat van het experiment, verschuift de schatting van $ \phi $ naar links of rechts met een vooraf bepaalde hoeveelheid en wordt de afwijking met een vooraf bepaalde hoeveelheid verkleind.</span><span class="sxs-lookup"><span data-stu-id="b3dec-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="b3dec-201">Dit gemiddelde en deze afwijking geven alle informatie die nodig is voor het opgeven van een Gaussiaans vóór $ \phi $ voor het volgende experiment.</span><span class="sxs-lookup"><span data-stu-id="b3dec-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="b3dec-202">Onverwachte metings fouten of het resultaat van de werkelijke waarde is de staart van de eerste, kan ervoor zorgen dat deze methode mislukt.</span><span class="sxs-lookup"><span data-stu-id="b3dec-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="b3dec-203">Er wordt van uitgegaan van een fout door experimenten uit te voeren om te testen of het huidige gemiddelde en de standaard afwijking geschikt zijn voor het systeem.</span><span class="sxs-lookup"><span data-stu-id="b3dec-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="b3dec-204">Als dat niet het geval is, voert het algoritme een omgekeerde stap van de Walk uit en wordt het proces voortgezet.</span><span class="sxs-lookup"><span data-stu-id="b3dec-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="b3dec-205">Met de mogelijkheid om achterwaarts op te stappen, kan de algoritme ook worden achterhaald, zelfs als de initiële voor gaande standaard afwijking inapropriately klein is.</span><span class="sxs-lookup"><span data-stu-id="b3dec-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="b3dec-206">Algoritmen voor fase schatting aanroepen</span><span class="sxs-lookup"><span data-stu-id="b3dec-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="b3dec-207">Elke fase-schattings bewerking die Q# is opgegeven met Canon, neemt een andere set invoer parameterizing de kwaliteit op die we nodig hebben voor de laatste schatting $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="b3dec-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="b3dec-208">Deze verschillende invoer, maar alle gemeen schappelijke invoer delen, zoals een gedeeltelijke toepassing die de kwaliteits parameters overschrijdt, resulteert in een algemene hand tekening.</span><span class="sxs-lookup"><span data-stu-id="b3dec-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="b3dec-209">De <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> bewerking die in de volgende sectie wordt besproken, heeft bijvoorbeeld de volgende hand tekening:</span><span class="sxs-lookup"><span data-stu-id="b3dec-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="b3dec-210">De `bitsPrecision` invoer is uniek voor `RobustPhaseEstimation` , maar `oracle` is `eigenstate` gebruikelijk.</span><span class="sxs-lookup"><span data-stu-id="b3dec-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="b3dec-211">Zo kan een bewerking, zoals gezien in **H2Sample**, een iteratieve fase schattings algoritme accepteren met een invoer van het formulier `(DiscreteOracle, Qubit[]) => Unit` zodat een gebruiker wille keurige fase schattings algoritmen kan opgeven:</span><span class="sxs-lookup"><span data-stu-id="b3dec-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="b3dec-212">Deze talloze fase schattings algoritmen zijn geoptimaliseerd voor verschillende eigenschappen en invoer parameters, die moeten worden begrepen om de beste keuze voor de doel toepassing te maken.</span><span class="sxs-lookup"><span data-stu-id="b3dec-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="b3dec-213">Zo zijn sommige fase schattings algoritmen adaptief, wat betekent dat toekomstige stappen klassiek worden beheerd door de meet resultaten van de vorige stappen.</span><span class="sxs-lookup"><span data-stu-id="b3dec-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="b3dec-214">In sommige gevallen is het de mogelijkheid om de exponentiate van de Black Box unitary Oracle door wille keurige echte bevoegdheden te laten opdoen, en andere hebben alleen geheeltallige bevoegdheden nodig, maar kunnen alleen een fase schatting modulo $2 \ Pi $ omzetten.</span><span class="sxs-lookup"><span data-stu-id="b3dec-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="b3dec-215">Er zijn veel hulp qubits vereist en anderen hebben er slechts één nodig.</span><span class="sxs-lookup"><span data-stu-id="b3dec-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="b3dec-216">Op dezelfde manier wordt de schatting van de wille keurige Walk-fase op ongeveer dezelfde wijze uitgevoerd als voor andere algoritmen die bij de Canon worden gebruikt:</span><span class="sxs-lookup"><span data-stu-id="b3dec-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
