---
title: Fout correctie in de Q# standaard bibliotheken
description: Meer informatie over het gebruik van fout correctie codes in uw Q# Program ma's terwijl u de status van de qubits beveiligt.
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: fc8e46aa22cb2575de42cfc3d4f57c43e5d3f7b0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857215"
---
# <a name="error-correction"></a><span data-ttu-id="c4a37-103">Fout correctie</span><span class="sxs-lookup"><span data-stu-id="c4a37-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="c4a37-104">Inleiding</span><span class="sxs-lookup"><span data-stu-id="c4a37-104">Introduction</span></span> ##

<span data-ttu-id="c4a37-105">Als er in klassieke computing een beetje op fouten wil beveiligen, kan het vaak voldoende zijn om die bit te vertegenwoordigen door een *logische bit* door de gegevensbits te herhalen.</span><span class="sxs-lookup"><span data-stu-id="c4a37-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="c4a37-106">Laat bijvoorbeeld $ \overline {0} = $0 de code ring van de gegevensbit 0 zijn, waarbij we de regel boven het label 0 gebruiken om aan te geven dat het een code ring van een bit in de status 0 is.</span><span class="sxs-lookup"><span data-stu-id="c4a37-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="c4a37-107">Als we net \overline {1} = $111 hebben, hebben we een eenvoudige herhalings code die kan worden beveiligd tegen een fout bij het spie gelen van een bit.</span><span class="sxs-lookup"><span data-stu-id="c4a37-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="c4a37-108">Als een van de drie bits is gespiegeld, kunnen we de status van de logische bit herstellen door een meerderheids stem te nemen.</span><span class="sxs-lookup"><span data-stu-id="c4a37-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="c4a37-109">Hoewel de klassieke fout correctie een veel rijker onderwerp is dat dit specifieke voor beeld wordt aangeraden, wordt de [inleidende](https://www.springer.com/us/book/9783540641339)code hierboven al verwezen naar een mogelijk probleem bij het beveiligen van Quantum gegevens.</span><span class="sxs-lookup"><span data-stu-id="c4a37-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="c4a37-110">Het [no-klonen van theorema](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) impliceert dat als we elke afzonderlijke Qubit meten en een meerderheids stem hebben ondergaand op basis van de hierboven vermelde code, de nauw keurige informatie die we proberen te beveiligen, verloren is gegaan.</span><span class="sxs-lookup"><span data-stu-id="c4a37-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="c4a37-111">In de Quantum instelling zien we dat de meting problemen heeft.</span><span class="sxs-lookup"><span data-stu-id="c4a37-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="c4a37-112">De bovenstaande code ring kan nog steeds worden geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="c4a37-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="c4a37-113">Het is handig om dit te doen om te zien hoe de fout correctie voor de Quantum case kan worden gegeneraliseerd.</span><span class="sxs-lookup"><span data-stu-id="c4a37-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="c4a37-114">Laat dus $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket \otimes {0} \ket {0} $, en laat $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="c4a37-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="c4a37-115">Op basis van lineariteit hebben we de herhalings code voor alle invoer gedefinieerd. bijvoorbeeld: $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="c4a37-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="c4a37-116">In het bijzonder wordt een bit-Flip-fout $X _1 $ Act op de middelste Qubit. we zien dat de correctie die nodig is voor beide vertakkingen exact $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="c4a37-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="c4a37-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="c4a37-117">\end{align} $$</span></span>

<span data-ttu-id="c4a37-118">Om te zien hoe we kunnen vaststellen dat dit het geval is, zonder dat u de enige status die we proberen te bemeten, is het handig om te schrijven wat elke andere bit voor het spie gelen van fouten aan de logische status heeft:</span><span class="sxs-lookup"><span data-stu-id="c4a37-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="c4a37-119">Fout $E $</span><span class="sxs-lookup"><span data-stu-id="c4a37-119">Error $E$</span></span> | <span data-ttu-id="c4a37-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="c4a37-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="c4a37-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="c4a37-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c4a37-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="c4a37-122">$\boldone$</span></span> | <span data-ttu-id="c4a37-123">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-123">$\ket{000}$</span></span> | <span data-ttu-id="c4a37-124">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-124">$\ket{111}$</span></span> |
| <span data-ttu-id="c4a37-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-125">$X_0$</span></span> | <span data-ttu-id="c4a37-126">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-126">$\ket{100}$</span></span> | <span data-ttu-id="c4a37-127">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-127">$\ket{011}$</span></span> |
| <span data-ttu-id="c4a37-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-128">$X_1$</span></span> | <span data-ttu-id="c4a37-129">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-129">$\ket{010}$</span></span> | <span data-ttu-id="c4a37-130">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-130">$\ket{101}$</span></span> |
| <span data-ttu-id="c4a37-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-131">$X_2$</span></span> | <span data-ttu-id="c4a37-132">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-132">$\ket{001}$</span></span> | <span data-ttu-id="c4a37-133">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-133">$\ket{110}$</span></span> |

<span data-ttu-id="c4a37-134">Ter bescherming van de status die we coderen, moeten we de drie fouten van elkaar en uit de identiteit $ \boldone $ onderscheiden, zonder onderscheid te maken tussen $ \ket{\overline {0} } $ en $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="c4a37-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="c4a37-135">Als we bijvoorbeeld $Z _0 $ meten, krijgen we een ander resultaat voor $ \ket{\overline {0} } $ en $ \ket{\overline {1} } $ in het geval geen fout, waardoor de gecodeerde status wordt samengevouwen.</span><span class="sxs-lookup"><span data-stu-id="c4a37-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="c4a37-136">In het andere geval kunt u overwegen om $Z _0 Z_1 $ te meten, de pariteit van de eerste twee bits in elke reken status.</span><span class="sxs-lookup"><span data-stu-id="c4a37-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="c4a37-137">U kunt er ook voor zorgen dat elke meting van een Pauli-operator controleert welke eigenvalue de status wordt gemeten overeenkomt met, dus voor elke staat $ \ket{\psi} $ in de bovenstaande tabel, kunnen we $Z _0 Z_1 \ket{\psi} $ berekenen om te zien of $ \pm\ket{\psi} $ wordt ontvangen.</span><span class="sxs-lookup"><span data-stu-id="c4a37-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="c4a37-138">Houd er rekening mee dat $Z _0 Z_1 \ket {000} = \ket {000} $ en dat $Z _0 Z_1 \ket {111} = \ket {111} $, zodat we kunnen concluderen dat deze meting hetzelfde is voor beide gecodeerde statussen.</span><span class="sxs-lookup"><span data-stu-id="c4a37-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="c4a37-139">Daarentegen $Z _0 Z_1 \ket {100} =-\ket {100} $ en $Z _0 Z_1 \ket {011} =-\ket {011} $, zodat het resultaat van het meten van $Z _0 Z_1 $ nuttige informatie over welke fout is opgetreden.</span><span class="sxs-lookup"><span data-stu-id="c4a37-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="c4a37-140">Als u dit wilt benadrukken, herhaalt u de bovenstaande tabel, maar voegt u de resultaten van meting $Z _0 Z_1 $ en $Z _1 Z_2 $ toe aan elke rij.</span><span class="sxs-lookup"><span data-stu-id="c4a37-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="c4a37-141">De resultaten van elke meting worden aangegeven door het teken van de eigenvalue die wordt waargenomen, ofwel $ + $ of $-$, die overeenkomt met de Q# `Result` waarden van `Zero` en `One` .</span><span class="sxs-lookup"><span data-stu-id="c4a37-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="c4a37-142">Fout $E $</span><span class="sxs-lookup"><span data-stu-id="c4a37-142">Error $E$</span></span> | <span data-ttu-id="c4a37-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="c4a37-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="c4a37-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="c4a37-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="c4a37-145">Resultaat van $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="c4a37-146">Resultaat van $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="c4a37-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="c4a37-147">$\boldone$</span></span> | <span data-ttu-id="c4a37-148">$ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-148">$\ket{000}$</span></span> | <span data-ttu-id="c4a37-149">$ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="c4a37-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-150">$X_0$</span></span> | <span data-ttu-id="c4a37-151">$ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-151">$\ket{100}$</span></span> | <span data-ttu-id="c4a37-152">$ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="c4a37-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-153">$X_1$</span></span> | <span data-ttu-id="c4a37-154">$ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-154">$\ket{010}$</span></span> | <span data-ttu-id="c4a37-155">$ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="c4a37-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="c4a37-156">$X_2$</span></span> | <span data-ttu-id="c4a37-157">$ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-157">$\ket{001}$</span></span> | <span data-ttu-id="c4a37-158">$ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="c4a37-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="c4a37-159">De resultaten van de twee metingen bepalen daarom op unieke wijze welke bit-Flip-fout is opgetreden, maar zonder dat er informatie wordt onthuld over welke status er is gecodeerd.</span><span class="sxs-lookup"><span data-stu-id="c4a37-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="c4a37-160">We noemen deze resultaten een *Syndrome* en verwijzen naar het proces van het toewijzen van een Syndrome terug naar de fout die de *bewerking* heeft veroorzaakt.</span><span class="sxs-lookup"><span data-stu-id="c4a37-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="c4a37-161">In het bijzonder benadrukken we dat herstel een *klassieke* methode voor het afwijzen van de interferentie is, waarbij de Syndrome wordt ingevoerd, en er een recept wordt geretourneerd voor het oplossen van eventuele fouten die zich hebben voorgedaan.</span><span class="sxs-lookup"><span data-stu-id="c4a37-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="c4a37-162">De bit-Flip code hierboven kan alleen worden gecorrigeerd ten opzichte van enkele bits-Flip-fouten; dat wil zeggen, een `X` bewerking die fungeert als een enkele Qubit.</span><span class="sxs-lookup"><span data-stu-id="c4a37-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="c4a37-163">`X`Als u wilt Toep assen op meer dan één Qubit, wordt $ \ket{\overline {0} } $ toegewezen aan $ \ket{\overline {1} } $ na herstel.</span><span class="sxs-lookup"><span data-stu-id="c4a37-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="c4a37-164">Op dezelfde manier wordt met het Toep assen van een fase Flip `Z` -bewerking $ \ket{\overline {1} } $ aan $-\ket{\overline {1} } $ toegewezen en wordt dus $ \ket{\overline{+}} $ toegewezen aan $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="c4a37-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="c4a37-165">Meer in het algemeen kunnen codes worden gemaakt voor het verwerken van een groter aantal fouten en voor het afhandelen van $Z $-fouten, evenals $X $-fouten.</span><span class="sxs-lookup"><span data-stu-id="c4a37-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="c4a37-166">Het inzicht dat we meten in een Quantum fout correctie die op dezelfde manier op alle code Staten reageert, is de essentie van de *stabilisatie formaliteit*.</span><span class="sxs-lookup"><span data-stu-id="c4a37-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="c4a37-167">De Q# Canon biedt een framework voor het beschrijven van code ring en het decoderen van stabilisatoren codes en voor het beschrijven van het herstel van fouten.</span><span class="sxs-lookup"><span data-stu-id="c4a37-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="c4a37-168">In deze sectie beschrijven we dit kader en de toepassing ervan tot een paar eenvoudige Quantum fout codes.</span><span class="sxs-lookup"><span data-stu-id="c4a37-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="c4a37-169">Een volledige inleiding tot de stabilisatie formaliteit valt buiten het bereik van deze sectie.</span><span class="sxs-lookup"><span data-stu-id="c4a37-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="c4a37-170">We verwijzen naar lezers die meer willen weten over [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="c4a37-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="c4a37-171">Duidt op fouten corrigerende codes in Q#</span><span class="sxs-lookup"><span data-stu-id="c4a37-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="c4a37-172">Om u te helpen bij het opgeven van fout codes voor het corrigeren van fouten, Q# biedt Canon verschillende afzonderlijke door de gebruiker gedefinieerde typen:</span><span class="sxs-lookup"><span data-stu-id="c4a37-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="c4a37-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Hiermee wordt aangegeven dat een REGI ster van qubits moet worden geïnterpreteerd als het code blok van een fout code.</span><span class="sxs-lookup"><span data-stu-id="c4a37-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="c4a37-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Hiermee wordt aangegeven dat een matrix met meet resultaten moet worden geïnterpreteerd als de Syndrome die op een code blok wordt gemeten.</span><span class="sxs-lookup"><span data-stu-id="c4a37-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="c4a37-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Hiermee wordt aangegeven dat een *klassieke* functie moet worden gebruikt om een Syndrome te interpreteren en een correctie te retour neren die moet worden toegepast.</span><span class="sxs-lookup"><span data-stu-id="c4a37-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="c4a37-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>: Hiermee wordt aangegeven `= ((Qubit[], Qubit[]) => LogicalRegister)` dat bij een bewerking qubits gegevens worden weer gegeven samen met een nieuwe ancilla-qubits om een code blok te maken van een fout code.</span><span class="sxs-lookup"><span data-stu-id="c4a37-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="c4a37-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Hiermee wordt een code blok van een fout bij het corrigeren van code in de gegevens qubits en het ancilla-qubits gebruikt om Syndrome-informatie weer te geven.</span><span class="sxs-lookup"><span data-stu-id="c4a37-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="c4a37-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Hiermee wordt een bewerking aangegeven die moet worden gebruikt voor het extra heren van Syndrome-informatie uit een code blok zonder dat de status wordt verstoord die wordt beveiligd door de code.</span><span class="sxs-lookup"><span data-stu-id="c4a37-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="c4a37-179">Ten slotte biedt Canon het <xref:Microsoft.Quantum.ErrorCorrection.QECC> type voor het verzamelen van de andere typen die vereist zijn voor het definiëren van een Quantum fout-juiste code.</span><span class="sxs-lookup"><span data-stu-id="c4a37-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="c4a37-180">Voor elke stabilisatore Quantum code is de lengte van de code $n $, het aantal $k $ logische qubits en de minimale afstand $d $, vaak gezamenlijk gegroepeerd in de notatie ⟦ $n $, $k $ $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="c4a37-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="c4a37-181">De <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> functie definieert bijvoorbeeld de ⟦ 3, 1, 1 ⟧ bits code voor spie gelen:</span><span class="sxs-lookup"><span data-stu-id="c4a37-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="c4a37-182">U ziet dat het `QECC` type *geen* herstel functie bevat.</span><span class="sxs-lookup"><span data-stu-id="c4a37-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="c4a37-183">Hierdoor kunnen we de herstel functie wijzigen die wordt gebruikt bij het corrigeren van fouten zonder de definitie van de code zelf te wijzigen. deze mogelijkheid is vooral nuttig bij het opnemen van feedback van karakte maten in het model dat wordt gebruikt door herstel.</span><span class="sxs-lookup"><span data-stu-id="c4a37-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="c4a37-184">Zodra een code op deze manier is gedefinieerd, kunnen we de <xref:Microsoft.Quantum.ErrorCorrection.Recover> bewerking gebruiken om fouten op te lossen:</span><span class="sxs-lookup"><span data-stu-id="c4a37-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="c4a37-185">We verkennen dit gedetailleerder in het bits-voor beeld voor het [spie gelen van code](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="c4a37-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="c4a37-186">Naast de code voor het spie gelen van bits, Q# wordt de Canon voorzien van implementaties van de [Qubit perfecte code](https://arxiv.org/abs/quant-ph/9602019)en de [zeven Qubit-code](https://arxiv.org/abs/quant-ph/9705052), die beide een wille keurige, single-Qubit fout kan corrigeren.</span><span class="sxs-lookup"><span data-stu-id="c4a37-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
