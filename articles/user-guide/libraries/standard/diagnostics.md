---
title: Diagnostische gegevens in de Q# standaard bibliotheken
description: Meer informatie over de diagnostische functies en bewerkingen in de Q# standaard bibliotheken die worden gebruikt om fouten of fouten in Quantum Programma's te ondervangen.
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: d13122187a24893d297cfdbb3ad4db03eb22ded0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 01/26/2021
ms.locfileid: "98858682"
---
# <a name="diagnostics"></a><span data-ttu-id="dfdd4-103">Diagnostiek</span><span class="sxs-lookup"><span data-stu-id="dfdd4-103">Diagnostics</span></span> #

<span data-ttu-id="dfdd4-104">Net als bij de klassieke ontwikkeling is het belang rijk om fouten en fouten in Quantum Program ma's te kunnen onderzoeken.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="dfdd4-105">De Q# standaard bibliotheken bieden verschillende manieren om de juistheid van Quantum Program ma's, zoals beschreven in, te garanderen <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="dfdd4-106">In het algemeen is deze ondersteuning beschikbaar in de vorm van functies en bewerkingen waarmee de doel computer aanvullende diagnostische gegevens kan leveren aan het hostprogramma of de ontwikkelaar, of die de juistheid van voor waarden en varianten afdwingt, uitgedrukt door de functie of de bewerkings aanroep.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="dfdd4-107">Machine diagnostiek</span><span class="sxs-lookup"><span data-stu-id="dfdd4-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="dfdd4-108">Diagnostische gegevens over klassieke waarden kunnen worden verkregen met behulp van de <xref:Microsoft.Quantum.Intrinsic.Message> functie om een bericht op een computer afhankelijke manier te registreren.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="dfdd4-109">Standaard schrijft de teken reeks naar de-console.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="dfdd4-110">Wordt gebruikt in combi natie met geïnterpoleerde teken reeksen en <xref:Microsoft.Quantum.Intrinsic.Message> maakt het eenvoudig om diagnostische gegevens over klassieke waarden te rapporteren:</span><span class="sxs-lookup"><span data-stu-id="dfdd4-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```qsharp
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="dfdd4-111">`Message` een hand tekening heeft `(String -> Unit)` die opnieuw aangeeft dat een logboek bestand voor fout opsporing niet in acht kan worden genomen Q# .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="dfdd4-112">De <xref:Microsoft.Quantum.Diagnostics.DumpMachine> en <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instrueren doel machines om diagnostische gegevens te verstrekken over alle momenteel toegewezen qubits of over een specifiek REGI ster van qubits.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="dfdd4-113">Elke doel computer is afhankelijk van de diagnostische gegevens die worden verstrekt in reactie op een dump instructie.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="dfdd4-114">De [Fully](xref:microsoft.quantum.machines.full-state-simulator) machine-doel computer, bijvoorbeeld, levert het hostprogramma met de status vector die intern wordt gebruikt om een REGI ster van qubits te vertegenwoordigen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="dfdd4-115">Ter vergelijking: de doel computer van de [Toffoli Simulator](xref:microsoft.quantum.machines.toffoli-simulator) biedt één klassieke bit voor elke qubit.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="dfdd4-116">[](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` Zie de sectie dump functies van het [artikel testen en fout opsporing](xref:microsoft.quantum.guide.testingdebugging#dump-functions)voor meer informatie over de volledige uitvoer van de status van de Simulator.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="dfdd4-117">Feiten en verklaringen</span><span class="sxs-lookup"><span data-stu-id="dfdd4-117">Facts and Assertions</span></span> ##

<span data-ttu-id="dfdd4-118">Zoals beschreven in [testen en fout opsporing](xref:microsoft.quantum.guide.testingdebugging), een functie of bewerking met hand tekening `Unit -> Unit` of `Unit => Unit` respectievelijk kan worden gemarkeerd als een *eenheids test*.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test*.</span></span>
<span data-ttu-id="dfdd4-119">Elke eenheids test bestaat doorgaans uit een klein Quantum programma, samen met een of meer voor waarden die de juistheid van het programma controleren.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="dfdd4-120">Deze voor waarden kunnen worden opgenomen in de vorm van _feiten_, die de waarden van hun invoer (of _beweringen_) controleren, die de statussen controleren van een of meer qubits die worden door gegeven als invoer.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-120">These conditions can come in the form of either _facts_, which check the values of their inputs, or _assertions_, which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="dfdd4-121">`EqualityFactI(1 + 1, 2, "1 + 1 != 2")`Geeft bijvoorbeeld het mathematische feit weer dat $1 + 1 = $2, terwijl `AssertQubit(One, qubit)` de voor waarde vertegenwoordigt die het meten `qubit` `One` van een met zekerheid retourneert.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="dfdd4-122">In het eerste geval kunnen we controleren of de voor waarde juist is gegeven, maar in de laatste gevallen moeten we iets weten over de status van de Qubit om de bewering te kunnen evalueren.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="dfdd4-123">De Q# standaard bibliotheken bieden verschillende functies voor het weer geven van feiten, waaronder:</span><span class="sxs-lookup"><span data-stu-id="dfdd4-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="dfdd4-124">Qubit-statussen testen</span><span class="sxs-lookup"><span data-stu-id="dfdd4-124">Testing Qubit States</span></span> ###

<span data-ttu-id="dfdd4-125">In de praktijk zijn de beweringen afhankelijk van het feit dat klassieke simulaties van Quantum-garages de [theorema zonder klonen](https://arxiv.org/abs/quant-ph/9607018)niet hoeven te volgen, zodat we fysieke metingen en beweringen kunnen maken wanneer ze een simulator voor onze doel computer gebruiken.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="dfdd4-126">Daarom kunnen we afzonderlijke bewerkingen op een klassieke Simulator testen voordat ze op hardware worden geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="dfdd4-127">Op doel computers die geen bevestigingen kunnen evalueren, kunnen aanroepen naar <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> veilig worden genegeerd.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="dfdd4-128">Meer in het algemeen is de <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> bewerkings verklaring dat de opgegeven qubits in de gegeven Pauli gebaseerd altijd het gegeven resultaat heeft.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="dfdd4-129">Als de verklaring mislukt, wordt de uitvoering beëindigd door aan te roepen `fail` met het opgegeven bericht.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="dfdd4-130">Deze bewerking is standaard niet geïmplementeerd. Simulatoren die IT kunnen ondersteunen, moeten een implementatie bieden die runtime-controle uitvoert.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="dfdd4-131">`AssertMeasurement` heeft hand tekening `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="dfdd4-132">Omdat `AssertMeasurement` een functie met een lege tuple als uitvoer type is, kan geen effect van het aangeroepen `AssertMeasurement` worden gezien in een Q# programma.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="dfdd4-133">De <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> bewerkings functie beweringen die het opgegeven qubits in de gegeven Pauli-basis meten, hebben het gegeven resultaat met de opgegeven kans, binnen enkele tolerantie.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="dfdd4-134">Tolerantie is additief (bijvoorbeeld `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="dfdd4-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="dfdd4-135">Als de verklaring mislukt, wordt de uitvoering beëindigd door aan te roepen `fail` met het opgegeven bericht.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="dfdd4-136">Deze bewerking is standaard niet geïmplementeerd. Simulatoren die IT kunnen ondersteunen, moeten een implementatie bieden die runtime-controle uitvoert.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="dfdd4-137">`AssertMeasurementProbability` heeft hand tekening `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="dfdd4-138">De eerste van de `Double` para meters geeft de gewenste kans op het resultaat en de tweede tolerantie.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="dfdd4-139">We kunnen meer dan één meting uitvoeren, met behulp van de klassieke informatie die door een simulator wordt gebruikt om de interne status van een Qubit weer te geven. zo is het niet nodig om een meting uit te voeren om onze bewering te testen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="dfdd4-140">In het bijzonder kan dit redenen hebben om *incompatibele* metingen die niet mogelijk zijn op werkelijke hardware.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="dfdd4-141">Stel dat `P : Qubit => Unit` een bewerking is bedoeld om de status $ \ket{\psi} $ voor te bereiden wanneer de invoer de status $ \ket {0} $ heeft.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="dfdd4-142">Laat $ \ket{\psi '} $ de werkelijke status voor bereid door `P` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="dfdd4-143">$ \Ket{\psi} = \ket{\psi '} $ If en alleen als ' $ \ket{\psi '} $ wordt gemeten in de as die wordt beschreven door $ \ket{\psi} $ altijd retourneert `Zero` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="dfdd4-144">Dat wil zeggen, \begin{align} \ket{\psi} = \ket{\psi '} \Text{als en alleen if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="dfdd4-145">\end{align} met behulp van de primitieve bewerkingen die zijn gedefinieerd in de prelude, kunnen we rechtstreeks een meting uitvoeren die wordt geretourneerd `Zero` als $ \ket{\psi} $ een eigenstate is van een van de Pauli-Opera tors.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="dfdd4-146">De bewerking <xref:Microsoft.Quantum.Diagnostics.AssertQubit> biedt een bijzonder nuttige steno om dit te doen in het geval dat we de bewering $ \ket{\psi} = \ket $ willen testen {0} .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="dfdd4-147">Dit is bijvoorbeeld gebruikelijk wanneer we niet zijn berekend om ancilla qubits te retour neren naar $ \ket {0} $ voordat ze worden vrijgegeven.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="dfdd4-148">Het bevestigen van $ \ket {0} $ is ook handig wanneer u wilt voor komen dat twee status voorbereidingen `P` en `Q` -bewerkingen dezelfde status voor bereid hebben en wanneer deze worden `Q` ondersteund `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="dfdd4-149">Met name</span><span class="sxs-lookup"><span data-stu-id="dfdd4-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="dfdd4-150">Meer in het algemeen is er echter geen toegang tot beweringen over staten die niet samen vallen met eigenstates van Pauli-Opera tors.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="dfdd4-151">Bijvoorbeeld: $ \ket{\psi} = (\ket {0} + e ^ {\pi/8} \ket {1} )/\sqrt {2} $ is geen Eigenstate van een Pauli-operator, zodat we niet kunnen gebruiken om te <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> bepalen of een status $ \ket{\psi '} $ gelijk is aan $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="dfdd4-152">In plaats daarvan moeten we de Assertion $ \ket{\psi} = \ket{\psi} $ afbreken in veronderstellingen die rechtstreeks kunnen worden getest met behulp van de primitieven die door onze Simulator worden ondersteund.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="dfdd4-153">Als u dit wilt doen, laat u $ \ket{\psi} = \alpha \ket {0} + \beta \ket {1} $ voor complexe getallen $ \alpha = a \_ r + a \_ i $ en $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="dfdd4-154">Houd er rekening mee dat deze expressie vier echte cijfers $ \{ a \_ r, a \_ i, b \_ r, b \_ i $ vereist om op te \} geven, aangezien elk complex getal kan worden uitgedrukt als de som van een reëel en imaginair deel.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="dfdd4-155">Als gevolg van de globale fase kunnen we echter kiezen $a \_ i = $0, zodat we slechts drie echte cijfers nodig hebben om een unieke status van één Qubit op te geven.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="dfdd4-156">Daarom moeten we drie beweringen opgeven die onafhankelijk van elkaar zijn, om de status te bevestigen die we verwachten.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="dfdd4-157">We doen dit door de kans te vinden dat wordt geobserveerd `Zero` voor elke Pauli meting op $ \alpha $ en $ \beta $, en elk afzonderlijk te bevestigen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="dfdd4-158">Laat $x $, $y $ en $z $ waarden hebben `Result` voor Pauli $X $, $Y $ en respectievelijk $Z $-metingen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="dfdd4-159">Vervolgens gebruikt u de functie kans voor Quantum metingen, \begin{align} \Pr (x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{Zero} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + \_ \_ b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="dfdd4-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="dfdd4-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="dfdd4-160">\end{align}</span></span>

<span data-ttu-id="dfdd4-161"><xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance>Met de bewerking worden deze verklaringen geïmplementeerd met de opgegeven representaties van $ \alpha $ en $ \beta $ als waarden van het type <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="dfdd4-162">Dit is handig wanneer de verwachte status wiskundig kan worden berekend.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="dfdd4-163">Gelijkheid van Quantum bewerkingen bevestigen</span><span class="sxs-lookup"><span data-stu-id="dfdd4-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="dfdd4-164">Tot nu toe hebben we de tests uitgevoerd die bedoeld zijn om bepaalde staten voor te bereiden.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="dfdd4-165">Vaak is het echter belang rijk dat een bewerking wordt uitgevoerd voor wille keurige invoer in plaats van voor één vaste invoer.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="dfdd4-166">Stel dat we een bewerking hebben geïmplementeerd `U : ((Double, Qubit[]) => () : Adjoint)` die overeenkomt met een familie van unitary-Opera tors $U (t) $ en een expliciet blok heeft gegeven `adjoint` in plaats van met `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="dfdd4-167">We zijn mogelijk geïnteresseerd in het bevestigen dat $U ^ \dagger (t) = U (-t) $, zoals verwacht als $t $ een ontwikkelings tijd vertegenwoordigt.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="dfdd4-168">Breed gepaard gesp roken zijn er twee verschillende strategieën die we kunnen volgen bij het maken van de bevestiging dat twee bewerkingen `U` en op `V` identieke wijze handelen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="dfdd4-169">Eerst kunnen we controleren dat `U(target); (Adjoint V)(target);` elke provincie in een bepaalde basis blijft behouden.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="dfdd4-170">Ten tweede kunnen we controleren of `U(target); (Adjoint V)(target);` op de helft van een Entangled-status het entanglement wordt behouden.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="dfdd4-171">Deze strategieën worden geïmplementeerd door de Canon <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> -bewerkingen en <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> , respectievelijk.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="dfdd4-172">De benaderende bevestigingen die hierboven worden beschreven, zijn gebaseerd op de [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), een wiskundig Framework waarmee de bewerkingen op $n $ qubits worden gekoppeld aan Entangled Staten op $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="dfdd4-173">Met name de identiteits bewerking op $n $ qubits wordt vertegenwoordigd door $n $ copies van de Entangled-status $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="dfdd4-174">Met <xref:Microsoft.Quantum.Preparation.PrepareChoiState> deze bewerking wordt deze isomorphism geïmplementeerd, waarbij een status wordt voor bereid die een bepaalde bewerking vertegenwoordigt.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="dfdd4-175">Deze strategieën worden ongeveer onderscheiden door een tijd-spatie balans.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="dfdd4-176">Door elke invoer status te herhalen, neemt extra tijd in beslag, terwijl entanglement wordt gebruikt als referentie voor het opslaan van extra qubits.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="dfdd4-177">In gevallen waarin een bewerking een omkeerbaar klassieke bewerking implementeert, zodat we alleen geïnteresseerd zijn in het gedrag van reken kundige statussen, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> testen de gelijkheid op deze beperkte set invoer.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="dfdd4-178">De iteratie over de invoer status wordt verwerkt door de inventarisatie bewerkingen <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> en <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="dfdd4-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="dfdd4-179">Deze bewerkingen zijn in het algemeen nuttiger voor het Toep assen van een bewerking op elk element van het Cartesisch product tussen twee of meer sets.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="dfdd4-180">Het is belang rijker dat de twee benaderingen echter verschillende eigenschappen testen van de bewerkingen die worden onderzocht.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="dfdd4-181">Omdat de in-place bewering elke bewerking meerdere keren aanroept, kunnen wille keurige keuzes en meet resultaten worden gewijzigd tussen aanroepen, één keer per invoer status.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="dfdd4-182">Daarentegen wordt elke bewerking exact één keer aangeroepen, zodat er wordt gecontroleerd of de bewerkingen *in één opname* gelijk zijn.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot*.</span></span>
<span data-ttu-id="dfdd4-183">Beide tests zijn handig om de juistheid van Quantum Program ma's te garanderen.</span><span class="sxs-lookup"><span data-stu-id="dfdd4-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="dfdd4-184">Meer informatie</span><span class="sxs-lookup"><span data-stu-id="dfdd4-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
