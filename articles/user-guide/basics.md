---
title: 'Q # basis principes'
description: 'Basis concepten van Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: fd0ea47f00b1456ec460808ef7d451c8427677cd
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 05/15/2020
ms.locfileid: "83431152"
---
# <a name="q-basics"></a><span data-ttu-id="d25ec-103">Q # basis principes</span><span class="sxs-lookup"><span data-stu-id="d25ec-103">Q# Basics</span></span>

<span data-ttu-id="d25ec-104">In deze sectie wordt een korte inleiding tot de basis bouwstenen van Q # weer gegeven.</span><span class="sxs-lookup"><span data-stu-id="d25ec-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="d25ec-105">Voor een snel overzicht van wat Q # is en waar het past in als een fundamenteel onderdeel van de Quantum Development Kit, kunt u zien [wat q #? is](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="d25ec-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="d25ec-106">Wat is een Quantum programma?</span><span class="sxs-lookup"><span data-stu-id="d25ec-106">What is a quantum program?</span></span>

<span data-ttu-id="d25ec-107">Vanuit een technisch perspectief kan een Quantum programma worden gezien als een bepaalde set klassieke subroutines die, wanneer aangeroepen, bepaalde bewerkingen op een Quantum systeem uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="d25ec-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="d25ec-108">Een belang rijk gevolg van deze weer gave is dat een programma dat is geschreven in Q # niet rechtstreeks model qubits is, maar in plaats daarvan beschrijft hoe een klassieke beheer computer communiceert met deze qubits.</span><span class="sxs-lookup"><span data-stu-id="d25ec-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="d25ec-109">Standaard worden met Q # geen Quantum Staten of andere eigenschappen van Quantum mechanismen rechtstreeks gedefinieerd.</span><span class="sxs-lookup"><span data-stu-id="d25ec-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="d25ec-110">Bekijk bijvoorbeeld de status $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ die wordt besproken in de hand leiding over de [quantum computing-concepten](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="d25ec-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="d25ec-111">Als u deze status wilt voorbereiden in Q #, gebruiken we de feiten die de qubits zijn geïnitialiseerd in de $ \ket {0} $-status en dat $ \ket{+} = H\ket {0} $, waarbij $H $ de Hadamard-trans formatie is, geïmplementeerd door de [ `H` Operation] (] (XREF: micro soft. Quantum. intrinsiek. H):</span><span class="sxs-lookup"><span data-stu-id="d25ec-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="d25ec-112">Quantum Staten in Q #</span><span class="sxs-lookup"><span data-stu-id="d25ec-112">Quantum states in Q#</span></span>

<span data-ttu-id="d25ec-113">Het is belang rijk dat u bij het schrijven van het bovenstaande programma niet expliciet naar de status van Q # verwijst, maar in plaats daarvan hebt aangegeven hoe de status door ons programma is *getransformeerd* .</span><span class="sxs-lookup"><span data-stu-id="d25ec-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="d25ec-114">Op deze manier kunnen we volledig neutraal over wat een Quantum staat, *zelfs op elke* doel computer, die verschillende interpretaties kan hebben, afhankelijk van de computer.</span><span class="sxs-lookup"><span data-stu-id="d25ec-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="d25ec-115">Een Q #-programma heeft geen mogelijkheid om introspect te gaan in de status van een Qubit.</span><span class="sxs-lookup"><span data-stu-id="d25ec-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="d25ec-116">Een programma kan in plaats daarvan bewerkingen aanroepen zoals [`Measure`](xref:microsoft.quantum.intrinsic.measure) om informatie van een Qubit te leren en om bewerkingen zoals [`X`](xref:microsoft.quantum.intrinsic.x) en [`H`](xref:microsoft.quantum.intrinsic.h) te kunnen aanroepen om te reageren op de status van een Qubit.</span><span class="sxs-lookup"><span data-stu-id="d25ec-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="d25ec-117">Wat deze bewerkingen eigenlijk *doen* , worden alleen concreet gemaakt door de doel computer die we gebruiken om het specifieke Q #-programma uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="d25ec-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="d25ec-118">Als bijvoorbeeld het programma wordt uitgevoerd op onze [volle Simulator](xref:microsoft.quantum.machines.full-state-simulator), voert de Simulator de bijbehorende wiskundige bewerkingen uit op het gesimuleerde Quantum systeem.</span><span class="sxs-lookup"><span data-stu-id="d25ec-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="d25ec-119">Maar in de toekomst kijken, wanneer de doel computer een echte quantum computer is, leidt het aanroepen van dergelijke bewerkingen in Q # ervoor dat de quantum computer de overeenkomstige *real* -bewerkingen op het *echte* Quantum systeem kan uitvoeren (bijvoorbeeld nauw keurig verlopen Laser pulsen).</span><span class="sxs-lookup"><span data-stu-id="d25ec-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="d25ec-120">Een Q #-programma recombineert deze bewerkingen, zoals gedefinieerd door een doel machine, om nieuwe bewerkingen op een hoger niveau te maken voor een snelle Quantum berekening.</span><span class="sxs-lookup"><span data-stu-id="d25ec-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="d25ec-121">Op deze manier maakt Q # het eenvoudig om de logische en hybride Quantum-algoritmen van de logica te expresseren, en is deze ook algemeen wat betreft de structuur van een doel machine of Simulator.</span><span class="sxs-lookup"><span data-stu-id="d25ec-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="d25ec-122">Q # bewerkingen en functies</span><span class="sxs-lookup"><span data-stu-id="d25ec-122">Q# operations and functions</span></span>

<span data-ttu-id="d25ec-123">In concrete zin is een Q #-programma bestaande uit *bewerkingen*, *functies*en eventuele door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="d25ec-124">Bewerkingen worden gebruikt om de trans formaties van Quantum systemen te beschrijven en zijn de meest elementaire bouw stenen van Q #-Program ma's.</span><span class="sxs-lookup"><span data-stu-id="d25ec-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="d25ec-125">Elke bewerking die in Q # is gedefinieerd, kan vervolgens een wille keurig aantal andere bewerkingen aanroepen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="d25ec-126">In tegens telling tot bewerkingen worden functies gebruikt om louter *deterministisch* klassiek gedrag te beschrijven en geen effect te hebben naast het uitvoeren van klassieke waarden.</span><span class="sxs-lookup"><span data-stu-id="d25ec-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="d25ec-127">Stel bijvoorbeeld dat we de qubits aan het einde van een programma willen meten en de meet resultaten aan een matrix moeten toevoegen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="d25ec-128">In dit geval `Measure` is een *bewerking* waarmee de doel computer een meting kan uitvoeren op de (reële of gesimuleerde) qubits, en het klassieke proces van het toevoegen van de geretourneerde resultaten aan een matrix wordt verwerkt door- *functies*.</span><span class="sxs-lookup"><span data-stu-id="d25ec-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="d25ec-129">Bewerkingen en functies worden samen aangeduid als *callables*, en de onderliggende structuur en het gedrag ervan worden geïntroduceerd op de [bewerkingen en functies op de pagina Q #](xref:microsoft.quantum.guide.operationsfunctions) .</span><span class="sxs-lookup"><span data-stu-id="d25ec-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="d25ec-130">Q # syntaxis overzicht</span><span class="sxs-lookup"><span data-stu-id="d25ec-130">Q# syntax overview</span></span>

<span data-ttu-id="d25ec-131">De syntaxis van een taal beschrijft de verschillende combi Naties van symbolen die een syntactisch corrigerend programma vormen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="d25ec-132">In Q # kunnen we de elementen van de syntaxis in drie verschillende groepen classificeren: typen, expressies en instructies.</span><span class="sxs-lookup"><span data-stu-id="d25ec-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="d25ec-133">Typen</span><span class="sxs-lookup"><span data-stu-id="d25ec-133">Types</span></span>
<span data-ttu-id="d25ec-134">Q # is een sterk getypeerde taal, zodat het gebruik van typen zorgvuldig kan helpen de compiler sterke garanties te bieden met Q #-Program ma's tijdens het compileren.</span><span class="sxs-lookup"><span data-stu-id="d25ec-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="d25ec-135">Naast de standaard en Quantum specifieke ingebouwde primitieve typen (zoals `Int` ,, `Bool` `Qubit` en `Result` ), biedt Q # ondersteuning voor door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="d25ec-136">De verschillende primitieve typen van Q # worden beschreven op de pagina [typen op Q #](xref:microsoft.quantum.guide.types) , samen met details over matrix-en tuple-typen, en het definiëren van nieuwe typen in een Q #-bestand.</span><span class="sxs-lookup"><span data-stu-id="d25ec-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="d25ec-137">Expressies</span><span class="sxs-lookup"><span data-stu-id="d25ec-137">Expressions</span></span>
<span data-ttu-id="d25ec-138">Een expressie in een programmeer taal is een combi natie van een of meer constanten, variabelen, Opera tors en functies die door de programmeer taal worden geïnterpreteerd en geëvalueerd naar een specifieke waarde.</span><span class="sxs-lookup"><span data-stu-id="d25ec-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="d25ec-139">In de meeste gevallen kunt u voor elk type in een taal *letterlijke* expressies of symbolen van dat type maken die zijn gebonden aan een waarde van dat type.</span><span class="sxs-lookup"><span data-stu-id="d25ec-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="d25ec-140">`5`Is bijvoorbeeld een `Int` letterlijke waarde (ook wel een expressie van `Int` het type), en als het symbool `count` is gebonden aan de integerwaarde `5` , `count` is ook een expressie met gehele getallen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="d25ec-141">Daarnaast kan een expressie bestaan uit andere expressies die worden gecombineerd met bepaalde Opera tors.</span><span class="sxs-lookup"><span data-stu-id="d25ec-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="d25ec-142">Een voor beeld van een `Int` expressie die wordt geëvalueerd naar `5` is `2+3` .</span><span class="sxs-lookup"><span data-stu-id="d25ec-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="d25ec-143">De mogelijke expressies van typen in Q # en de compatibele Opera tors die kunnen worden gebruikt om ze te maken, worden beschreven op de pagina [type-expressies in Q #](xref:microsoft.quantum.guide.expressions) .</span><span class="sxs-lookup"><span data-stu-id="d25ec-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="d25ec-144">Instructies</span><span class="sxs-lookup"><span data-stu-id="d25ec-144">Statements</span></span> 
<span data-ttu-id="d25ec-145">Een instructie is een syntaxis eenheid van een verplichte programmeer taal die een aantal actie bevat die moet worden uitgevoerd. Met de instructies in deze instructies worden geen resultaten geretourneerd en alleen voor hun neven effecten uitgevoerd, terwijl expressies altijd een resultaat retour neren en vaak geen neven effecten hebben.</span><span class="sxs-lookup"><span data-stu-id="d25ec-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="d25ec-146">Dit onderscheid wordt vaak geconstateerd in de formule: er wordt een expressie geëvalueerd, terwijl een instructie wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="d25ec-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="d25ec-147">Een eenvoudig voor beeld van een instructie in Q # is het toewijzen van een symbool aan een expressie:</span><span class="sxs-lookup"><span data-stu-id="d25ec-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="d25ec-148">Een iets interessantere voor beeld is de `for` instructie die iteratie ondersteunt en een *instructie blok*bevat.</span><span class="sxs-lookup"><span data-stu-id="d25ec-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="d25ec-149">Stel dat `qubits` het symbool is gebonden aan een REGI ster van qubits (technisch type `Qubit[]` , dat wil zeggen een matrix met `Qubit` typen).</span><span class="sxs-lookup"><span data-stu-id="d25ec-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="d25ec-150">Kies</span><span class="sxs-lookup"><span data-stu-id="d25ec-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="d25ec-151">is een instructie waarmee elke qubit in de kassa wordt herhaald, waarbij de `H` bewerking op elk wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="d25ec-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="d25ec-152">Houd er rekening mee dat `H(qubit);` er ook een instructie is.</span><span class="sxs-lookup"><span data-stu-id="d25ec-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="d25ec-153">Een aanroep expressie van het type `Unit` (die callables die geen informatie retour neren) kan ook worden gebruikt als een instructie.</span><span class="sxs-lookup"><span data-stu-id="d25ec-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="d25ec-154">Dit wordt voornamelijk gebruikt wanneer u bewerkingen aanroept voor qubits die resulteren in het `Unit` doel van de instructie om de impliciete Quantum status te wijzigen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="d25ec-155">Voor expressie-evaluatie-instructies is een afsluit punt komma vereist.</span><span class="sxs-lookup"><span data-stu-id="d25ec-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="d25ec-156">Bijna elk aspect van een Q #-programma is gebouwd met behulp van instructies, zodat niet alle informatie die betrekking heeft op de pagina kan worden opgenomen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="d25ec-157">De lexicale structuur en-opmaak worden echter beschreven op de pagina [q # bestands structuur](xref:microsoft.quantum.guide.filestructure) , de toewijzing van het symbool en het bereik bij [variabelen in q #](xref:microsoft.quantum.guide.variables), en controle stroom lussen zoals `for` bij [controle stroom in q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="d25ec-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>


## <a name="whats-next"></a><span data-ttu-id="d25ec-158">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="d25ec-158">What's next?</span></span>
<span data-ttu-id="d25ec-159">In de rest van deze hand leiding wordt uitgelegd hoe u Q # kunt gebruiken om complexe Quantum Programma's te maken met behulp van de basis bouwstenen van bewerkingen, functies en typen.</span><span class="sxs-lookup"><span data-stu-id="d25ec-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="d25ec-160">Om aan de slag te gaan, kunt u beginnen met het leren [van typen in Q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="d25ec-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="d25ec-161">Als u meer wilt weten over de stichtingen en motivatie achter Q #, Lees [dan waarom hebben we q # nodig?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="d25ec-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
