---
title: Q# Bewerkingen
description: Basis concepten van Q#
author: gillenhaalb
ms.author: a-gibec
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- Q#
- $$v
ms.openlocfilehash: 86f6538cf383f4e7c14255b38cfb1c141c8f991b
ms.sourcegitcommit: 9b0d1ffc8752334bd6145457a826505cc31fa27a
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 09/21/2020
ms.locfileid: "90835516"
---
# <a name="no-locq-basics"></a><span data-ttu-id="d0b20-103">Q# Bewerkingen</span><span class="sxs-lookup"><span data-stu-id="d0b20-103">Q# Basics</span></span>

<span data-ttu-id="d0b20-104">Dit artikel bevat een korte inleiding tot de basis bouwstenen van Q# .</span><span class="sxs-lookup"><span data-stu-id="d0b20-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="d0b20-105">Q#Zie [Wat is Q# ?](xref:microsoft.quantum.overview.q-sharp)voor een overzicht van wat is en waar het past in als een fundamenteel onderdeel van de Quantum Development Kit.</span><span class="sxs-lookup"><span data-stu-id="d0b20-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="d0b20-106">Wat is een Quantum programma?</span><span class="sxs-lookup"><span data-stu-id="d0b20-106">What is a quantum program?</span></span>

<span data-ttu-id="d0b20-107">Vanuit een technisch perspectief is een Quantum programma een bepaalde set klassieke subroutines die, wanneer aangeroepen, bepaalde bewerkingen op een Quantum systeem uitvoeren.</span><span class="sxs-lookup"><span data-stu-id="d0b20-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="d0b20-108">Een belang rijk gevolg van deze weer gave is dat een Q# programma qubits zelf niet rechtstreeks modelt, maar in plaats daarvan wordt beschreven hoe een klassieke, beheerde computer communiceert met die qubits.</span><span class="sxs-lookup"><span data-stu-id="d0b20-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="d0b20-109">Standaard worden door het ontwerp Q# geen Quantum Staten of andere eigenschappen van Quantum mechanismen gedefinieerd.</span><span class="sxs-lookup"><span data-stu-id="d0b20-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="d0b20-110">Bekijk bijvoorbeeld de status $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ die wordt besproken in de hand leiding over de [quantum computing-concepten](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="d0b20-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="d0b20-111">Als u deze status wilt voorbereiden in Q# , begint u met de feiten die de qubits hebben geïnitialiseerd in de $ \ket {0} $-status en die $ \ket{+} = H\ket {0} $, waarbij $H $ de [Hadamard-trans formatie](xref:microsoft.quantum.glossary#hadamard)is, geïmplementeerd door de [ `H` bewerking](xref:microsoft.quantum.intrinsic.h).</span><span class="sxs-lookup"><span data-stu-id="d0b20-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:microsoft.quantum.intrinsic.h).</span></span> <span data-ttu-id="d0b20-112">De Basic Q# -code voor het initialiseren en transformeren van een Qubit. dit ziet er als volgt uit:</span><span class="sxs-lookup"><span data-stu-id="d0b20-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="d0b20-113">Zie [werken met qubits](xref:microsoft.quantum.guide.qubits)voor meer informatie over het initialiseren van, of het *toewijzen*van qubits.</span><span class="sxs-lookup"><span data-stu-id="d0b20-113">For more information on initializing, or *allocating*, qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-no-locq"></a><span data-ttu-id="d0b20-114">Quantum provincies in Q#</span><span class="sxs-lookup"><span data-stu-id="d0b20-114">Quantum states in Q#</span></span>

<span data-ttu-id="d0b20-115">Belang rijk: in het vorige programma wordt niet expliciet naar de status verwezen, Q# maar wordt beschreven hoe ons programma de status heeft *getransformeerd* .</span><span class="sxs-lookup"><span data-stu-id="d0b20-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="d0b20-116">Met deze methode kunt u volledig neutraal over wat een Quantum status *heeft* , zelfs op elke doel computer, die verschillende interpretaties kan hebben, afhankelijk van de computer.</span><span class="sxs-lookup"><span data-stu-id="d0b20-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="d0b20-117">Een Q# programma kan niet introspect in de status van een Qubit.</span><span class="sxs-lookup"><span data-stu-id="d0b20-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="d0b20-118">Een programma kan in plaats daarvan bewerkingen aanroepen zoals [`Measure`](xref:microsoft.quantum.intrinsic.measure) om informatie van een Qubit te leren en om bewerkingen zoals [`X`](xref:microsoft.quantum.intrinsic.x) en [`H`](xref:microsoft.quantum.intrinsic.h) te kunnen aanroepen om te reageren op de status van een Qubit.</span><span class="sxs-lookup"><span data-stu-id="d0b20-118">Instead, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="d0b20-119">Wat deze bewerkingen eigenlijk *doen* , worden alleen concreet gemaakt door de doel computer die wordt gebruikt om het desbetreffende programma uit te voeren Q# .</span><span class="sxs-lookup"><span data-stu-id="d0b20-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="d0b20-120">Als bijvoorbeeld het programma wordt uitgevoerd op onze [volle Simulator](xref:microsoft.quantum.machines.full-state-simulator), voert de Simulator de bijbehorende wiskundige bewerkingen uit op het gesimuleerde Quantum systeem.</span><span class="sxs-lookup"><span data-stu-id="d0b20-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="d0b20-121">Maar in de toekomst kijken we, wanneer de doel computer een echte quantum computer is, dergelijke bewerkingen aanroepen in Q# de quantum computer om de overeenkomstige *real* -bewerkingen uit te voeren op het *echte* Quantum systeem, bijvoorbeeld nauw keurig verlopen Laser pulsen).</span><span class="sxs-lookup"><span data-stu-id="d0b20-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="d0b20-122">Een Q# programma recombineert deze bewerkingen, zoals gedefinieerd door een doel machine, om nieuwe bewerkingen op een hoger niveau te maken voor een snelle Quantum berekening.</span><span class="sxs-lookup"><span data-stu-id="d0b20-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="d0b20-123">Op deze manier kunt u Q# eenvoudig de logische en hybride Quantum-algoritmen van de logica uitdrukken, maar ook algemeen met betrekking tot de structuur van een doel machine of Simulator.</span><span class="sxs-lookup"><span data-stu-id="d0b20-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="no-locq-operations-and-functions"></a><span data-ttu-id="d0b20-124">Q# bewerkingen en functies</span><span class="sxs-lookup"><span data-stu-id="d0b20-124">Q# operations and functions</span></span>

<span data-ttu-id="d0b20-125">In concrete Q# zin bestaat een programma uit *bewerkingen*, *functies*en eventuele door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-125">Concretely, a Q# program comprises *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="d0b20-126">Bewerkingen worden gebruikt om de trans formaties van Quantum systemen te beschrijven en zijn de meest fundamentele bouw stenen voor Q# Program ma's.</span><span class="sxs-lookup"><span data-stu-id="d0b20-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="d0b20-127">Elke bewerking die is gedefinieerd in Q# kan vervolgens een wille keurig aantal andere bewerkingen aanroepen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="d0b20-128">In tegens telling tot bewerkingen worden functies gebruikt om louter *deterministisch* klassiek gedrag te beschrijven en geen effect te hebben naast het uitvoeren van klassieke waarden.</span><span class="sxs-lookup"><span data-stu-id="d0b20-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="d0b20-129">Stel bijvoorbeeld dat u de qubits aan het einde van een programma wilt meten en de meet resultaten wilt toevoegen aan een matrix.</span><span class="sxs-lookup"><span data-stu-id="d0b20-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="d0b20-130">In dit geval `Measure` is een *bewerking* waarmee de doel computer een meting kan uitvoeren op de (reële of gesimuleerde) qubits.</span><span class="sxs-lookup"><span data-stu-id="d0b20-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="d0b20-131">Terzelfder tijd verwerken *functies* het klassieke proces van het toevoegen van de geretourneerde resultaten aan een matrix.</span><span class="sxs-lookup"><span data-stu-id="d0b20-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="d0b20-132">Samen worden bewerkingen en functies ook wel *callables*genoemd.</span><span class="sxs-lookup"><span data-stu-id="d0b20-132">Together, operations and functions are known as *callables*.</span></span> <span data-ttu-id="d0b20-133">Hun onderliggende structuur en gedrag worden geïntroduceerd en beschreven in [bewerkingen en functies in Q# ](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="d0b20-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="no-locq-syntax-overview"></a><span data-ttu-id="d0b20-134">Q# syntaxis overzicht</span><span class="sxs-lookup"><span data-stu-id="d0b20-134">Q# syntax overview</span></span>

<span data-ttu-id="d0b20-135">De syntaxis van een taal beschrijft de verschillende combi Naties van symbolen die een syntactisch corrigerend programma vormen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="d0b20-136">In Q# worden syntaxis elementen ingedeeld in drie verschillende groepen: typen, expressies en instructies.</span><span class="sxs-lookup"><span data-stu-id="d0b20-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="d0b20-137">Typen</span><span class="sxs-lookup"><span data-stu-id="d0b20-137">Types</span></span>
<span data-ttu-id="d0b20-138">Q# is een sterk getypeerde taal, zodat het gebruik van typen zorgvuldig kan bijdragen aan de compiler, waardoor het mogelijk is dat er sterke garanties worden geboden over Q# Program ma's tijdens het compileren.</span><span class="sxs-lookup"><span data-stu-id="d0b20-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="d0b20-139">Naast de standaard en Quantum specifieke ingebouwde primitieve typen, bijvoorbeeld,, `Int` `Bool` `Qubit` en `Result` , Q# biedt ondersteuning voor door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="d0b20-140">Q#Zie [typen in Q# ](xref:microsoft.quantum.guide.types)voor beschrijvingen van alle primitieve typen, Details voor matrix-en tuple-typen en stappen voor het definiëren van nieuwe typen in een bestand.</span><span class="sxs-lookup"><span data-stu-id="d0b20-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="d0b20-141">Expressies</span><span class="sxs-lookup"><span data-stu-id="d0b20-141">Expressions</span></span>
<span data-ttu-id="d0b20-142">Een expressie in een programmeer taal is een combi natie van een of meer constanten, variabelen, Opera tors en functies die door de programmeer taal worden geïnterpreteerd en geëvalueerd naar een specifieke waarde.</span><span class="sxs-lookup"><span data-stu-id="d0b20-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="d0b20-143">In de meeste gevallen kunt u voor elk type in een taal *letterlijke* expressies of symbolen van dat type maken die zijn gebonden aan een waarde van dat type.</span><span class="sxs-lookup"><span data-stu-id="d0b20-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="d0b20-144">`5`Is bijvoorbeeld een `Int` letterlijke waarde (ook wel een expressie van `Int` het type), en als het symbool `count` is gebonden aan de integerwaarde `5` , `count` is ook een expressie met gehele getallen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="d0b20-145">Daarnaast kan een expressie bestaan uit andere expressies die worden gecombineerd door bepaalde Opera tors.</span><span class="sxs-lookup"><span data-stu-id="d0b20-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="d0b20-146">Een voor beeld hiervan `Int` is een andere expressie die `5` wordt geëvalueerd naar `2+3` .</span><span class="sxs-lookup"><span data-stu-id="d0b20-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="d0b20-147">Q#Zie [type expressies in Q# ](xref:microsoft.quantum.guide.expressions)voor meer informatie over expressies en compatibele Opera tors in.</span><span class="sxs-lookup"><span data-stu-id="d0b20-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="d0b20-148">Instructies</span><span class="sxs-lookup"><span data-stu-id="d0b20-148">Statements</span></span> 
<span data-ttu-id="d0b20-149">Een instructie is een syntaxis eenheid van een verplichte programmeer taal waarin een aantal acties wordt vermeld die moeten worden uitgevoerd. Met de instructies in deze instructies worden geen resultaten geretourneerd en alleen voor hun neven effecten uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="d0b20-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are run solely for their side effects.</span></span> <span data-ttu-id="d0b20-150">Expressies retour neren echter altijd een resultaat en bevatten vaak geen neven effecten.</span><span class="sxs-lookup"><span data-stu-id="d0b20-150">Expressions, however, always return a result and often do not have any side effects.</span></span> <span data-ttu-id="d0b20-151">Kortom, Q# instructies worden uitgevoerd, terwijl expressies worden geëvalueerd.</span><span class="sxs-lookup"><span data-stu-id="d0b20-151">In short, Q# statements are run, while expressions are evaluated.</span></span>

<span data-ttu-id="d0b20-152">Een eenvoudig voor beeld van een instructie in Q# is het toewijzen van een symbool aan een expressie:</span><span class="sxs-lookup"><span data-stu-id="d0b20-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="d0b20-153">Een interessantere voor beeld is de `for` instructie die iteratie ondersteunt en een *instructie blok*bevat.</span><span class="sxs-lookup"><span data-stu-id="d0b20-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="d0b20-154">Stel dat `qubits` het symbool is gebonden aan een REGI ster van qubits (technisch type `Qubit[]` of een matrix van `Qubit` typen).</span><span class="sxs-lookup"><span data-stu-id="d0b20-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="d0b20-155">Kies</span><span class="sxs-lookup"><span data-stu-id="d0b20-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="d0b20-156">is een instructie waarmee elke qubit in de kassa wordt herhaald, waarbij de `H` bewerking op elk afzonderlijk wordt uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="d0b20-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="d0b20-157">Houd er rekening mee dat `H(qubit);` er ook een instructie is.</span><span class="sxs-lookup"><span data-stu-id="d0b20-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="d0b20-158">U kunt elke aanroep expressie van het type `Unit` (een `Unit` type geeft geen informatie) als een instructie gebruiken.</span><span class="sxs-lookup"><span data-stu-id="d0b20-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="d0b20-159">Dit type expressie is handig bij het aanroepen van bewerkingen op qubits die worden geretourneerd `Unit` , omdat het doel van de instructie is om de impliciete Quantum status te wijzigen.</span><span class="sxs-lookup"><span data-stu-id="d0b20-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="d0b20-160">Voor expressie-evaluatie-instructies is een afsluit punt komma vereist.</span><span class="sxs-lookup"><span data-stu-id="d0b20-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="d0b20-161">U gebruikt-instructies om bijna elk aspect van een Q# programma te bouwen, en er kan geen enkele pagina alle informatie bevatten.</span><span class="sxs-lookup"><span data-stu-id="d0b20-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="d0b20-162">Zie voor meer informatie over de lexicale structuur en opmaak, [ Q# bestands structuur](xref:microsoft.quantum.guide.filestructure); voor de toewijzing van een symbool binding en het bereik, Zie [variabelen in Q# ](xref:microsoft.quantum.guide.variables); en voor controle stroom lussen zoals `for` , Zie [controle stroom in Q# ](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="d0b20-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="d0b20-163">Volgende stappen</span><span class="sxs-lookup"><span data-stu-id="d0b20-163">Next steps</span></span>

<span data-ttu-id="d0b20-164">Begin met het leren van [typen in Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="d0b20-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="d0b20-165">Voor meer achtergrond informatie over de stichtingen en motivatie achter Q# , Zie [Waarom zijn we nodig Q# ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="d0b20-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
