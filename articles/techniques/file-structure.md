---
title: Programmaoverzicht voor Q#
description: Leer de basis structuur van een Quantum programma en hoe het trans formaties van Quantum staten vertegenwoordigt.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907695"
---
# <a name="q-program-overview"></a><span data-ttu-id="5eb43-103">Programmaoverzicht voor Q#</span><span class="sxs-lookup"><span data-stu-id="5eb43-103">Q# program overview</span></span>

<span data-ttu-id="5eb43-104">Q # is een schaal bare, op domeinen gebaseerde programmeer taal die specifiek is voor het gebruik van Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="5eb43-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="5eb43-105">Q # is een Quantum-programmeer taal in die IT kan worden gebruikt om te beschrijven hoe instructies op Quantum machines worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="5eb43-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="5eb43-106">De computers waarop het bereik kan worden toegepast, kunnen variëren van simulatoren tot echte kwantum-hardware.</span><span class="sxs-lookup"><span data-stu-id="5eb43-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="5eb43-107">Q # is schaalbaar: het kan worden gebruikt voor het schrijven van eenvoudige demonstratie Programma's, zoals het teleporteren die worden uitgevoerd op een paar qubits, maar biedt ook ondersteuning voor het schrijven van grote, geavanceerde Program ma's, zoals simulaties van complexe moleculen die grote machines met miljoenen qubits nodig hebben.</span><span class="sxs-lookup"><span data-stu-id="5eb43-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="5eb43-108">Hoewel grote fysieke machines zich nog steeds in de toekomst bevinden, staat Q # toe dat een programmeur nu complexe Quantum algoritmen kan Program meren.</span><span class="sxs-lookup"><span data-stu-id="5eb43-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="5eb43-109">Wat meer is, Q # ondersteunt diverse taken zoals fout opsporing, profile ring, resource schatting en bepaalde speciale simulaties op een schaal bare manier.</span><span class="sxs-lookup"><span data-stu-id="5eb43-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="5eb43-110">Vanuit een technisch perspectief kan een Quantum programma worden gezien als een bepaalde set klassieke functies die, indien aangeroepen, Quantum circuits genereren als neven effecten.</span><span class="sxs-lookup"><span data-stu-id="5eb43-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="5eb43-111">Een belang rijk gevolg van deze weer gave is dat een programma dat is geschreven in Q # niet rechtstreeks model qubits is, maar in plaats daarvan beschrijft hoe een klassieke beheer computer communiceert met deze qubits.</span><span class="sxs-lookup"><span data-stu-id="5eb43-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="5eb43-112">Standaard worden met Q # geen Quantum toestanden of andere eigenschappen van Quantum-mechanismen gedefinieerd, maar wel direct via de actie van de verschillende subroutines die in de taal zijn gedefinieerd.</span><span class="sxs-lookup"><span data-stu-id="5eb43-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="5eb43-113">Bekijk bijvoorbeeld de status $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$, zoals beschreven in de hand leiding over de [quantum computing-concepten](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="5eb43-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="5eb43-114">Als u deze status wilt voorbereiden in Q #, gebruiken we de feiten die de qubits hebben geïnitialiseerd in $ \ket{0}$ status en dat $ \ket{+} = H\ket{0}$, waarbij $H $ de Hadamard-trans formatie is:</span><span class="sxs-lookup"><span data-stu-id="5eb43-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="5eb43-115">Q # tranformations van Quantum Staten</span><span class="sxs-lookup"><span data-stu-id="5eb43-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="5eb43-116">Het is belang rijk dat u bij het schrijven van het bovenstaande programma niet expliciet naar de status van Q # verwijst, maar in plaats daarvan hebt aangegeven hoe de status door ons programma is *getransformeerd* .</span><span class="sxs-lookup"><span data-stu-id="5eb43-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="5eb43-117">Net als bij de manier waarop een grafische arcerings programma een beschrijving van trans formaties naar elk hoek punt samenvoegt, accumuleert een Quantum programma in Q # trans formaties naar Quantum statussen.</span><span class="sxs-lookup"><span data-stu-id="5eb43-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="5eb43-118">Op deze manier kunnen we volledig neutraal over wat een Quantum staat, *zelfs op elke* doel computer, die verschillende interpretaties kan hebben, afhankelijk van de computer.</span><span class="sxs-lookup"><span data-stu-id="5eb43-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="5eb43-119">Vanuit het perspectief van een Q #-programma is een Qubit een volledig dekkende verwijzing naar de interne structuur van een doel machine.</span><span class="sxs-lookup"><span data-stu-id="5eb43-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="5eb43-120">Een Q #-programma heeft geen mogelijkheid om introspect te gaan in de status van een Qubit, de weer gave op een doel machine of zelfs op dezelfde Qubit als andere Qubit die beschikbaar zijn voor het programma.</span><span class="sxs-lookup"><span data-stu-id="5eb43-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="5eb43-121">Een programma kan in plaats daarvan bewerkingen als `Measure` aanroepen om informatie uit een Qubit te leren en om bewerkingen zoals `X` en `H` aan te roepen om te reageren op de status van een Qubit.</span><span class="sxs-lookup"><span data-stu-id="5eb43-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="5eb43-122">Deze bewerkingen hebben geen intrinsieke definitie in de taal en worden alleen concreet gemaakt door de doel computer die wordt gebruikt om een bepaald Q #-programma uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="5eb43-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="5eb43-123">Een Q #-programma recombineert deze bewerkingen, zoals gedefinieerd door een doel machine, om nieuwe bewerkingen op een hoger niveau te maken voor een snelle Quantum berekening.</span><span class="sxs-lookup"><span data-stu-id="5eb43-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="5eb43-124">Op deze manier maakt Q # het eenvoudig om de logische en hybride Quantum-algoritmen te kunnen uitdrukken, en is het ook algemeen wat betreft de structuur van een doel machine of Simulator.</span><span class="sxs-lookup"><span data-stu-id="5eb43-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="5eb43-125">Q # bewerkingen en functies</span><span class="sxs-lookup"><span data-stu-id="5eb43-125">Q# operations and functions</span></span>

<span data-ttu-id="5eb43-126">In concrete zin is een Q #-programma bestaande uit een of meer *bewerkingen*, een of meer *functies*en door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="5eb43-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="5eb43-127">Bewerkingen worden gebruikt om de trans formaties van de status van een Quantum machine te beschrijven en zijn de meest elementaire bouw stenen van Q #-Program ma's.</span><span class="sxs-lookup"><span data-stu-id="5eb43-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="5eb43-128">Elke bewerking die is gedefinieerd in Q # kan vervolgens een wille keurig aantal andere bewerkingen aanroepen, met inbegrip van de ingebouwde *intrinsieke* bewerkingen die worden geïmplementeerd door een doel machine.</span><span class="sxs-lookup"><span data-stu-id="5eb43-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="5eb43-129">Bij compilatie wordt elke bewerking weer gegeven als een .NET-klassetype dat kan worden geleverd aan doel computers.</span><span class="sxs-lookup"><span data-stu-id="5eb43-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="5eb43-130">In tegens telling tot bewerkingen worden functies gebruikt om louter klassiek gedrag te beschrijven en geen effecten te hebben, behalve het berekenen van klassieke uitvoer waarden.</span><span class="sxs-lookup"><span data-stu-id="5eb43-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="5eb43-131">Q # is een sterk getypeerde taal en wordt geleverd met een set ingebouwde primitieve typen, en biedt ondersteuning voor door de gebruiker gedefinieerde typen.</span><span class="sxs-lookup"><span data-stu-id="5eb43-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="5eb43-132">In de rest van deze hand leiding wordt uitgelegd hoe u verschillende taal concepten en-constructies kunt gebruiken om te helpen bij het definiëren van complexe Quantum Programma's via de basis bouwstenen van bewerkingen, functies en typen.</span><span class="sxs-lookup"><span data-stu-id="5eb43-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="5eb43-133">Structuur van Q # bron bestanden</span><span class="sxs-lookup"><span data-stu-id="5eb43-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="5eb43-134">Een Q #-bron bestand bestaat mini maal uit een *naam ruimte declaratie*, waarmee een .net-naam ruimte wordt opgegeven die de definities in het bron bestand bevat.</span><span class="sxs-lookup"><span data-stu-id="5eb43-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="5eb43-135">Definities van andere Q #-bron bestanden en-bibliotheken kunnen worden opgenomen met behulp van de `open`-instructie.</span><span class="sxs-lookup"><span data-stu-id="5eb43-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="5eb43-136">Zo worden bijvoorbeeld de meeste Operations-basis poorten gedefinieerd in de naam ruimte <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="5eb43-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="5eb43-137">Om dit beschikbaar te maken voor onze code, `open` u de naam ruimte aan de bovenkant van elk bestand.</span><span class="sxs-lookup"><span data-stu-id="5eb43-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="5eb43-138">Binnen een naam ruimte kan elk Q #-bron bestand een wille keurige combi natie van *bewerkingen*, *functies*en door de *gebruiker gedefinieerde typen*definiëren.</span><span class="sxs-lookup"><span data-stu-id="5eb43-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="5eb43-139">In de rest van deze sectie beschrijven we elk op zijn beurt en bieden we voor beelden van hoe ze in de praktijk kunnen worden gebruikt om nuttige Quantum Program ma's te maken.</span><span class="sxs-lookup"><span data-stu-id="5eb43-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
