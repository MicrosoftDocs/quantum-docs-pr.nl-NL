---
title: 'Q # standaard bibliotheken-algoritmen | Microsoft Docs'
description: 'Q # standaard bibliotheken'
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
ms.openlocfilehash: 61efddb9e7199543370ffd66d08f78ec013f4f79
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185695"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="b4512-103">Quantum algoritmen</span><span class="sxs-lookup"><span data-stu-id="b4512-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="b4512-104">Amplitude versterking</span><span class="sxs-lookup"><span data-stu-id="b4512-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="b4512-105">*Amplitude versterking* is een van de fundamentele hulpprogram Ma's van Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="b4512-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="b4512-106">Het is het belangrijkste idee dat grover de zoek functie, amplitude schatting en veel Quantum machine learning-algoritmen ondervindt.</span><span class="sxs-lookup"><span data-stu-id="b4512-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="b4512-107">Er zijn veel varianten, en in Q # bieden we een algemene versie op basis van een Oblivious amplitude-versterking met gedeeltelijke reflecties om het breedste toepassings gebied te bieden.</span><span class="sxs-lookup"><span data-stu-id="b4512-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="b4512-108">Het centrale idee achter amplitude versterking is het verhogen van de kans op een gewenste uitkomst door een reeks reflecties uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="b4512-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="b4512-109">Deze reflecties draaien de begin status dichter naar de gewenste doel status, ook wel een gemarkeerde status genoemd.</span><span class="sxs-lookup"><span data-stu-id="b4512-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="b4512-110">Als de waarschijnlijkheid van het meten van de begin status een gemarkeerde status is, is $ \sin ^ 2 (\theta) $ en na het Toep assen van amplitude versterking $m $ keer de kans op succes wordt $ \sin ^ 2 ((2 min. + 1) \theta) $.</span><span class="sxs-lookup"><span data-stu-id="b4512-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="b4512-111">Dit betekent dat als $ \theta = \ PI/[2 (2n + 1)] $ voor een bepaalde waarde van $n $ de amplitude-versterking de kans kan verg Roten tot $100\\% $ na $n $ iteraties van de amplitude versterking.</span><span class="sxs-lookup"><span data-stu-id="b4512-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="b4512-112">Omdat $ \theta = \sin ^{-1}(\sqrt{\Pr (geslaagd)}) $ Dit betekent dat het aantal iteraties dat nodig is om een geslaagde deterministische uitkomst te verkrijgen, quadratically lager is dan het verwachte aantal dat nodig is om een gemarkeerde status niet-deterministisch te vinden met wille keurig proef.</span><span class="sxs-lookup"><span data-stu-id="b4512-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="b4512-113">Voor elke iteratie van de amplitude versterking moeten twee reflectie operatoren worden opgegeven.</span><span class="sxs-lookup"><span data-stu-id="b4512-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="b4512-114">In het bijzonder, als $Q $ de amplitude versterking is, en $P _0 $ een projector operator is op de eerste subruimte en $P _1 $ de projector op de gemarkeerde subruimte is, dan $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="b4512-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="b4512-115">Het is raadzaam dat een projector een Hermitian-operator is met eigenvalues $ + $1 en $0 $, en als resultaat $ (\boldone-2P_0) $ is unitary, omdat het eigenvalues heeft die wortel zijn van Unity (in dit geval $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="b4512-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="b4512-116">Bekijk bijvoorbeeld het geval van de zoek opdracht van Grover met de begin status $H ^ {\otimes n} \ket{0}$ en marked State $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket{0}\bra{0}H ^ {\otimes n} $ en $P _1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="b4512-117">In de meeste toepassingen van amplitude versterking $P _0 $ een projector is op een oorspronkelijke staat, wat betekent dat $P _0 = \boldone-2 \ Ket {\ psi} \ Bra {\ psi} $ voor sommige vector $ \ket{\psi} $; voor Oblivious amplitude amplication $P _0 $ bijvoorbeeld projecteren op veel Quantum Staten (dat wil zeggen, de multipliciteit van de $ + $1 eigenvalue van $P _0 $ groter is dan $1 $).</span><span class="sxs-lookup"><span data-stu-id="b4512-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="b4512-118">De logica achter de amplitude versterking volgt rechtstreeks van de eigen van $Q $.</span><span class="sxs-lookup"><span data-stu-id="b4512-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="b4512-119">Met name de eigenvectors van $Q $ dat de oorspronkelijke status geen ondersteuning voor nul heeft, kan worden weer gegeven als lineaire combi Naties van de $ + $1 eigenvectors van $P _0 $ en $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="b4512-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="b4512-120">Met name de eerste status voor de amplitude versterking (ervan uitgaande dat het een $ + $1 eigenvector van $P _0 $) kan worden geschreven als $ $ \ket{\psi} = \frac{-i}{\sqrt{2}} \left (e ^ {i\theta} \ Ket {\ psi_ +} + e ^ {-i\theta} \ Ket {\ psi_-} \ right), $ $ waarbij $ \ket{\psi_\pm } $ zijn eigenvectors van $Q $ met eigenvalues $e ^ {\pm 2i \ theta} $ en bieden alleen ondersteuning voor de $ + $1 eigenvectors van $P _0 $ en $P _1 $.</span><span class="sxs-lookup"><span data-stu-id="b4512-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="b4512-121">Het feit dat de eigenvalues zijn $e ^ {\pm i \theta} $ impliceert dat de operator $Q $ een draaiing uitvoert in een tweedimensionale subruimte die is opgegeven door de twee projectors en de begin toestand waarin de draai hoek $2 \ theta $ is.</span><span class="sxs-lookup"><span data-stu-id="b4512-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="b4512-122">Daarom moet u na $m $-iteraties van $Q $ de kans op succes is $ \sin ^ 2 ([2 min. + 1] \theta) $.</span><span class="sxs-lookup"><span data-stu-id="b4512-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="b4512-123">Een andere nuttige eigenschap die er uit komt, is dat de eigenvalue $ \theta $ direct gerelateerd is aan de waarschijnlijkheid dat de oorspronkelijke status zou worden gemarkeerd (in het geval waar $P _0 $ een projector is op alleen de begin toestand).</span><span class="sxs-lookup"><span data-stu-id="b4512-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="b4512-124">Omdat de eigenphases van $Q $ $2 \ theta = 2 \ Sin ^{-1}(\sqrt{\Pr (geslaagd)}) is, volgt $ het. als we fase schatting Toep assen op $Q $, kunnen we de kans op succes voor een unitary Quantum-procedure ontdekken.</span><span class="sxs-lookup"><span data-stu-id="b4512-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="b4512-125">Dit is handig omdat u quadratically minder toepassingen van de Quantum procedure nodig hebt om de kans op succes te ontdekken dan anders zou zijn.</span><span class="sxs-lookup"><span data-stu-id="b4512-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="b4512-126">Q # introduceert een amplitude versterking als een specialisatie van obliviouse amplitude versterking.</span><span class="sxs-lookup"><span data-stu-id="b4512-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="b4512-127">De Oblivious-amplitude versterking heeft deze moniker, omdat de projector op de eerste eigenspace geen projector hoeft te zijn op de oorspronkelijke staat.</span><span class="sxs-lookup"><span data-stu-id="b4512-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="b4512-128">In deze zin is het protocol Oblivious in de oorspronkelijke staat.</span><span class="sxs-lookup"><span data-stu-id="b4512-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="b4512-129">De belangrijkste toepassing van de Oblivious-amplitude versterking is in bepaalde *lineaire combi Naties van simulatie methoden van unitary* Hamiltonian, waarbij de oorspronkelijke status onbekend is, maar wordt Entangled met een ancilla-REGI ster in het simulatie protocol.</span><span class="sxs-lookup"><span data-stu-id="b4512-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="b4512-130">Als dit ancilla-REGI ster zou moeten worden gewaardeerd als een vaste waarde, zegt $0 $, dan passen die simulatie methoden de gewenste unitary-trans formatie toe op de resterende qubits (het systeem register genoemd).</span><span class="sxs-lookup"><span data-stu-id="b4512-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="b4512-131">Alle andere meet resultaten leiden echter tot storingen.</span><span class="sxs-lookup"><span data-stu-id="b4512-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="b4512-132">Met de Oblivious-amplitude versterking kan de kans op succes van deze meting worden verhoogd tot $100\\% $ met behulp van de bovenstaande reden.</span><span class="sxs-lookup"><span data-stu-id="b4512-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="b4512-133">Daarnaast komt de normale amplitude versterking overeen met de gevallen waarin het systeem register leeg is.</span><span class="sxs-lookup"><span data-stu-id="b4512-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="b4512-134">Daarom gebruikt Q # Oblivious amplitude versterking als de belangrijkste amplitude versterking subroutine.</span><span class="sxs-lookup"><span data-stu-id="b4512-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="b4512-135">De algemene routine (`AmpAmpObliviousByReflectionPhases`) heeft twee registers die `ancillaRegister` en `systemRegister`aanroepen.</span><span class="sxs-lookup"><span data-stu-id="b4512-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="b4512-136">Daarnaast worden er twee Oracle-waarden geaccepteerd voor de nood zakelijke reflecties.</span><span class="sxs-lookup"><span data-stu-id="b4512-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="b4512-137">De `ReflectionOracle` fungeert alleen op de `ancillaRegister` terwijl de `ObliviousOracle` gezamenlijk op beide registers reageert.</span><span class="sxs-lookup"><span data-stu-id="b4512-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="b4512-138">De invoer voor `ancillaRegister` moet worden geïnitialiseerd op een-1-eigenstate van de eerste reflectie operator $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="b4512-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="b4512-139">Normaal gesp roken wordt de status in de Oracle-voor bereiding berekend op basis van de berekening $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="b4512-140">In onze implementatie bestaat de `ancillaRegister` uit één Qubit (`flagQubit`) die de `stateOracle` en de rest van de gewenste ancillas regelt.</span><span class="sxs-lookup"><span data-stu-id="b4512-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="b4512-141">De `stateOracle` wordt toegepast wanneer de `flagQubit` $ \ket{1}$ is.</span><span class="sxs-lookup"><span data-stu-id="b4512-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="b4512-142">Een kan ook Oracle `StateOracle` en `ObliviousOracle` bieden in plaats van reflecties via een aanroep van `AmpAmpObliviousByOraclePhases`.</span><span class="sxs-lookup"><span data-stu-id="b4512-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="b4512-143">Zoals vermeld, is traditionele amplitude versterking slechts een speciaal geval van deze routines waarbij `ObliviousOracle` de identiteits operator is en er geen systeem qubits is (dat wil zeggen `systemRegister` is leeg).</span><span class="sxs-lookup"><span data-stu-id="b4512-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="b4512-144">Als u fasen wilt verkrijgen voor gedeeltelijke reflecties (bijvoorbeeld voor Grover Search), is de functie `AmpAmpPhasesStandard` beschikbaar.</span><span class="sxs-lookup"><span data-stu-id="b4512-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="b4512-145">Raadpleeg `DatabaseSearch.qs` voor een voor beeld van de implementatie van het Grover-algoritme.</span><span class="sxs-lookup"><span data-stu-id="b4512-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="b4512-146">We hebben de draaiings fasen met één Qubit gekoppeld aan de fasen van de reflectie operator zoals beschreven in het artikel met [G.H. low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="b4512-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="b4512-147">De vaste-punt fasen die worden gebruikt, worden in [Yoder, laag en Chuang](https://arxiv.org/abs/1409.3305) samen met de fasen in [laag, Yoder en Chuang](https://arxiv.org/abs/1603.03996)beschreven.</span><span class="sxs-lookup"><span data-stu-id="b4512-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="b4512-148">Voor achtergrond kunt u beginnen met [standaard amplitude versterking](https://arxiv.org/abs/quant-ph/0005055) en vervolgens overschakelen naar een inleiding tot [Obliviouse amplitude versterking](https://arxiv.org/abs/1312.1414) en finally-generalisaties die worden gepresenteerd in [laag en Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="b4512-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="b4512-149">Een goed overzicht van het hele gebied (zoals het is gekoppeld aan Hamiltonian simulatie) werd gegeven door [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="b4512-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="b4512-150">Kwantum Fourier-trans formatie</span><span class="sxs-lookup"><span data-stu-id="b4512-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="b4512-151">De Fourier-trans formatie is een fundamenteel hulp middel voor klassieke analyse en is net zo belang rijk voor Quantum berekeningen.</span><span class="sxs-lookup"><span data-stu-id="b4512-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="b4512-152">Daarnaast overschrijdt de efficiency van de *Quantum Fourier trans formatie* (QFT) ver wat mogelijk is op een klassieke machine, waardoor deze een van de eerste hulp middelen is die u kunt gebruiken bij het ontwerpen van een Quantum algoritme.</span><span class="sxs-lookup"><span data-stu-id="b4512-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="b4512-153">Als een geschatte generalisatie van de QFT bieden we de <xref:microsoft.quantum.canon.approximateqft> bewerking die verdere optimalisaties mogelijk maakt door rotaties te verwijderen die niet strikt nood zakelijk zijn voor de gewenste nauw keurigheid van de algoritmen.</span><span class="sxs-lookup"><span data-stu-id="b4512-153">As an approximate generalization of the QFT, we provide the <xref:microsoft.quantum.canon.approximateqft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="b4512-154">De geschatte QFT vereist de dyadic $Z $-rotation-bewerking <xref:microsoft.quantum.primitive.rfrac> en de <xref:microsoft.quantum.intrinsic.h> bewerking.</span><span class="sxs-lookup"><span data-stu-id="b4512-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:microsoft.quantum.primitive.rfrac> as well as the <xref:microsoft.quantum.intrinsic.h> operation.</span></span>
<span data-ttu-id="b4512-155">Er wordt van uitgegaan dat de invoer en uitvoer worden gecodeerd in big endian-code ring (de laagste bit-Qubit is aan de linkerkant, hetzelfde als [Ket-notatie](xref:microsoft.quantum.concepts.dirac)).</span><span class="sxs-lookup"><span data-stu-id="b4512-155">The input and output are assumed to be encoded in big endian encoding (lowest bit/qubit is on the left, same as [ket notation](xref:microsoft.quantum.concepts.dirac)).</span></span>
<span data-ttu-id="b4512-156">De benaderings parameter $a $ bepaalt het Pruning-niveau van de $Z $-rotations, dat wil zeggen $a \in [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="b4512-156">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="b4512-157">In dit geval worden alle $Z $-rotations $2 \ pi/2 ^ k $, waarbij $k > a $ worden verwijderd uit het QFT-circuit.</span><span class="sxs-lookup"><span data-stu-id="b4512-157">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="b4512-158">Het is bekend dat voor $k \ge \log_2 (n) + \log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="b4512-158">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="b4512-159">een kan $\\binden | \operatorname{QFT}-\operatorname{AQFT} \\| < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="b4512-159">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="b4512-160">Hier $\\| \cdot\\| $ is de operator norm die in dit geval de vierkantswortel van de grootste [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) van $ (\Operatorname{QFT}-\operatorname{AQFT}) (\Operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $ is.</span><span class="sxs-lookup"><span data-stu-id="b4512-160">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="b4512-161">Rekenkundig</span><span class="sxs-lookup"><span data-stu-id="b4512-161">Arithmetic</span></span> ##

<span data-ttu-id="b4512-162">Net zoals reken kundig een centrale rol speelt in de klassieke computing, is het ook indispensible bij Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="b4512-162">Just as arithmetic plays a central role in classical computing, it is also indispensible in quantum computing.</span></span>  <span data-ttu-id="b4512-163">Algoritmen, zoals het factor algoritme voor Shor, Quantum simulatie methoden en veel oracular-algoritmen zijn afhankelijk van samenhangende reken kundige bewerkingen.</span><span class="sxs-lookup"><span data-stu-id="b4512-163">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="b4512-164">De meeste benaderingen van reken kundige builds op Quantum adder-circuits.</span><span class="sxs-lookup"><span data-stu-id="b4512-164">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="b4512-165">De eenvoudigste adder neemt een klassieke invoer $b $ en voegt de waarde toe aan een Quantum status met een geheel getal $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-165">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="b4512-166">Wiskundig, de adder (die we $ \operatorname{Add} (b) $ voor klassieke invoer $b $) heeft de eigenschap die</span><span class="sxs-lookup"><span data-stu-id="b4512-166">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="b4512-167">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="b4512-167">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="b4512-168">$ $ Dit Basic adder-circuit is meer dan een incrementer dan een adder.</span><span class="sxs-lookup"><span data-stu-id="b4512-168">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="b4512-169">Het kan worden omgezet in een adder met twee Quantum invoer via $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ met behulp van $n $ beheerde toepassingen van adders van het formulier \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left (\operatorname{Add} (1) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (4) \right) \cdots \Lambda\_{a\_{n-1}} \left (\ operator {add} ({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} voor $n $-bitsinteger gehele getallen $a $ en $b $ en modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="b4512-169">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="b4512-170">U herinnert dat de notatie $ \Lambda\_x (A) $ $A verwijst naar de gecontroleerde versie van die bewerking met de Qubit $x $ as-besturings element.</span><span class="sxs-lookup"><span data-stu-id="b4512-170">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="b4512-171">Op dezelfde manier kunnen gespreide vermenigvuldiging (een modulaire vorm van essentieel voor het factor algoritme van de Shor) worden uitgevoerd met behulp van een vergelijk bare reeks beheerde toevoegingen: \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda\_{x\_0} \left (\operatorname{Add} (2 ^ 0 a) \right) \Lambda\_{a\_1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda\_{a\_2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda\_{x\_{ n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\\\ & = \ket{x}\ket{b + AX}.</span><span class="sxs-lookup"><span data-stu-id="b4512-171">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="b4512-172">\end{align} er is een subtlety met vermenigvuldiging op quantum computers waarvan u mogelijk merkt dat u de definitie van $ \operatorname{Mult} $ hierboven ziet.</span><span class="sxs-lookup"><span data-stu-id="b4512-172">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="b4512-173">In tegens telling tot de Quantum versie van dit circuit slaat u het product van de invoer op in een hulp registratie in plaats van in het invoer register.</span><span class="sxs-lookup"><span data-stu-id="b4512-173">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="b4512-174">In dit voor beeld wordt het REGI ster geïnitialiseerd met de waarde $b $, maar normaal gesp roken wordt de waarde nul ingedrukt.</span><span class="sxs-lookup"><span data-stu-id="b4512-174">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="b4512-175">Dit is nodig omdat in het algemeen geen multiplicative inverse is voor algemene $a $ en $x $.</span><span class="sxs-lookup"><span data-stu-id="b4512-175">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="b4512-176">Aangezien alle Quantum bewerkingen, het opslaan van metingen, kunnen worden teruggedraaid, moeten we voldoende informatie bewaren om de vermenigvuldiging ongedaan te maken.</span><span class="sxs-lookup"><span data-stu-id="b4512-176">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="b4512-177">Daarom wordt het resultaat opgeslagen in een andere matrix.</span><span class="sxs-lookup"><span data-stu-id="b4512-177">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="b4512-178">Dit leidt tot het opslaan van de uitvoer van een onomkeerbaare bewerking, zoals vermenigvuldigen, in een afzonderlijk REGI ster, ook wel bekend als ' Bennett, slag ' na Charlie Bennett,. Dit is een fundamenteel hulp middel in zowel omkeerbaar als Quantum Computing.</span><span class="sxs-lookup"><span data-stu-id="b4512-178">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="b4512-179">Er zijn veel Quantum circuits voorgesteld om toe te voegen en elke keer een ander toenemend aantal qubits (ruimte) en het aantal poort bewerkingen (tijd) dat is vereist.</span><span class="sxs-lookup"><span data-stu-id="b4512-179">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="b4512-180">We bekijken twee uiterst efficiënte adders beneden bekend als de Draper adder en de Beauregard Adder.</span><span class="sxs-lookup"><span data-stu-id="b4512-180">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="b4512-181">Draper Adder</span><span class="sxs-lookup"><span data-stu-id="b4512-181">Draper Adder</span></span> ###

<span data-ttu-id="b4512-182">De Draper-Adder is weliswaar een van de meest elegante Quantum adders, omdat deze direct de Quantum eigenschappen aanroept om de toevoeging uit te voeren.</span><span class="sxs-lookup"><span data-stu-id="b4512-182">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="b4512-183">Het inzicht achter de Draper Adder is dat de Fourier-trans formatie kan worden gebruikt om fase verschuivingen te vertalen naar een beetje verschuiving.</span><span class="sxs-lookup"><span data-stu-id="b4512-183">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="b4512-184">Daarna wordt een Fourier-trans formatie toegepast, waarbij de juiste fase verschuivingen worden toegepast en vervolgens de Fourier-trans formatie ongedaan wordt maakt, kunt u een adder implementeren.</span><span class="sxs-lookup"><span data-stu-id="b4512-184">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="b4512-185">In tegens telling tot veel andere adders die zijn voorgesteld, gebruikt de Draper-adder expliciet Quantum effecten die zijn geïntroduceerd via de Quantum-Fourier-trans formatie.</span><span class="sxs-lookup"><span data-stu-id="b4512-185">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="b4512-186">Het heeft geen natuurlijk klassiek tegen hanger.</span><span class="sxs-lookup"><span data-stu-id="b4512-186">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="b4512-187">De specifieke stappen van de Draper-adder worden hieronder gegeven.</span><span class="sxs-lookup"><span data-stu-id="b4512-187">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="b4512-188">Stel dat u met twee $n $-bits-Qubit de gehele getallen opslaat $a $ en $b $ vervolgens voor alle $a $ $ $ \operatorname{QFT}\ket{a} = \frac{1}{\sqrt{2 ^ n}} \sum\_{j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="b4512-188">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="b4512-189">$ $ Als we $ $ \ket{\phi\_k (a)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi a/2 ^ k} \ket{1} \right), $ $ daarna weer geven, kunt u zien dat $ $ algebra = \operatorname{QFT}\ket{a}\_1 (a)} \ket{\phi \otimes \ otimes \ket{\phi\_n (a)}.</span><span class="sxs-lookup"><span data-stu-id="b4512-189">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="b4512-190">$ $ Het pad naar het uitvoeren van een adder wordt vervolgens gewist nadat u hebt gezien dat de som van de invoer kan worden geschreven als $ $ \ket{a + b} = \operatorname{QFT} ^{-1}\ket{\phi\_1 (a + b)} \otimes \cdots \otimes \ket{\phi\_n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="b4512-190">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="b4512-191">$ $ De gehele getallen $b $ en $a $ kunnen vervolgens worden toegevoegd door de controle van de gecontroleerde fase voor elk van de qubits in de ontleding uit te voeren met de bits van $b $ as-besturings elementen.</span><span class="sxs-lookup"><span data-stu-id="b4512-191">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="b4512-192">Deze uitbrei ding kan verder worden vereenvoudigd door te voor komen dat een geheel getal $j $ en reëel getal $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-192">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="b4512-193">Dit komt doordat als u $360 ^ {\circ} $ graden ($ 2 \ pi $ radialen) in een cirkel roteert, u uiteindelijk precies op de slag gaat.</span><span class="sxs-lookup"><span data-stu-id="b4512-193">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="b4512-194">Het enige belang rijk deel van $x $ voor $e ^ {i2\pi x} $ is daarom het gedeelte van $x $.</span><span class="sxs-lookup"><span data-stu-id="b4512-194">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="b4512-195">In het bijzonder, als we een binaire uitbrei ding hebben van het formulier $x = y +0. x\_0x\_2 \ ldots x\_n $ vervolgens $e ^ {i2\pi x} = e ^ {i2\pi (0. x\_0x\_2 \ ldots x\_{n-1})} $ en dus $ $ \ket{\ Phi\_k (a + b)} = \frac{1}{\sqrt{2}} \left (\ket{0} + e ^ {i2\pi [a/2 ^ k +0. b\_k\ldots b\_1]} \ket{1} \right). $ $ Dit betekent dat als we een aanvulling uitvoeren op de tensor factoren in de uitbrei ding van de Fourier-trans formatie van $ \ket{a} $ dan wordt het aantal rotaties kleiner naarmate $k $ afneemt.</span><span class="sxs-lookup"><span data-stu-id="b4512-195">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="b4512-196">Hierdoor wordt het aantal Quantum-Gates dat nodig is in de adder aanzienlijk verminderd.</span><span class="sxs-lookup"><span data-stu-id="b4512-196">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="b4512-197">We vermelden de Fourier-trans formatie, de toevoeging van de fase en de inverse Fourier-transformatie stappen die bestaan uit de Draper adder als $ \operatorname{QFT} ^{-1} \left (\phi\\\!\operatorname{ADD}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-197">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="b4512-198">Hieronder vindt u een Quantum circuit dat deze vereenvoudiging gebruikt om het hele proces te implementeren.</span><span class="sxs-lookup"><span data-stu-id="b4512-198">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Draper adder weer gegeven als circuit diagram](~/media/draper.png)

<span data-ttu-id="b4512-200">Elke beheerde $e ^ {I2 \ Pi/k} in het circuit verwijst naar een poort met gecontroleerde fasen.</span><span class="sxs-lookup"><span data-stu-id="b4512-200">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="b4512-201">Dergelijke Gates hebben de eigenschap op het paar qubits waarop ze handelen, $ \ket{00}\mapsto \ket{00}$, \ket{11}\mapsto e ^ {I2 \ Pi/k} \ Ket{11}$.</span><span class="sxs-lookup"><span data-stu-id="b4512-201">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="b4512-202">Met dit circuit kunnen we toevoegingen uitvoeren met behulp van geen extra qubits die nodig zijn om de invoer en de uitvoer op te slaan.</span><span class="sxs-lookup"><span data-stu-id="b4512-202">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="b4512-203">Beauregard Adder</span><span class="sxs-lookup"><span data-stu-id="b4512-203">Beauregard Adder</span></span> ###

<span data-ttu-id="b4512-204">De Beauregard Adder is een Quantum modulaire adder die gebruikmaakt van de Draper adder om het toevoegen van modulo $N $ uit te voeren voor een wille keurige waarde, positief geheel getal $N $.</span><span class="sxs-lookup"><span data-stu-id="b4512-204">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="b4512-205">De significantie van de Quantum modulaire adders, zoals de Beauregard adder, is in grote mate gepaard met hun gebruik in de modulaire machtsverheffen-stap binnen het Shor-algoritme voor factories.</span><span class="sxs-lookup"><span data-stu-id="b4512-205">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="b4512-206">Een Quantum modulaire adder heeft de volgende actie voor de Quantum invoer $ \ket{b} $ en de klassieke invoer $a $, waarbij $a $ en $b $ zijn beloofd als integers rest $N $, wat betekent dat ze in het interval $ [0, \ldots, N-1] $ liggen.</span><span class="sxs-lookup"><span data-stu-id="b4512-206">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="b4512-207">$ $ \ket{b}\rightarrow \ket{b + a \Text{mod} N} = \begin{cases} \ket{b + a}, & b + a < N\\\\ \ket{b + a-N}, & (b + a) \ge N \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="b4512-207">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="b4512-208">De Beauregard adder maakt gebruik van de Draper adder of meer specifiek $ \phi\\\!\operatorname{ADD} $, om $a $ en $b $ in te voegen.</span><span class="sxs-lookup"><span data-stu-id="b4512-208">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="b4512-209">Vervolgens wordt dezelfde bewerking gebruikt om te bepalen of $a + b < N $ wordt afgetrokken van $N $ en te testen als $a + b-N < 0 $.</span><span class="sxs-lookup"><span data-stu-id="b4512-209">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="b4512-210">Het circuit slaat deze informatie op in een bijkomende Qubit en voegt $N $ terug het REGI ster toe als $a + b < N $.</span><span class="sxs-lookup"><span data-stu-id="b4512-210">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="b4512-211">Vervolgens wordt het systeem afgesloten door de computer te ontlasten (deze stap is nodig om ervoor te zorgen dat de ancilla na het aanroepen van de adder niet meer kunnen worden toegewezen).</span><span class="sxs-lookup"><span data-stu-id="b4512-211">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="b4512-212">Het circuit voor de Beauregard adder wordt hieronder gegeven.</span><span class="sxs-lookup"><span data-stu-id="b4512-212">The circuit for the Beauregard adder is given below.</span></span>

![Beauregard adder weer gegeven als circuit diagram](~/media/beau.png)

<span data-ttu-id="b4512-214">Hier heeft de poort $ \Phi\\\!\operatorname{ADD} $ hetzelfde als $ \Phi\\\!\operatorname{ADD} $, met uitzonde ring van de invoer in deze context, in plaats van Quantum.</span><span class="sxs-lookup"><span data-stu-id="b4512-214">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="b4512-215">Hierdoor kunnen de bewaakte fasen in $ \Phi\\\!\operatorname{ADD} $ worden vervangen door Phase Gates die vervolgens samen worden gecompileerd in minder bewerkingen om zowel het aantal qubits als het aantal poorten dat nodig is voor de adder te verminderen.</span><span class="sxs-lookup"><span data-stu-id="b4512-215">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="b4512-216">Ga voor meer informatie naar [M. Roetteler, th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) en [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="b4512-216">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="b4512-217">Schatting van Quantum fase</span><span class="sxs-lookup"><span data-stu-id="b4512-217">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="b4512-218">Een bijzonder belang rijke toepassing van de Quantum Fourier Transform is het leren van de eigenvalues van unitary-Opera Tors, een probleem bekend als *fase schatting*.</span><span class="sxs-lookup"><span data-stu-id="b4512-218">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation*.</span></span>
<span data-ttu-id="b4512-219">Houd rekening met een unitary $U $ en een status $ \ket{\phi} $, waardoor $ \ket{\phi} $ een eigenstate van $U $ is met onbekende eigenvalue $ \phi $, \begin{Equation} U\ket {\ Phi} = \phi\ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="b4512-219">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="b4512-220">\end{Equation} als we alleen toegang hebben tot $U $ als Oracle, kunnen we de fase $ \phi $ leren door gebruik te maken van de $Z $-rotaties die zijn toegepast op het doel van een beheerde bewerking die op het besturings element wordt door gegeven.</span><span class="sxs-lookup"><span data-stu-id="b4512-220">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="b4512-221">Stel dat $V $ een beheerde toepassing is van $U $, zodanig dat \begin{align} V (\ket{0} \otimes \ket{\phi}) & = \ket{0} \otimes \ket{\phi} \\\\ \textrm{en} V (\ket{1} \otimes \ket{\phi}) & = e ^ {i \phi} \ket{1}  \otimes \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="b4512-221">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="b4512-222">\end{align} vervolgens op lineariteit, \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{(\ket{0} \otimes \ket{\phi}) + e ^ {i \phi} (\ket{1} \otimes \ket{\phi})} {\sqrt{2}}.</span><span class="sxs-lookup"><span data-stu-id="b4512-222">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="b4512-223">\end{align} we kunnen voor waarden verzamelen om erachter te komen dat \begin{align} V (\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e ^ {i \phi} \ket{1}} {\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1 (\phi) \ket{+}) \otimes \ket{\phi} , \end{align} waarbij $R _1 $ het unitary is dat door de <xref:microsoft.quantum.intrinsic.r1> bewerking wordt toegepast.</span><span class="sxs-lookup"><span data-stu-id="b4512-223">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:microsoft.quantum.intrinsic.r1> operation.</span></span>
<span data-ttu-id="b4512-224">Anders is het effect van het Toep assen van $V $ precies hetzelfde als het Toep assen van $R _1 $ met een onbekende hoek, zelfs als we alleen toegang hebben tot $V $ als Oracle.</span><span class="sxs-lookup"><span data-stu-id="b4512-224">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="b4512-225">Voor de rest van deze bespreking bespreken we bijvoorbeeld de fase schatting in termen van $R _1 (\phi) $, die we implementeren met behulp van de zogenaamde *fase kickback*.</span><span class="sxs-lookup"><span data-stu-id="b4512-225">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback*.</span></span>

<span data-ttu-id="b4512-226">Omdat het besturings element en het doel register untangled na dit proces blijven, kunnen we $ \ket{\phi} $ opnieuw gebruiken als het doel van een beheerde toepassing van $U ^ $2 om een tweede besturings element voor een Qubit in de status $R _1 (2 \phi) \ket{+} $ voor te bereiden.</span><span class="sxs-lookup"><span data-stu-id="b4512-226">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="b4512-227">Op deze manier kunnen we een REGI ster ontvangen van het formulier \begin{align} \ket{\psi} & = \sum_{j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\\\ & \propto \bigotimes_{j = 0} ^ {n} \left (\ket{0} + \exp (i 2 ^ {j} \phi) \ket{1}\right) @no__ t_4_ \\ & \propto \sum_{k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align} waarbij $n $ het aantal bits nauw keurig is dat we nodig hebben en waar we ${} \propto {}$ hebben gebruikt om aan te geven dat de normalisatie factor $ is onderdrukt 1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="b4512-227">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="b4512-228">Als we ervan uitgaan dat $ \phi = 2 \pi p/2 ^ k $ voor een geheel getal $p $, herkennen we dit als $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, waarbij $p _J $ de $j ^ {\textrm{th}} $ bits $2 \pi \phi $ is.</span><span class="sxs-lookup"><span data-stu-id="b4512-228">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="b4512-229">Wanneer de adjoint van de Quantum Fourier-trans formatie wordt toegepast, krijgen we daarom de binaire weer gave van de fase die is gecodeerd als een Quantum status.</span><span class="sxs-lookup"><span data-stu-id="b4512-229">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="b4512-230">In Q # wordt dit geïmplementeerd door de <xref:microsoft.quantum.characterization.quantumphaseestimation> bewerking, die een <xref:microsoft.quantum.oracles.discreteoracle> implementatie van de toepassing van $U ^ m $ maakt, als een functie van positieve gehele getallen $m $.</span><span class="sxs-lookup"><span data-stu-id="b4512-230">In Q#, this is implemented by the <xref:microsoft.quantum.characterization.quantumphaseestimation> operation, which takes a <xref:microsoft.quantum.oracles.discreteoracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
