---
title: 'Toepassingen in de standaard bibliotheken van Q #'
description: Meer informatie over twee fundamentele toepassingen in de Quantum Computing-Hamiltonian simulatie en het zoek algoritme van Shor.
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: b7c46b634c6d691c067c0dd995301395408c85ca
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: nl-NL
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907219"
---
# <a name="applications"></a><span data-ttu-id="5a319-103">Toepassingen</span><span class="sxs-lookup"><span data-stu-id="5a319-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="5a319-104">Hamiltoniaanse simulatie</span><span class="sxs-lookup"><span data-stu-id="5a319-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="5a319-105">De simulatie van Quantum systemen is een van de meest interessante toepassingen van Quantum berekeningen.</span><span class="sxs-lookup"><span data-stu-id="5a319-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="5a319-106">Op een klassieke computer, de moeite van het simuleren van Quantum-garages, in het algemeen, wordt geschaald met de dimensie $N $ van de weer gave van de status vector.</span><span class="sxs-lookup"><span data-stu-id="5a319-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="5a319-107">Aangezien deze weer gave exponentieel toeneemt met het aantal $n $ qubits $N = 2 ^ n $, een Trait die ook wel bekend staat als de term [dimensionaliteit](xref:microsoft.quantum.concepts.multiple-qubits), kan de Quantum simulatie op klassieke hardware ongemoeid zijn.</span><span class="sxs-lookup"><span data-stu-id="5a319-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="5a319-108">De situatie kan echter zeer verschillen op Quantum hardware.</span><span class="sxs-lookup"><span data-stu-id="5a319-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="5a319-109">De meest voorkomende variatie van de Quantum simulatie wordt het tijd onafhankelijke Hamiltonian simulatie probleem genoemd.</span><span class="sxs-lookup"><span data-stu-id="5a319-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="5a319-110">Er wordt een beschrijving gegeven van het systeem Hamiltonian $H $, een Hermitian-matrix en een initiële Quantum status $ \ket{\psi (0)} $ die in een bepaalde basis is gecodeerd op $n $ qubits op een quantum computer.</span><span class="sxs-lookup"><span data-stu-id="5a319-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="5a319-111">Als Quantum statussen in gesloten systemen ontwikkelen onder de Schrödinger-vergelijking $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ het doel is om de unitary time-evolutie operator te implementeren $U (t) = e ^ {-iHt} $ op een bepaalde vaste tijd $t $ , waarbij $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ de vergelijking van Schrödinger opgelost.</span><span class="sxs-lookup"><span data-stu-id="5a319-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="5a319-112">Vergelijkbaar met het tijdgebonden Hamiltonian simulatie probleem wordt dezelfde vergelijking opgelost, maar met $H (t) $ nu een functie van tijd.</span><span class="sxs-lookup"><span data-stu-id="5a319-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="5a319-113">Hamiltonian simulatie is een belang rijk onderdeel van vele andere Quantum simulatie problemen en oplossingen voor het simulatie probleem van Hamiltonian zijn algoritmen die een reeks primitieve Quantum-Gates beschrijven voor het syntheseen van een benadering van unitary $ \tilde{U} $ met fout $\\| \tilde{U}-U (t)\\| \le \epsilon $ in de [Spectral-norm](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="5a319-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="5a319-114">De complexiteit van deze algoritmen is sterk afhankelijk van de manier waarop een quantum computer toegang heeft tot een beschrijving van de Hamiltonian van de interesses.</span><span class="sxs-lookup"><span data-stu-id="5a319-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="5a319-115">Als $H $ op $n $ qubits moet worden aangeboden als een lijst met $2 ^ n \times 2 ^ n $ cijfers, één voor elk matrix element, zou de gegevens echter al exponentiële tijd nodig hebben, bijvoorbeeld in het ergste geval.</span><span class="sxs-lookup"><span data-stu-id="5a319-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="5a319-116">In het beste geval kan een van de voor keur uitgaan van de toegang tot een Black Box-unitary die $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ het probleem op een pase manier oplost.</span><span class="sxs-lookup"><span data-stu-id="5a319-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="5a319-117">Geen van deze invoer modellen is bijzonder interessant, omdat het niet beter is dan klassieke benaderingen, en de laatste als zwarte doos de primitieve poort complexiteit van de implementatie verbergen. Dit kan exponentieel zijn in het aantal qubits.</span><span class="sxs-lookup"><span data-stu-id="5a319-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="5a319-118">Beschrijvingen van Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="5a319-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="5a319-119">Aanvullende veronderstellingen van de indeling van de invoer zijn daarom vereist.</span><span class="sxs-lookup"><span data-stu-id="5a319-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="5a319-120">Er moet een nauw keurige balans zijn tussen invoer modellen die voldoende beschrijvend zijn om interessante Hamiltonians te omvatten, zoals die voor realistische fysieke systemen of interessante verwerkings problemen, en invoer modellen die voldoende beperkend zijn efficiënt te implementeren op een quantum computer.</span><span class="sxs-lookup"><span data-stu-id="5a319-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="5a319-121">Er is mogelijk een verscheidenheid aan niet-trivial invoer model gevonden in de literatuur en het bereik is van Quantum tot klassiek.</span><span class="sxs-lookup"><span data-stu-id="5a319-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="5a319-122">Als voor beelden van Quantum invoer modellen, wordt in de [Hamiltonian-simulatie op basis](http://www.nature.com/articles/s41534-017-0013-7) van een voor beeld uitgegaan van Black-Box-toegang tot Quantum bewerkingen die kopieën van een dichtheids matrix $ \rho $ maken, die de Hamiltonian $H $ zijn.</span><span class="sxs-lookup"><span data-stu-id="5a319-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="5a319-123">In het [unitary-toegangs model](https://arxiv.org/abs/1202.5822) is er een van de Hamiltonian in plaats daarvan een som van unitaries $ $ \begin{align} H & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j, \end{align} $ $, waarbij $a\_j > 0 $ coëfficiënten zijn en $ \hat{U}\_j $ unitaries zijn.</span><span class="sxs-lookup"><span data-stu-id="5a319-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="5a319-124">Er wordt van uitgegaan dat één Black-Box-toegang heeft tot de unitary Oracle $V = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ waarmee de gewenste $ \hat{U}\_j $ wordt geselecteerd. en de Oracle $A \ket{0}= \sum ^ {d-1}\_{j = 0} \sqrt{a\_j/\ Sum ^ {d-1}\_{k = 0} \alpha\_j} \ket{j} $ waarmee een Quantum status code ring wordt gemaakt.</span><span class="sxs-lookup"><span data-stu-id="5a319-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="5a319-125">In het geval van een [sparse Hamiltoniane-simulatie](https://arxiv.org/abs/quant-ph/0301023)wordt ervan uitgegaan dat de Hamiltonian een Sparse matrix is met alleen $d = \mathcal{O} (\Text{polylog} (N)) $ niet-nul-element in elke rij.</span><span class="sxs-lookup"><span data-stu-id="5a319-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="5a319-126">Daarnaast wordt ervan uitgegaan dat het bestaan van efficiënte Quantum circuits die de locatie van deze niet-nul elementen, en de waarden ervan, worden uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="5a319-127">De complexiteit van [Hamiltonian-simulatie algoritmen](xref:microsoft.quantum.more-information) wordt geëvalueerd in termen van het aantal query's naar deze zwarte vakjes en de primitieve poort complexiteit is dan afhankelijk van de moeilijkheids graad van de implementatie van deze zwarte vakken.</span><span class="sxs-lookup"><span data-stu-id="5a319-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="5a319-128">De Big-O-notatie wordt meestal gebruikt voor het beschrijven van de complexiteits schaal van algoritmen.</span><span class="sxs-lookup"><span data-stu-id="5a319-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="5a319-129">Als er twee echte functies $f, g $, de expressie $g (x) = \mathcal{O} (f (x)) $ betekent dat er een absolute positieve constante is $x\_0, c > 0 $ zodanig dat $g (x) \le c f (x) $ voor alle $x \ge x\_$0.</span><span class="sxs-lookup"><span data-stu-id="5a319-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="5a319-130">In de meeste praktische toepassingen die op een quantum computer moeten worden geïmplementeerd, moeten deze zwarte vakken efficiënt kunnen worden geïmplementeerd, dat wil zeggen met $ \mathcal{O} (\Text{polylog} (N)) $ primitieve Quantum-poorten.</span><span class="sxs-lookup"><span data-stu-id="5a319-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="5a319-131">Een sterkere, efficiëntere simulable Hamiltonians moet een voldoende sparse klassieke beschrijving hebben.</span><span class="sxs-lookup"><span data-stu-id="5a319-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="5a319-132">In een dergelijke formulering wordt ervan uitgegaan dat de Hamiltonian is opgetrokken in een som van Hermitian-onderdelen $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="5a319-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="5a319-133">\end{align} $ $ er wordt van uitgegaan dat elk deel, een Hamiltonian $H\_j $, gemakkelijk te simuleren is.</span><span class="sxs-lookup"><span data-stu-id="5a319-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="5a319-134">Dit betekent dat de unitary $e ^ {-iH\_j t} $ voor elke tijd $t $ kan worden geïmplementeerd met $ \mathcal{O} (1) $ primitieve Quantum Gates.</span><span class="sxs-lookup"><span data-stu-id="5a319-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="5a319-135">Dit geldt bijvoorbeeld in het speciale geval waarbij elke $H\_j $ lokale Pauli-Opera Tors is, wat inhoudt dat ze van tensor-producten van $ \mathcal{O} (1) $ niet-identiteits Pauli Opera tors die op ruimtelijke dichte qubits handelen.</span><span class="sxs-lookup"><span data-stu-id="5a319-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="5a319-136">Dit model is met name van toepassing op fysieke systemen met een begrensde en lokale interactie, omdat het aantal voor waarden is $d = \mathcal{O} (\Text{polylog} (N)) $ en mogelijk duidelijk kan worden geschreven, d.w.z. in een polynoom.</span><span class="sxs-lookup"><span data-stu-id="5a319-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="5a319-137">Hamiltonians die in een som van delen afbreken, kunnen worden beschreven met behulp van de Dynamical Generator representatie bibliotheek.</span><span class="sxs-lookup"><span data-stu-id="5a319-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="5a319-138">Zie de sectie weer gave van dynamische generator in [gegevens structuren](xref:microsoft.quantum.libraries.data-structures)voor meer informatie.</span><span class="sxs-lookup"><span data-stu-id="5a319-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="5a319-139">Simulatie algoritmen</span><span class="sxs-lookup"><span data-stu-id="5a319-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="5a319-140">Een Quantum simulatie algoritme zet een opgegeven beschrijving van een Hamiltonian om in een reeks primitieve Quantum-poorten die als geheel een tijdige evolutie van Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="5a319-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="5a319-141">In het speciale geval waarbij de Hamiltonian wordt ontsteld in een som van Hermitian-onderdelen, is de Trotter-Suzuki-ontleding een bijzonder eenvoudig en intuïtief algoritme voor het simuleren van Hamiltonians die een som van Hermitian onderdelen afbreken.</span><span class="sxs-lookup"><span data-stu-id="5a319-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="5a319-142">Bijvoorbeeld, een first-order integrator van deze familie heeft ongeveer $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cdots e ^ {-iH\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j\\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $ met behulp van een product van $r d $-voor waarden.</span><span class="sxs-lookup"><span data-stu-id="5a319-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="5a319-143">Toepassingen van het simulatie algoritme Trotter-Suzuki worden in de voor beelden besproken.</span><span class="sxs-lookup"><span data-stu-id="5a319-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="5a319-144">Zie het [ **SimpleIsing** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple)-voor beeld voor het Ising-model met alleen de intrinsieke bewerkingen van elke doel computer.</span><span class="sxs-lookup"><span data-stu-id="5a319-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="5a319-145">Raadpleeg het [ **IsingTrotter** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution)-voor beeld voor het Ising-model met behulp van de Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="5a319-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="5a319-146">Zie het [ **simulatie** voorbeeld](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)van de Trotter-Suzuki voor moleculaire water stof met behulp van de beheer structuur van de bibliotheek.</span><span class="sxs-lookup"><span data-stu-id="5a319-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="5a319-147">In veel gevallen willen we het simulatie algoritme implementeren, maar zijn ze niet geïnteresseerd in de details van de implementatie.</span><span class="sxs-lookup"><span data-stu-id="5a319-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="5a319-148">Bijvoorbeeld, de tweede order integrator benadert $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/2R} e ^ {-iH\_1 t/2R} \cdots e ^ {-iH\_{d-1} t/2R} e ^ {-iH\_{d-1} t/2R} \cdots e ^ {-iH\_1 t/2R} e ^ {-iH\_0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), \end{align} $ $ met behulp van een product van $2rd $-voor waarden.</span><span class="sxs-lookup"><span data-stu-id="5a319-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="5a319-149">Grotere orders hebben zelfs nog meer voor waarden en geoptimaliseerde varianten kunnen een zeer niet-oplopende volg orde van de exponentiëlen vereisen.</span><span class="sxs-lookup"><span data-stu-id="5a319-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="5a319-150">Andere geavanceerde algoritmen kunnen ook het gebruik van ancilla qubits in tussenliggende stappen omvatten.</span><span class="sxs-lookup"><span data-stu-id="5a319-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="5a319-151">Daarom kunnen simulatie algoritmen in de Canon worden gepakketd als het door de gebruiker gedefinieerde type</span><span class="sxs-lookup"><span data-stu-id="5a319-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="5a319-152">De eerste para meter `Double` is de tijd van simulatie, de tweede para meter `EvolutionGenerator`, die wordt behandeld in de sectie dynamische Generator weergave van [gegevens structuren](xref:microsoft.quantum.libraries.data-structures), is een klassieke beschrijving van een tijdgebonden Hamiltonian die is verpakt met instructies over hoe elke term in de Hamiltonian kan worden gesimuleerd met een Quantum circuit.</span><span class="sxs-lookup"><span data-stu-id="5a319-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="5a319-153">De typen van dit formulier benaderen de unitary-bewerking $e ^ {-iHt} $ op de derde para meter `Qubit[]`. Dit is de kassa waarin de Quantum status van het gesimuleerde systeem wordt opgeslagen.</span><span class="sxs-lookup"><span data-stu-id="5a319-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="5a319-154">Net als de tijds afhankelijke case definiëren we een door de gebruiker gedefinieerd type met een `EvolutionSchedule` type, dat een klassieke beschrijving is van een tijdgebonden Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="5a319-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="5a319-155">Als voor beeld kan de ontleding van de Trotter-Suzuki worden aangeroepen met behulp van de volgende Canon-functies, met para meters `trotterStepSize` de duur van simulatie in elke exponentiële waarde te wijzigen en `trotterOrder` voor de volg orde van de gewenste integrator.</span><span class="sxs-lookup"><span data-stu-id="5a319-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="5a319-156">Toepassingen van de simulatie bibliotheek worden in de voor beelden besproken.</span><span class="sxs-lookup"><span data-stu-id="5a319-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="5a319-157">Zie het [ **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation)-voor beeld voor een fase-schatting in het Ising-model met behulp van `SimulationAlgorithm`.</span><span class="sxs-lookup"><span data-stu-id="5a319-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="5a319-158">Raadpleeg het [ **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic)-voor beeld voor Adiabatic-status voorbereiding in het Ising-model met behulp van `TimeDependentSimulationAlgorithm`.</span><span class="sxs-lookup"><span data-stu-id="5a319-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="5a319-159">Schatting van Adiabatic-status voorbereiding & fase</span><span class="sxs-lookup"><span data-stu-id="5a319-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="5a319-160">Een gemeen schappelijke toepassing van Hamiltonian simulatie is Adiabatic status voorbereiding.</span><span class="sxs-lookup"><span data-stu-id="5a319-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="5a319-161">Hier wordt een van de twee Hamiltonians-$H\_{\Text{start}} $ en $H\_{\Text{end}} $, en een Quantum status $ \ket{\psi (0)} $ die een grond staat is van de start Hamiltonian $H\_{\Text{start}} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="5a319-162">Normaal gesp roken wordt $H\_{\Text{start}} $ gekozen, waardoor $ \ket{\psi (0)} $ gemakkelijk kan worden voor bereid op basis van een reken kundige status $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="5a319-163">Door interpolatie tussen deze Hamiltonians in het tijdgebonden simulatie probleem voldoende langzaam te interpoleren, is het mogelijk om, met een hoge waarschijnlijkheid, in een grond staat van de uiteindelijke Hamiltonian $H\_{\Text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="5a319-164">Het voorbereiden van een goede benadering van Hamiltonian-grond staat kan op deze manier door gaan door op tijd afhankelijke Hamiltonian simulatie algoritmen als subroutine aan te roepen, andere conceptuele verschillende benaderingen zoals de variatie van de Quantum eigensolver zijn mogelijk.</span><span class="sxs-lookup"><span data-stu-id="5a319-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="5a319-165">Maar een andere toepassing alomtegenwoordige in quantum chemie is het schatten van de bodem status energie van Hamiltonians die de tussenliggende stappen van chemische reactie vertegenwoordigen.</span><span class="sxs-lookup"><span data-stu-id="5a319-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="5a319-166">Een dergelijke regeling kan bijvoorbeeld afhankelijk zijn van de voor bereiding van de Adiabatic-status om de bodem status te maken en vervolgens een tijdgebonden Hamiltonian-simulatie op te nemen als een subroutine in Phase-schattings karakteisatie om deze energie te extra heren met een beperkte fout en de kans op geslaagde pogingen.</span><span class="sxs-lookup"><span data-stu-id="5a319-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="5a319-167">Bij het samen stellen van simulatie algoritmen als de door de gebruiker gedefinieerde typen `SimulationAlgorithm` en `TimeDependentSimulationAlgorithm` kunnen we hun functionaliteit in meer geavanceerde Quantum algoritmen opnemen.</span><span class="sxs-lookup"><span data-stu-id="5a319-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="5a319-168">Hiermee wordt u gewend om hetzelfde te doen voor deze veelgebruikte subroutines.</span><span class="sxs-lookup"><span data-stu-id="5a319-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="5a319-169">We definiëren daarom de handige functie</span><span class="sxs-lookup"><span data-stu-id="5a319-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="5a319-170">Hiermee wordt een unitary-bewerking geretourneerd waarmee alle stappen van de voor bereiding van Adiabatic-status worden geïmplementeerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="5a319-171">De eerste para meter `interpolatedTime` definieert het tijdstip waarop we lineair interpoleren tussen de start Hamiltonian die worden beschreven door de tweede para meter `evolutionGeneratorStart` en de end Hamiltonian die wordt beschreven door de derde para meter `evolutionGeneratorEnd`.</span><span class="sxs-lookup"><span data-stu-id="5a319-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="5a319-172">Met de vierde para meter `timeDependentSimulationAlgorithm` wordt de keuze van simulatie algoritme gemaakt.</span><span class="sxs-lookup"><span data-stu-id="5a319-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="5a319-173">Houd er rekening mee dat als `interpolatedTime` lang genoeg is, een aanvankelijke toestand van de Hamiltonian gedurende de gehele duur van een tijdgebonden simulatie een onmiddellijke bodem status heeft en eindigt op de bodem status van de eind Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="5a319-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="5a319-174">We definiëren ook een nuttige bewerking die automatisch alle stappen van een typische quantum chemie-experiment uitvoert.</span><span class="sxs-lookup"><span data-stu-id="5a319-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="5a319-175">We hebben bijvoorbeeld het volgende, waarmee een energie schatting wordt geretourneerd van de status die is geproduceerd door de voor bereiding van de Adiabatic-status:</span><span class="sxs-lookup"><span data-stu-id="5a319-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="5a319-176">`nQubits` is het aantal qubits dat wordt gebruikt om de initiële Quantum status te coderen.</span><span class="sxs-lookup"><span data-stu-id="5a319-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="5a319-177">`statePrepUnitary` bereidt de start status voor op basis van de berekening $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="5a319-178">`adiabaticUnitary` is de unitary-bewerking die de voor bereiding van Adiabatic-status implementeert, zoals geproduceerd door de functie `InterpolatedEvolution`.</span><span class="sxs-lookup"><span data-stu-id="5a319-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="5a319-179">`qpeUnitary` is de unitary-bewerking die wordt gebruikt voor het uitvoeren van een fase schatting voor de resulterende Quantum status.</span><span class="sxs-lookup"><span data-stu-id="5a319-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="5a319-180">`phaseEstAlgorithm` is ons keuze-algoritme voor fase schatting.</span><span class="sxs-lookup"><span data-stu-id="5a319-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="5a319-181">Toepassingen van de Adiabatic-status voorbereiding worden behandeld in de voor beelden.</span><span class="sxs-lookup"><span data-stu-id="5a319-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="5a319-182">Raadpleeg het [ **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic)-voor beeld voor het Ising-model met behulp van een hand matige implementatie van Adiabatic-status voorbereiding versus het gebruik van de functie `AdiabaticEvolution`.</span><span class="sxs-lookup"><span data-stu-id="5a319-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="5a319-183">Raadpleeg het [ **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation)-voor beeld voor fase schatting en Adiabatic-status voorbereiding in het Ising-model.</span><span class="sxs-lookup"><span data-stu-id="5a319-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="5a319-184">De [simulatie van moleculaire water stof](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is een interessant en beknopt voor beeld.</span><span class="sxs-lookup"><span data-stu-id="5a319-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="5a319-185">De model-en experimentele resultaten die in [O'Malley et. al](https://arxiv.org/abs/1512.06860) zijn gerapporteerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="5a319-186">vereist alleen Pauli-matrices en heeft de vorm $ \hat H = g\_{0}I\_0I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="5a319-187">Dit is een effectief Hamiltonian waarvoor slechts 2 qubits nodig is, waarbij de constanten $g $ worden berekend op basis van de afstand $R $ tussen de twee water stof atomen.</span><span class="sxs-lookup"><span data-stu-id="5a319-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="5a319-188">Met Canon functions worden de Paul-functies geconverteerd naar unitaries en vervolgens over korte Peri Oden gegroeid met behulp van de Trotter-Suzuki-ontleding.</span><span class="sxs-lookup"><span data-stu-id="5a319-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="5a319-189">Een goede benadering van $H de _2 $ aarde kan worden gemaakt zonder gebruik te maken van Adiabatic-status voorbereiding, waardoor de grond staats energie direct kan worden gevonden door de fase-schatting van de Canon te gebruiken.</span><span class="sxs-lookup"><span data-stu-id="5a319-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="5a319-190">Algoritme van Shor</span><span class="sxs-lookup"><span data-stu-id="5a319-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="5a319-191">Het Shor-algoritme is een van de belangrijkste ontwikkelingen in de Quantum Computing, omdat blijkt dat quantum computers kunnen worden gebruikt voor het oplossen van belang rijke, op dit moment klassieke problemen.</span><span class="sxs-lookup"><span data-stu-id="5a319-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="5a319-192">Het Shor-algoritme biedt een snelle manier om grote getallen te vermenigvuldigen met behulp van een quantum computer, een probleem met de naam *factoring*.</span><span class="sxs-lookup"><span data-stu-id="5a319-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="5a319-193">De beveiliging van veel aanwezige dagen cryptosystems is gebaseerd op de veronderstelling dat er geen snelle algoritme bestaat voor factories.</span><span class="sxs-lookup"><span data-stu-id="5a319-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="5a319-194">Het algoritme van Shor heeft een progevonden effect gehad op hoe we de beveiliging in een post-Quantum wereld denken.</span><span class="sxs-lookup"><span data-stu-id="5a319-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="5a319-195">Het Shor-algoritme kan worden beschouwd als een hybride algoritme.</span><span class="sxs-lookup"><span data-stu-id="5a319-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="5a319-196">De quantum computer wordt gebruikt voor het uitvoeren van een reken kundige vaste taak die bekend staat als periode zoeken.</span><span class="sxs-lookup"><span data-stu-id="5a319-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="5a319-197">De resultaten van de periode zoeken worden vervolgens klassiek verwerkt om de factoren te schatten.</span><span class="sxs-lookup"><span data-stu-id="5a319-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="5a319-198">Deze twee stappen worden hieronder besproken.</span><span class="sxs-lookup"><span data-stu-id="5a319-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="5a319-199">Periode zoeken</span><span class="sxs-lookup"><span data-stu-id="5a319-199">Period Finding</span></span> ###

<span data-ttu-id="5a319-200">Gezien hoe de Quantum Fourier-trans formatie en fase schatting werken (Zie [Quantum algoritmen](xref:microsoft.quantum.libraries.standard.algorithms)), kunnen we deze hulpprogram ma's gebruiken om een klassiek probleem op te lossen dat de *periode bevindt*.</span><span class="sxs-lookup"><span data-stu-id="5a319-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="5a319-201">In de volgende sectie wordt beschreven hoe u de periode voor het zoeken kunt Toep assen op factor.</span><span class="sxs-lookup"><span data-stu-id="5a319-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="5a319-202">Als er twee gehele getallen zijn $a $ en $N $, waarbij $a < N $, het doel van het vinden van de periode, ook wel het vinden van orders genoemd, het vinden van de _volg orde_ $r $ van $a $ modulo $N $, waarbij $r $ is gedefinieerd als het minst positieve gehele getal zodat $a ^ r \equiv 1 \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="5a319-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="5a319-203">Om de volg orde te vinden met behulp van een quantum computer, kunnen we het Phase-schattings algoritme gebruiken dat wordt toegepast op de volgende unitary-operator $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \Text{mod} N}. $ $ de eigenvectors van $U _a $ zijn voor een geheel getal $s $ en $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ zijn _eigenstates_ van $U _a $.</span><span class="sxs-lookup"><span data-stu-id="5a319-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="5a319-204">De eigenvalues van $U _a $ $ $ U\_een \ket{x\_s} = e ^ {2 \ Pi i s/r} \ket{x\_s}.</span><span class="sxs-lookup"><span data-stu-id="5a319-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="5a319-205">In de fase-schatting wordt de eigenvalues $e ^ {2 \ Pi i s/r} uitgevoerd, waarbij $r $ op efficiënte wijze kan worden geleerd met behulp van [vervolg breuken](https://en.wikipedia.org/wiki/Continued_fraction) uit $s/r $.</span><span class="sxs-lookup"><span data-stu-id="5a319-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="5a319-206">Het circuit diagram voor het zoeken naar een Quantum periode is:</span><span class="sxs-lookup"><span data-stu-id="5a319-206">The circuit diagram for quantum period finding is:</span></span>

![Circuit diagram voor het zoeken naar Quantum dagen](./../../media/QPE.svg)

<span data-ttu-id="5a319-208">Hier $2n $ qubits worden geïnitialiseerd op $ \ket{0}$ en $n $ qubits worden geïnitialiseerd op $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="5a319-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="5a319-209">De lezer kan u opnieuw vragen waarom het Quantum REGI ster voor de eigenstates wordt geïnitialiseerd op $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="5a319-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="5a319-210">Als één de volg orde $r $ vooraf niet kent, kunnen we de status van $ \ket{x_s} $ niet rechtstreeks voorbereiden.</span><span class="sxs-lookup"><span data-stu-id="5a319-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="5a319-211">Gelukkig is dat $1/\ SQRT {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="5a319-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="5a319-212">$ \Ket{x} $! wordt niet daad werkelijk voor bereid.</span><span class="sxs-lookup"><span data-stu-id="5a319-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="5a319-213">We hebben gewoon een Quantum register van $n $ qubits in status $ \ket{1}$ voor bereid.</span><span class="sxs-lookup"><span data-stu-id="5a319-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="5a319-214">Het circuit bevat de QFT en verschillende bewaakte Gates.</span><span class="sxs-lookup"><span data-stu-id="5a319-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="5a319-215">De QFT-Gate is [eerder](xref:microsoft.quantum.libraries.standard.algorithms)beschreven.</span><span class="sxs-lookup"><span data-stu-id="5a319-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="5a319-216">De Controlled-$U _a $ Gate Maps $ \ket{x} $ to $ \ket{(AX) \Text{mod} N} $ als het besturings element Qubit $ \ket{1}$ is en wijst $ \ket{x} $ toe aan $ \ket{x} $ anders.</span><span class="sxs-lookup"><span data-stu-id="5a319-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="5a319-217">Om $ (a ^ NX) \Text{mod} N $ toe te passen, kunnen we een beheerde $U _ {a ^ N} $ Toep assen, waar we $a ^ N \Text{mod} N $ op klassieke wijze berekenen om in het Quantum circuit aan te sluiten.</span><span class="sxs-lookup"><span data-stu-id="5a319-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="5a319-218">De circuits om dergelijke modulaire reken kundige berekeningen te realiseren, zijn beschreven in de [Quantum reken kundige documentatie](./algorithms.md#arithmetic). er is met name een modulair exponent circuit nodig om de beheerde $U\_{a ^ i} $ bewerkingen te implementeren.</span><span class="sxs-lookup"><span data-stu-id="5a319-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="5a319-219">Hoewel het circuit hierboven overeenkomt met de [Quantum fase-schatting](xref:microsoft.quantum.characterization.quantumphaseestimation) en expliciet het zoeken van bestellingen mogelijk maakt, kunnen we het aantal qubits beperken dat nodig is.</span><span class="sxs-lookup"><span data-stu-id="5a319-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="5a319-220">We kunnen de Beauregard-methode voor het vinden van orders volgen, zoals beschreven [op pagina 8 van arXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), of een van de fase-schattings routines gebruiken die beschikbaar zijn in micro soft. Quantum. karakte Rise ring.</span><span class="sxs-lookup"><span data-stu-id="5a319-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="5a319-221">Een voor beeld van een [Robust Phase-schatting](xref:microsoft.quantum.characterization.robustphaseestimation) maakt bijvoorbeeld ook gebruik van één extra Qubit.</span><span class="sxs-lookup"><span data-stu-id="5a319-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="5a319-222">Waarbij</span><span class="sxs-lookup"><span data-stu-id="5a319-222">Factoring</span></span> ###
<span data-ttu-id="5a319-223">Het doel van factoren is het bepalen van de twee Prime factoren van het gehele getal $N $, waarbij $N $ een $n $-bit-nummer is.</span><span class="sxs-lookup"><span data-stu-id="5a319-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="5a319-224">Factoring bestaat uit de stappen die hieronder worden beschreven.</span><span class="sxs-lookup"><span data-stu-id="5a319-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="5a319-225">De stappen zijn onderverdeeld in drie delen: een klassieke preverwerkings routine (1-4); een quantum computing-routine om de volg orde van $a \Text{mod} te vinden, N $ (5); en een klassieke postprocessing-routine voor het afleiden van de Prime factoren uit de bestelling (6-9).</span><span class="sxs-lookup"><span data-stu-id="5a319-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="5a319-226">De klassieke preverwerkings routine bestaat uit de volgende stappen:</span><span class="sxs-lookup"><span data-stu-id="5a319-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="5a319-227">Als $N $ even is, geeft u de Prime factor $2 $ als resultaat.</span><span class="sxs-lookup"><span data-stu-id="5a319-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="5a319-228">Als $N = p ^ q $ voor $p \geq1 $, $q \geq2 $, geeft u de Prime factor $p $ als resultaat.</span><span class="sxs-lookup"><span data-stu-id="5a319-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="5a319-229">Deze stap wordt klassiek uitgevoerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-229">This step is performed classically.</span></span>
3. <span data-ttu-id="5a319-230">Kies een wille keurig getal $a $ zodanig dat $1 < een < N-$1.</span><span class="sxs-lookup"><span data-stu-id="5a319-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="5a319-231">Als $ \Text{GCD} (a, N) > 1 $, wordt de Prime factor $ \Text{GCD} (a, N) $ geretourneerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="5a319-232">Deze stap wordt berekend met behulp van het algoritme van Euclid.</span><span class="sxs-lookup"><span data-stu-id="5a319-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="5a319-233">Als er geen Prime factor is geretourneerd, gaan we verder met de Quantum-routine:</span><span class="sxs-lookup"><span data-stu-id="5a319-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="5a319-234">Roep het algoritme voor het zoeken naar de Quantum periode aan om de volg orde $r $ van $a \Text{mod} N $ te berekenen.</span><span class="sxs-lookup"><span data-stu-id="5a319-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="5a319-235">Gebruik $r $ in de klassieke postprocessing-routine om de Prime factoren te bepalen:</span><span class="sxs-lookup"><span data-stu-id="5a319-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="5a319-236">Als $r $ oneven is, gaat u terug naar stap voor voor verwerking (3).</span><span class="sxs-lookup"><span data-stu-id="5a319-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="5a319-237">Als $r $ even is en $a ^ {r/2} =-1 \ tekst {mod} N $, gaat u terug naar stap voor voor verwerking (3).</span><span class="sxs-lookup"><span data-stu-id="5a319-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="5a319-238">Als $ \Text{GCD} (a ^ {r/2} + 1, N) $ een niet-triviaische factor van $N $ is, retourneert $ \Text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="5a319-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="5a319-239">Als $ \Text{GCD} (a ^ {r/2}-1, N) $ een niet-triviaische factor van $N $ is, retourneert $ \Text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="5a319-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="5a319-240">De factoring-algoritme is Probabilistic: deze kan worden weer gegeven met een waarschijnlijkheid van ten minste één helft $r $ en $a ^ {r/2} \neq-1 \Text{mod} N $, waardoor er een prime factor wordt geproduceerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="5a319-241">(Zie [het oorspronkelijke document van Shor](https://doi.org/10.1109/SFCS.1994.365700) voor meer informatie of een van de basis teksten van *Quantum Computing* in [voor meer gegevens](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="5a319-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="5a319-242">Als er geen Prime factor wordt geretourneerd, herhaalt u de algoritme gewoon uit stap (1).</span><span class="sxs-lookup"><span data-stu-id="5a319-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="5a319-243">Na $n $ probeert, is de kans dat elke poging is mislukt Maxi maal $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="5a319-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="5a319-244">Na het herhalen van het algoritme is het echter een klein aantal keren dat succes is gegarandeerd.</span><span class="sxs-lookup"><span data-stu-id="5a319-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
