### YamlMime:QSharpType
uid: microsoft.quantum.canon.controlledonbitstring
name: ControlledOnBitString
type: function
namespace: Microsoft.Quantum.Canon
summary: >-
  Retourneert een unitary-operator die een Oracle toepast op het doel register als de register status van het besturings element overeenkomt met een opgegeven bitmasker.


  De uitvoer van deze functie kan worden weer gegeven met een unitary-trans formatie $U $ zodanig dat \begin{align} U \ket{b_0 b_1 \cdots b_ {n-1}} \ket{\psi} = \ket{b_0 b_1 \cdots b_ {n-1}} \otimes \begin{cases} V \ket{\psi} & \textrm{if} (b_0 b_1 \cdots b_ {n-1}) = \texttt{bits} \\\\ \ket{\psi} & \textrm{otherwise} \end{cases}, \end{align} waarbij $V $ een unitary-trans formatie is die de actie vertegenwoordigt van de `oracle` bewerking.
remarks: >-
  De lengte van `bits` en `controlRegister` moet gelijk zijn.


  Op basis van een Boole-matrix `bits` en een unitary-bewerking `oracle`, is de uitvoer van deze functie een bewerking die de volgende stappen uitvoert:


  * pas een `X` bewerking toe op elk Qubit van het controle register dat overeenkomt met `false` element van de `bits`;

  * `Controlled oracle` Toep assen op het besturings element en de doel registers;

  * pas een `X` bewerking toe op elke qubit van het controle register dat overeenkomt met het `false` element van de `bits` opnieuw om het controle register te retour neren naar de oorspronkelijke staat.


  De uitvoer van de `Controlled` functor is een speciaal geval van `ControlledOnBitString` waarbij `bits` gelijk is aan `[true, ..., true]`.
examples: >-
  De volgende code fragmenten zijn gelijk:


  ```qsharp

  (ControlledOnBitString(bits, oracle))(controlRegister, targetRegister);

  ```


  en


  ```qsharp

  within {
      ApplyPauliFromBitString(PauliX, false, bits, controlRegister);
  } apply {
      Controlled oracle(controlRegister, targetRegister);
  }

  ```


  Met de volgende code wordt een status voor bereid op $ \frac{1}{2}(\ket{00}-\ket{01} + \ket{10} + \ket{11}) $:


  ```qsharp

  using (register = Qubit[2]) {
      ApplyToEach(H, register);
      (ControlledOnBitString([false], Z))(register[0..0], register[1]);
  }

  ```
syntax: "function ControlledOnBitString (bits : Bool[], oracle : ('T => Unit is Adj + Ctl)) : ((Qubit[], 'T) => Unit is Adj + Ctl)"
input:
  content: "(bits : Bool[], oracle : ('T => Unit is Adj + Ctl))"
  types:
  - name: bits
    summary: De bit-teken reeks voor het beheren van de opgegeven unitary-operator in.
    isArray: true
    isPrimitive: true
    uid: Bool
  - name: oracle
    summary: De unitary-operator die moet worden toegepast op de doel register.
    isOperation: true
    input:
      types:
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
output:
  content: ((Qubit[], 'T) => Unit is Adj + Ctl)
  types:
  - summary: Een unitary-operator waarmee `oracle` wordt toegepast op het doel register als de register status van het besturings element overeenkomt met het bitmasker `bits`.
    isOperation: true
    input:
      types:
      - isArray: true
        isPrimitive: true
        uid: Qubit
      - uid: "'T"
        isLocal: true
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
metadata:
  ms.openlocfilehash: dde246a6eb0cf5e278cd079ff52c3a0b0ff71120
  ms.sourcegitcommit: b7e205aaa7fa1ca9f0daa163e46154945f4bc965
  ms.translationtype: MT
  ms.contentlocale: nl-NL
  ms.lasthandoff: 02/18/2020
  ms.locfileid: "77441060"
